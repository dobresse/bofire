{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>BoFire is a framework to define and solve black-box optimization problems.  These problems can arise in a number of closely related fields including experimental design, multi-objective optimization and active learning.</p> <p>BoFire problem specifications are json serializable for use in RESTful APIs and are to a large extent agnostic to the specific methods and frameworks in which the problems are solved.</p> <p>You can find code-examples in the Getting Started section of this document, as well as full worked-out examples of code-usage in the /tutorials section of this repository!</p>"},{"location":"#experimental-design","title":"Experimental design","text":"<p>In the context of experimental design BoFire allows to define a design space</p> \\[ \\mathbb{X} = x_1 \\otimes x_2 \\ldots \\otimes x_D \\] <p>where the design parameters may take values depending on their type and domain, e.g.</p> <ul> <li>continuous: \\(x_1 \\in [0, 1]\\)</li> <li>discrete: \\(x_2 \\in \\{1, 2, 5, 7.5\\}\\)</li> <li>categorical: \\(x_3 \\in \\{A, B, C\\}\\)</li> </ul> <p>and a set of equations define additional experimental constraints, e.g.</p> <ul> <li>linear equality: \\(\\sum x_i = 1\\)</li> <li>linear inequality: \\(2 x_1 \\leq x_2\\)</li> <li>non-linear inequality: \\(\\sum x_i^2 \\leq 1\\)</li> <li>n-choose-k: only \\(k\\) out of \\(n\\) parameters can take non-zero values.</li> </ul>"},{"location":"#multi-objective-optimization","title":"Multi-objective optimization","text":"<p>In the context of multi-objective optimization BoFire allows to define a vector-valued optimization problem</p> \\[ \\min_{x \\in \\mathbb{X}} s(y(x)) \\] <p>where</p> <ul> <li>\\(x \\in \\mathbb{X}\\) is again the experimental design space</li> <li>\\(y = \\{y_1, \\ldots y_M\\}\\) are known functions describing your experimental outputs and</li> <li>\\(s = \\{s_1, \\ldots s_M\\}\\) are the objectives to be minimized, e.g. \\(s_1\\) is the identity function if \\(y_1\\) is to be minimized.</li> </ul> <p>Since the objectives are in general conflicting, there is no point \\(x\\) that simultaneously optimizes all objectives. Instead the goal is to find the Pareto front of all optimal compromises.</p> <p>A decision maker can then explore these compromises to get a deep understanding of the problem and make the best informed decision.</p>"},{"location":"#bayesian-optimization","title":"Bayesian optimization","text":"<p>In the context of Bayesian optimization we want to simultaneously learn the unknown function \\(y(x)\\) (exploration), while focusing the experimental effort on promising regions (exploitation). This is done by using the experimental data to fit a probabilistic model \\(p(y|x, {data})\\) that estimates the distribution of possible outcomes for \\(y\\). An acquisition function \\(a\\) then formulates the desired trade-off between exploration and exploitation</p> \\[ \\min_{x \\in \\mathbb{X}} a(s(p_y(x))) \\] <p>and the minimizer \\(x_\\mathrm{opt}\\) of this acquisition function determines the next experiment \\(y(x)\\) to run.</p> <p>When there are multiple competing objectives, the task is again to find a suitable approximation of the Pareto front.</p>"},{"location":"#design-of-experiments","title":"Design of Experiments","text":"<p>BoFire can be used to generate optimal experimental designs with respect to various optimality criteria like D-optimality, A-optimality or uniform space filling.</p> <p>For this, the user specifies a design space and a model formula, then chooses an optimality criterion and the desired number of experiments in the design. The resulting optimization problem is then solved by IPOPT.</p> <p>The doe subpackage also supports a wide range of constraints on the design space including linear and nonlinear equalities and inequalities as well a (limited) use of NChooseK constraints. The user can provide fixed experiments that will be treated as part of the design but remain fixed during the optimization process. Design spaces that contain design variables which are not continuous are currently not supported.</p>"},{"location":"basic_examples/","title":"Basic Examples for the DoE Subpackage","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FormatStrFormatter\n\nfrom bofire.data_models.constraints.api import (\n    NonlinearEqualityConstraint,\n    NonlinearInequalityConstraint,\n    LinearEqualityConstraint,\n    LinearInequalityConstraint,\n)\nfrom bofire.data_models.domain.api import Domain\nfrom bofire.data_models.features.api import ContinuousInput, ContinuousOutput\nfrom bofire.strategies.doe.design import find_local_max_ipopt\n</pre> import numpy as np import matplotlib.pyplot as plt from matplotlib.ticker import FormatStrFormatter  from bofire.data_models.constraints.api import (     NonlinearEqualityConstraint,     NonlinearInequalityConstraint,     LinearEqualityConstraint,     LinearInequalityConstraint, ) from bofire.data_models.domain.api import Domain from bofire.data_models.features.api import ContinuousInput, ContinuousOutput from bofire.strategies.doe.design import find_local_max_ipopt <pre>/home/aaron/Desktop/bofire/bofire/utils/cheminformatics.py:10: UserWarning: rdkit not installed, BoFire's cheminformatics utilities cannot be used.\n  warnings.warn(\n/home/aaron/anaconda3/envs/bofire/lib/python3.11/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[2]: Copied! <pre>domain = Domain(\n   inputs = [\n    ContinuousInput(key=\"x1\", bounds = (0,1)),\n    ContinuousInput(key=\"x2\", bounds = (0.1, 1)),\n    ContinuousInput(key=\"x3\", bounds = (0, 0.6))\n    ],\n   outputs = [ContinuousOutput(key=\"y\")],\n   constraints = [\n       LinearEqualityConstraint(features=[\"x1\",\"x2\",\"x3\"], coefficients=[1,1,1], rhs=1),\n       LinearInequalityConstraint(features=[\"x1\",\"x2\"], coefficients=[5,4], rhs=3.9),\n       LinearInequalityConstraint(features=[\"x1\",\"x2\"], coefficients=[-20,5], rhs=-3)\n   ]\n)\n\nd_optimal_design = find_local_max_ipopt(domain, \"linear\", n_experiments=12, ipopt_options={\"disp\":0}).to_numpy().T\n</pre> domain = Domain(    inputs = [     ContinuousInput(key=\"x1\", bounds = (0,1)),     ContinuousInput(key=\"x2\", bounds = (0.1, 1)),     ContinuousInput(key=\"x3\", bounds = (0, 0.6))     ],    outputs = [ContinuousOutput(key=\"y\")],    constraints = [        LinearEqualityConstraint(features=[\"x1\",\"x2\",\"x3\"], coefficients=[1,1,1], rhs=1),        LinearInequalityConstraint(features=[\"x1\",\"x2\"], coefficients=[5,4], rhs=3.9),        LinearInequalityConstraint(features=[\"x1\",\"x2\"], coefficients=[-20,5], rhs=-3)    ] )  d_optimal_design = find_local_max_ipopt(domain, \"linear\", n_experiments=12, ipopt_options={\"disp\":0}).to_numpy().T <pre>\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n******************************************************************************\n\n</pre> In\u00a0[3]: Copied! <pre>fig = plt.figure(figsize=((10,10)))\nax = fig.add_subplot(111, projection='3d')\nax.view_init(45, 45)\nax.set_title(\"Linear model\")\nax.set_xlabel(\"$x_1$\")\nax.set_ylabel(\"$x_2$\")\nax.set_zlabel(\"$x_3$\")\nplt.rcParams[\"figure.figsize\"] = (10,8)\n\n#plot feasible polytope\nax.plot(\n    xs=[7/10, 3/10, 1/5, 3/10, 7/10],\n    ys=[1/10, 3/5, 1/5, 1/10, 1/10],\n    zs=[1/5, 1/10, 3/5, 3/5, 1/5],\n    linewidth=2\n)\n\n#plot D-optimal solutions\nax.scatter(\n    xs=d_optimal_design[0],\n    ys=d_optimal_design[1],\n    zs=d_optimal_design[2],\n    marker=\"o\",\n    s=40,\n    color=\"orange\",\n    label=\"optimal_design solution, 12 points\"\n)\n\nplt.legend()\n</pre> fig = plt.figure(figsize=((10,10))) ax = fig.add_subplot(111, projection='3d') ax.view_init(45, 45) ax.set_title(\"Linear model\") ax.set_xlabel(\"$x_1$\") ax.set_ylabel(\"$x_2$\") ax.set_zlabel(\"$x_3$\") plt.rcParams[\"figure.figsize\"] = (10,8)  #plot feasible polytope ax.plot(     xs=[7/10, 3/10, 1/5, 3/10, 7/10],     ys=[1/10, 3/5, 1/5, 1/10, 1/10],     zs=[1/5, 1/10, 3/5, 3/5, 1/5],     linewidth=2 )  #plot D-optimal solutions ax.scatter(     xs=d_optimal_design[0],     ys=d_optimal_design[1],     zs=d_optimal_design[2],     marker=\"o\",     s=40,     color=\"orange\",     label=\"optimal_design solution, 12 points\" )  plt.legend() Out[3]: <pre>&lt;matplotlib.legend.Legend at 0x7fb56db6a010&gt;</pre> In\u00a0[4]: Copied! <pre>d_optimal_design = find_local_max_ipopt(domain, \"x1 + x2 + x3 + {x1**2} + {x2**2} + {x3**2} + {x1**3} + {x2**3} + {x3**3} + x1:x2 + x1:x3 + x2:x3 + x1:x2:x3\", n_experiments=12).to_numpy().T\n\nd_opt = np.array([\n    [0.7, 0.3, 0.2, 0.3, 0.5902, 0.4098, 0.2702, 0.2279, 0.4118, 0.5738, 0.4211, 0.3360],\n    [0.1, 0.6, 0.2, 0.1, 0.2373, 0.4628, 0.4808, 0.3117, 0.1, 0.1, 0.2911, 0.2264],\n    [0.2, 0.1, 0.6, 0.6, 0.1725, 0.1274, 0.249, 0.4604, 0.4882, 0.3262, 0.2878, 0.4376],\n]) # values taken from paper\n\n\nfig = plt.figure(figsize=((10,10)))\nax = fig.add_subplot(111, projection='3d')\nax.set_title(\"cubic model\")\nax.view_init(45, 45)\nax.set_xlabel(\"$x_1$\")\nax.set_ylabel(\"$x_2$\")\nax.set_zlabel(\"$x_3$\")\nplt.rcParams[\"figure.figsize\"] = (10,8)\n\n#plot feasible polytope\nax.plot(\n    xs=[7/10, 3/10, 1/5, 3/10, 7/10],\n    ys=[1/10, 3/5, 1/5, 1/10, 1/10],\n    zs=[1/5, 1/10, 3/5, 3/5, 1/5],\n    linewidth=2\n)\n\n#plot D-optimal solution\nax.scatter(\n    xs=d_opt[0],\n    ys=d_opt[1],\n    zs=d_opt[2],\n    marker=\"o\",\n    s=40,\n    color=\"darkgreen\",\n    label=\"D-optimal design, 12 points\"\n)\n\nax.scatter(\n    xs=d_optimal_design[0],\n    ys=d_optimal_design[1],\n    zs=d_optimal_design[2],\n    marker=\"o\",\n    s=40,\n    color=\"orange\",\n    label=\"optimal_design solution, 12 points\"\n)\n\nplt.legend()\n</pre> d_optimal_design = find_local_max_ipopt(domain, \"x1 + x2 + x3 + {x1**2} + {x2**2} + {x3**2} + {x1**3} + {x2**3} + {x3**3} + x1:x2 + x1:x3 + x2:x3 + x1:x2:x3\", n_experiments=12).to_numpy().T  d_opt = np.array([     [0.7, 0.3, 0.2, 0.3, 0.5902, 0.4098, 0.2702, 0.2279, 0.4118, 0.5738, 0.4211, 0.3360],     [0.1, 0.6, 0.2, 0.1, 0.2373, 0.4628, 0.4808, 0.3117, 0.1, 0.1, 0.2911, 0.2264],     [0.2, 0.1, 0.6, 0.6, 0.1725, 0.1274, 0.249, 0.4604, 0.4882, 0.3262, 0.2878, 0.4376], ]) # values taken from paper   fig = plt.figure(figsize=((10,10))) ax = fig.add_subplot(111, projection='3d') ax.set_title(\"cubic model\") ax.view_init(45, 45) ax.set_xlabel(\"$x_1$\") ax.set_ylabel(\"$x_2$\") ax.set_zlabel(\"$x_3$\") plt.rcParams[\"figure.figsize\"] = (10,8)  #plot feasible polytope ax.plot(     xs=[7/10, 3/10, 1/5, 3/10, 7/10],     ys=[1/10, 3/5, 1/5, 1/10, 1/10],     zs=[1/5, 1/10, 3/5, 3/5, 1/5],     linewidth=2 )  #plot D-optimal solution ax.scatter(     xs=d_opt[0],     ys=d_opt[1],     zs=d_opt[2],     marker=\"o\",     s=40,     color=\"darkgreen\",     label=\"D-optimal design, 12 points\" )  ax.scatter(     xs=d_optimal_design[0],     ys=d_optimal_design[1],     zs=d_optimal_design[2],     marker=\"o\",     s=40,     color=\"orange\",     label=\"optimal_design solution, 12 points\" )  plt.legend() <pre>/home/aaron/Desktop/bofire/bofire/strategies/doe/design.py:241: UserWarning: The minimum number of experiments is 17, but the current setting is n_experiments=12.\n  warnings.warn(\n</pre> Out[4]: <pre>&lt;matplotlib.legend.Legend at 0x7fb56a01b3d0&gt;</pre> In\u00a0[5]: Copied! <pre>def plot_results_3d(result, surface_func):\n    u, v = np.mgrid[0 : 2 * np.pi : 100j, 0 : np.pi : 80j]\n    X = np.cos(u) * np.sin(v)\n    Y = np.sin(u) * np.sin(v)\n    Z = surface_func(X, Y)\n\n    fig = plt.figure(figsize=(8, 8))\n    ax = fig.add_subplot(111, projection=\"3d\")\n    ax.plot_surface(X, Y, Z, alpha=0.3)\n    ax.scatter(\n        xs=result[\"x1\"],\n        ys=result[\"x2\"],\n        zs=result[\"x3\"],\n        marker=\"o\",\n        s=40,\n        color=\"red\",\n    )\n    ax.set(xlabel=\"x1\", ylabel=\"x2\", zlabel=\"x3\")\n    ax.xaxis.set_major_formatter(FormatStrFormatter('%.2f'))\n    ax.yaxis.set_major_formatter(FormatStrFormatter('%.2f'))\n</pre> def plot_results_3d(result, surface_func):     u, v = np.mgrid[0 : 2 * np.pi : 100j, 0 : np.pi : 80j]     X = np.cos(u) * np.sin(v)     Y = np.sin(u) * np.sin(v)     Z = surface_func(X, Y)      fig = plt.figure(figsize=(8, 8))     ax = fig.add_subplot(111, projection=\"3d\")     ax.plot_surface(X, Y, Z, alpha=0.3)     ax.scatter(         xs=result[\"x1\"],         ys=result[\"x2\"],         zs=result[\"x3\"],         marker=\"o\",         s=40,         color=\"red\",     )     ax.set(xlabel=\"x1\", ylabel=\"x2\", zlabel=\"x3\")     ax.xaxis.set_major_formatter(FormatStrFormatter('%.2f'))     ax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')) In\u00a0[6]: Copied! <pre>domain = Domain(\n    inputs=[\n        ContinuousInput(key=\"x1\", bounds = (-1,1)),\n        ContinuousInput(key=\"x2\", bounds = (-1,1)),\n        ContinuousInput(key=\"x3\", bounds = (0,1))],\n    outputs=[ContinuousOutput(key=\"y\")],\n    constraints=[NonlinearInequalityConstraint(expression=\"(x1**2 + x2**2)**0.5 - x3\", features=[\"x1\",\"x2\",\"x3\"])],\n)\n\nresult = find_local_max_ipopt(domain, \"linear\", ipopt_options={\"maxiter\": 100, \"disp\":0})\nresult.round(3)\nplot_results_3d(result, surface_func=lambda x1, x2: np.sqrt(x1**2 + x2**2))\n</pre> domain = Domain(     inputs=[         ContinuousInput(key=\"x1\", bounds = (-1,1)),         ContinuousInput(key=\"x2\", bounds = (-1,1)),         ContinuousInput(key=\"x3\", bounds = (0,1))],     outputs=[ContinuousOutput(key=\"y\")],     constraints=[NonlinearInequalityConstraint(expression=\"(x1**2 + x2**2)**0.5 - x3\", features=[\"x1\",\"x2\",\"x3\"])], )  result = find_local_max_ipopt(domain, \"linear\", ipopt_options={\"maxiter\": 100, \"disp\":0}) result.round(3) plot_results_3d(result, surface_func=lambda x1, x2: np.sqrt(x1**2 + x2**2)) <pre>/home/aaron/Desktop/bofire/bofire/strategies/doe/design.py:71: UserWarning: Nonlinear constraints were detected. Not all features and checks are supported for this type of constraints.                 Using them can lead to unexpected behaviour. Please make sure to provide jacobians for nonlinear constraints.\n  warnings.warn(\n/home/aaron/Desktop/bofire/bofire/strategies/doe/design.py:103: UserWarning: Sampling failed. Falling back to uniform sampling on input domain.                          Providing a custom sampling strategy compatible with the problem can                           possibly improve performance.\n  warnings.warn(\n</pre> <p>And the same for a design space limited by an elliptical cone $x_1^2 + x_2^2 - x_3 \\leq 0$.</p> In\u00a0[7]: Copied! <pre>domain = Domain(\n    inputs=[\n        ContinuousInput(key=\"x1\", bounds = (-1,1)),\n        ContinuousInput(key=\"x2\", bounds = (-1,1)),\n        ContinuousInput(key=\"x3\", bounds = (0,1))],\n    outputs=[ContinuousOutput(key=\"y\")],\n    constraints=[NonlinearInequalityConstraint(expression=\"x1**2 + x2**2 - x3\", features=[\"x1\",\"x2\",\"x3\"])],\n)\n\nresult = find_local_max_ipopt(domain, \"linear\", ipopt_options={\"maxiter\": 100})\nresult.round(3)\nplot_results_3d(result, surface_func=lambda x1, x2: x1**2 + x2**2)\n</pre> domain = Domain(     inputs=[         ContinuousInput(key=\"x1\", bounds = (-1,1)),         ContinuousInput(key=\"x2\", bounds = (-1,1)),         ContinuousInput(key=\"x3\", bounds = (0,1))],     outputs=[ContinuousOutput(key=\"y\")],     constraints=[NonlinearInequalityConstraint(expression=\"x1**2 + x2**2 - x3\", features=[\"x1\",\"x2\",\"x3\"])], )  result = find_local_max_ipopt(domain, \"linear\", ipopt_options={\"maxiter\": 100}) result.round(3) plot_results_3d(result, surface_func=lambda x1, x2: x1**2 + x2**2) <pre>/home/aaron/Desktop/bofire/bofire/strategies/doe/design.py:71: UserWarning: Nonlinear constraints were detected. Not all features and checks are supported for this type of constraints.                 Using them can lead to unexpected behaviour. Please make sure to provide jacobians for nonlinear constraints.\n  warnings.warn(\n/home/aaron/Desktop/bofire/bofire/strategies/doe/design.py:103: UserWarning: Sampling failed. Falling back to uniform sampling on input domain.                          Providing a custom sampling strategy compatible with the problem can                           possibly improve performance.\n  warnings.warn(\n</pre> In\u00a0[8]: Copied! <pre>domain = Domain(\n    inputs=[\n        ContinuousInput(key=\"x1\", bounds = (-1,1)),\n        ContinuousInput(key=\"x2\", bounds = (-1,1)),\n        ContinuousInput(key=\"x3\", bounds = (0,1))],\n    outputs=[ContinuousOutput(key=\"y\")],\n    constraints=[NonlinearEqualityConstraint(expression=\"(x1**2 + x2**2)**0.5 - x3\", features=[\"x1\",\"x2\",\"x3\"])],\n)\n\nresult = find_local_max_ipopt(domain, \"linear\", ipopt_options={\"maxiter\": 100})\nresult.round(3)\nplot_results_3d(result, surface_func=lambda x1, x2: np.sqrt(x1**2 + x2**2))\n</pre> domain = Domain(     inputs=[         ContinuousInput(key=\"x1\", bounds = (-1,1)),         ContinuousInput(key=\"x2\", bounds = (-1,1)),         ContinuousInput(key=\"x3\", bounds = (0,1))],     outputs=[ContinuousOutput(key=\"y\")],     constraints=[NonlinearEqualityConstraint(expression=\"(x1**2 + x2**2)**0.5 - x3\", features=[\"x1\",\"x2\",\"x3\"])], )  result = find_local_max_ipopt(domain, \"linear\", ipopt_options={\"maxiter\": 100}) result.round(3) plot_results_3d(result, surface_func=lambda x1, x2: np.sqrt(x1**2 + x2**2)) <pre>/home/aaron/Desktop/bofire/bofire/strategies/doe/design.py:71: UserWarning: Nonlinear constraints were detected. Not all features and checks are supported for this type of constraints.                 Using them can lead to unexpected behaviour. Please make sure to provide jacobians for nonlinear constraints.\n  warnings.warn(\n/home/aaron/Desktop/bofire/bofire/strategies/doe/design.py:103: UserWarning: Sampling failed. Falling back to uniform sampling on input domain.                          Providing a custom sampling strategy compatible with the problem can                           possibly improve performance.\n  warnings.warn(\n</pre>"},{"location":"basic_examples/#basic-examples-for-the-doe-subpackage","title":"Basic Examples for the DoE Subpackage\u00b6","text":"<p>The following example has been taken from the paper \"The construction of D- and I-optimal designs for mixture experiments with linear constraints on the components\" by R. Coetzer and L. M. Haines.</p>"},{"location":"basic_examples/#linear-model","title":"linear model\u00b6","text":""},{"location":"basic_examples/#cubic-model","title":"cubic model\u00b6","text":""},{"location":"basic_examples/#nonlinear-constraints","title":"Nonlinear Constraints\u00b6","text":"<p>IPOPT also supports nonlinear constraints. This notebook shows examples of design optimizations with nonlinear constraints.</p>"},{"location":"basic_examples/#example-1-design-inside-a-cone-nonlinear-inequality","title":"Example 1: Design inside a cone / nonlinear inequality\u00b6","text":"<p>In the following example we have three design variables. We impose the constraint of all experiments to be contained in the interior of a cone, which corresponds the nonlinear inequality constraint $\\sqrt{x_1^2 + x_2^2} - x_3 \\leq 0$. The optimization is done for a linear model and places the points on the surface of the cone so as to maximize the between them</p>"},{"location":"basic_examples/#example-2-design-on-the-surface-of-a-cone-nonlinear-equality","title":"Example 2: Design on the surface of a cone / nonlinear equality\u00b6","text":"<p>We can also limit the design space to the surface of a cone, defined by the equality constraint $\\sqrt{x_1^2 + x_2^2} - x_3 = 0$</p> <p>Note that due to missing sampling methods in opti, the initial points provided to IPOPT don't satisfy the constraints.</p>"},{"location":"data_models_functionals/","title":"Data Models vs. Functional Components","text":"<p>Data models in BoFire hold static data of an optimization problem. These are input and output features as well as constraints making up the domain. They further include possible optimization objectives, acquisition functions, and kernels.</p> <p>All data models in <code>bofire.data_models</code>, are specified as pydantic models and inherit from <code>bofire.data_models.base.BaseModel</code>. These data models can be (de)serialized via <code>.dict()</code> and <code>.json()</code> (provided by pydantic). A json schema of each data model can be obtained using <code>.schema()</code>.</p> <p>For surrogates and strategies, all functional parts are located in <code>bofire.surrogates</code> and <code>bofire.strategies</code>. These functionalities include the <code>ask</code> and <code>tell</code> as well as <code>fit</code> and <code>predict</code> methods. All class attributes (used by these method) are also removed from the data models. Each functional entity is initialized using the corresponding data model. As an example, consider the following data model of a <code>RandomStrategy</code>:</p> <pre><code>import bofire.data_models.domain.api as dm_domain\nimport bofire.data_models.features.api as dm_features\nimport bofire.data_models.strategies.api as dm_strategies\n\nin1 = dm_features.ContinuousInput(key=\"in1\", bounds=(0.0,1.0))\nin2 = dm_features.ContinuousInput(key=\"in2\", bounds=(0.0,2.0))\nin3 = dm_features.ContinuousInput(key=\"in3\", bounds=(0.0,3.0))\n\nout1 = dm_features.ContinuousOutput(key=\"out1\")\n\ninputs = dm_domain.Inputs(features=[in1, in2, in3])\noutputs = dm_domain.Outputs(features=[out1])\nconstraints = dm_domain.Constraints()\n\ndomain = dm_domain.Domain(\n    inputs=inputs,\n    outputs=outputs,\n    constraints=constraints,\n)\n\ndata_model = dm_strategies.RandomStrategy(domain=domain)\n</code></pre> <p>Such a data model can be (de)serialized as follows:</p> <pre><code>import json\nfrom pydantic import parse_obj_as\nfrom bofire.data_models.strategies.api import AnyStrategy\n\nserialized = data_model.json()\ndata = json.loads(serialized)\n# alternative: data = data_model.dict()\ndata_model_ = parse_obj_as(AnyStrategy, data)\nassert data_model_ == data_model\n</code></pre> <p>Using this data model of a strategy, we can create an instance of a (functional) strategy:</p> <pre><code>import bofire.strategies.api as strategies\nstrategy = strategies.RandomStrategy(data_model=data_model)\n</code></pre> <p>As each strategy data model should be mapped to a specific (functional) strategy, we provide such a mapping:</p> <pre><code>strategy = strategies.map(data_model)\n</code></pre>"},{"location":"design_with_explicit_formula/","title":"Design with explicit Formula","text":"In\u00a0[1]: Copied! <pre>from bofire.data_models.api import Domain, Inputs\nfrom bofire.data_models.features.api import ContinuousInput\nfrom bofire.strategies.doe.design import find_local_max_ipopt\nfrom formulaic import Formula\nfrom sklearn.preprocessing import MinMaxScaler\nimport itertools\nimport pandas as pd\nfrom bofire.utils.doe import get_confounding_matrix\n</pre> from bofire.data_models.api import Domain, Inputs from bofire.data_models.features.api import ContinuousInput from bofire.strategies.doe.design import find_local_max_ipopt from formulaic import Formula from sklearn.preprocessing import MinMaxScaler import itertools import pandas as pd from bofire.utils.doe import get_confounding_matrix <pre>/opt/homebrew/Caskroom/miniforge/base/envs/bofire/lib/python3.10/site-packages/tqdm/auto.py:22: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[2]: Copied! <pre>input_features=Inputs(\n        features=[\n            ContinuousInput(key=\"a\", bounds = (0,5)),\n            ContinuousInput(key=\"b\", bounds= (40, 800)),\n            ContinuousInput(key=\"c\", bounds= (80,180)),\n            ContinuousInput(key=\"d\", bounds = (200,800)),\n        ]  \n    )\ndomain = Domain(inputs=input_features)\n</pre> input_features=Inputs(         features=[             ContinuousInput(key=\"a\", bounds = (0,5)),             ContinuousInput(key=\"b\", bounds= (40, 800)),             ContinuousInput(key=\"c\", bounds= (80,180)),             ContinuousInput(key=\"d\", bounds = (200,800)),         ]       ) domain = Domain(inputs=input_features) In\u00a0[3]: Copied! <pre>model_type = Formula(\"a + {a**2} + b + c + d + a:b + a:c + a:d + b:c + b:d + c:d\")\nmodel_type\n</pre> model_type = Formula(\"a + {a**2} + b + c + d + a:b + a:c + a:d + b:c + b:d + c:d\") model_type  Out[3]: <pre>1 + a + a**2 + b + c + d + a:b + a:c + a:d + b:c + b:d + c:d</pre> In\u00a0[4]: Copied! <pre>design = find_local_max_ipopt(domain=domain, model_type=model_type, n_experiments=17)\ndesign\n</pre> design = find_local_max_ipopt(domain=domain, model_type=model_type, n_experiments=17) design <pre>\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n******************************************************************************\n\n</pre> Out[4]: a b c d exp0 5.000000e+00 40.000000 180.000002 199.999998 exp1 2.500000e+00 800.000008 79.999999 800.000008 exp2 -9.972222e-09 800.000008 180.000002 199.999998 exp3 5.000000e+00 800.000008 180.000002 800.000008 exp4 -9.975610e-09 40.000000 180.000002 199.999998 exp5 -9.975610e-09 800.000008 180.000002 800.000008 exp6 2.500000e+00 800.000008 180.000002 199.999998 exp7 5.000000e+00 40.000000 79.999999 800.000008 exp8 5.000000e+00 800.000008 79.999999 199.999998 exp9 -9.750000e-09 40.000000 79.999999 199.999998 exp10 -9.975610e-09 800.000008 79.999999 199.999998 exp11 -9.975610e-09 40.000000 79.999999 800.000008 exp12 5.000000e+00 800.000008 79.999999 800.000008 exp13 2.500000e+00 40.000000 180.000002 800.000008 exp14 5.000000e+00 40.000000 79.999999 199.999998 exp15 -9.972222e-09 800.000008 79.999999 800.000008 exp16 5.000000e+00 800.000008 180.000002 199.999998 In\u00a0[6]: Copied! <pre>import matplotlib.pyplot as plt\nimport matplotlib\nmatplotlib.rcParams[\"figure.dpi\"] = 120\n\nm = get_confounding_matrix(domain.inputs, design=design, interactions=[2,3], powers=[2])\n\n# do this when seaborn is installed, which is not the case in the tests\n#import seaborn as sns\n#sns.heatmap(m, annot=True, annot_kws={\"fontsize\":7},fmt=\"2.1f\")\n#plt.show()\n</pre> import matplotlib.pyplot as plt import matplotlib matplotlib.rcParams[\"figure.dpi\"] = 120  m = get_confounding_matrix(domain.inputs, design=design, interactions=[2,3], powers=[2])  # do this when seaborn is installed, which is not the case in the tests #import seaborn as sns #sns.heatmap(m, annot=True, annot_kws={\"fontsize\":7},fmt=\"2.1f\") #plt.show()  In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"design_with_explicit_formula/#design-with-explicit-formula","title":"Design with explicit Formula\u00b6","text":"<p>This tutorial notebook shows how to setup a D-optimal design with BoFire while providing an explicit formula and not just one of the four available keywords <code>linear</code>, <code>linear-and-interaction</code>, <code>linear-and-quadratic</code>, <code>fully-quadratic</code>.</p> <p>Make sure that <code>cyipopt</code>is installed. The recommend way is the installation via conda <code>conda install -c conda-forge cyipopt</code>.</p>"},{"location":"design_with_explicit_formula/#imports","title":"Imports\u00b6","text":""},{"location":"design_with_explicit_formula/#setup-of-the-problem","title":"Setup of the problem\u00b6","text":""},{"location":"design_with_explicit_formula/#defintion-of-the-formula-for-which-the-optimal-points-should-be-found","title":"Defintion of the formula for which the optimal points should be found\u00b6","text":""},{"location":"design_with_explicit_formula/#find-d-optimal-design","title":"Find D-optimal Design\u00b6","text":""},{"location":"design_with_explicit_formula/#analyze-confounding","title":"Analyze Confounding\u00b6","text":""},{"location":"examples/","title":"Examples","text":"<p>This is a collection of code examples to allow for an easy exploration of the functionalities that BoFire offers.</p>"},{"location":"examples/#doe","title":"DoE","text":"<ul> <li>creating designs for constrained design spaces</li> <li>optimizing designs with respect to various optimality criteria</li> <li>creating designs for a custom model</li> <li>creating designs with NChooseK constraints</li> </ul>"},{"location":"getting_started/","title":"Getting started","text":"In\u00a0[1]: Copied! <pre>from bofire.data_models.features.api import ContinuousInput, DiscreteInput, CategoricalInput, CategoricalDescriptorInput\n\nx1 = ContinuousInput(key=\"x1\", bounds=(0,1))\nx2 = ContinuousInput(key=\"x2\", bounds=(0,1))\nx3 = ContinuousInput(key=\"x3\", bounds=(0,1))\nx4 = DiscreteInput(key=\"x4\", values=[1, 2, 5, 7.5])\nx5 = CategoricalInput(key=\"x5\", categories=[\"A\", \"B\", \"C\"], allowed=[True,True,False])\nx6 = CategoricalDescriptorInput(key=\"x6\", categories=[\"c1\", \"c2\", \"c3\"], descriptors=[\"d1\", \"d2\"], values = [[1,2],[2,5],[1,7]])\n</pre> from bofire.data_models.features.api import ContinuousInput, DiscreteInput, CategoricalInput, CategoricalDescriptorInput  x1 = ContinuousInput(key=\"x1\", bounds=(0,1)) x2 = ContinuousInput(key=\"x2\", bounds=(0,1)) x3 = ContinuousInput(key=\"x3\", bounds=(0,1)) x4 = DiscreteInput(key=\"x4\", values=[1, 2, 5, 7.5]) x5 = CategoricalInput(key=\"x5\", categories=[\"A\", \"B\", \"C\"], allowed=[True,True,False]) x6 = CategoricalDescriptorInput(key=\"x6\", categories=[\"c1\", \"c2\", \"c3\"], descriptors=[\"d1\", \"d2\"], values = [[1,2],[2,5],[1,7]]) <p>As output features, currently only continuous output features are supported. Each output feature should have an objective, which can be a minimize or maximize objective. Furthermore, we can define weights between 0 and 1 in case the objectives should not be weighted equally.</p> In\u00a0[2]: Copied! <pre>from bofire.data_models.features.api import ContinuousOutput\nfrom bofire.data_models.objectives.api import MaximizeObjective, MinimizeObjective\n\nobjective1 = MaximizeObjective(\n    w=1.0, \n    bounds= [0.0,1.0],\n)\ny1 = ContinuousOutput(key=\"y1\", objective=objective1)\n\nobjective2 = MinimizeObjective(\n    w=1.0\n)\ny2 = ContinuousOutput(key=\"y2\", objective=objective2)\n</pre> from bofire.data_models.features.api import ContinuousOutput from bofire.data_models.objectives.api import MaximizeObjective, MinimizeObjective  objective1 = MaximizeObjective(     w=1.0,      bounds= [0.0,1.0], ) y1 = ContinuousOutput(key=\"y1\", objective=objective1)  objective2 = MinimizeObjective(     w=1.0 ) y2 = ContinuousOutput(key=\"y2\", objective=objective2) <p>In- and output features are collected in respective feature lists.</p> In\u00a0[3]: Copied! <pre>from bofire.data_models.domain.api import Inputs, Outputs\n\ninput_features = Inputs(features = [x1, x2, x3, x4, x5, x6])\noutput_features = Outputs(features=[y1, y2])\n</pre> from bofire.data_models.domain.api import Inputs, Outputs  input_features = Inputs(features = [x1, x2, x3, x4, x5, x6]) output_features = Outputs(features=[y1, y2]) <p>Individual features can be retrieved by name.</p> In\u00a0[4]: Copied! <pre>x5 = input_features.get_by_key('x5')\nx5\n</pre> x5 = input_features.get_by_key('x5') x5 Out[4]: <pre>CategoricalInput(type='CategoricalInput', key='x5', categories=['A', 'B', 'C'], allowed=[True, True, False])</pre> <p>This is also possible with list of feature names.</p> In\u00a0[5]: Copied! <pre>input_features.get_by_keys(['x5', 'x2'])\n</pre> input_features.get_by_keys(['x5', 'x2']) Out[5]: <pre>Inputs(type='Inputs', features=[ContinuousInput(type='ContinuousInput', key='x2', unit=None, bounds=(0.0, 1.0), stepsize=None), CategoricalInput(type='CategoricalInput', key='x5', categories=['A', 'B', 'C'], allowed=[True, True, False])])</pre> <p>Features of a specific type can be returned by the <code>get</code> method, by default it returns all features that are an instance of the provided class.</p> In\u00a0[6]: Copied! <pre>input_features.get(CategoricalInput)\n</pre> input_features.get(CategoricalInput) Out[6]: <pre>Inputs(type='Inputs', features=[CategoricalDescriptorInput(type='CategoricalDescriptorInput', key='x6', categories=['c1', 'c2', 'c3'], allowed=[True, True, True], descriptors=['d1', 'd2'], values=[[1.0, 2.0], [2.0, 5.0], [1.0, 7.0]]), CategoricalInput(type='CategoricalInput', key='x5', categories=['A', 'B', 'C'], allowed=[True, True, False])])</pre> <p>By using the <code>exact</code> argument one can force it to only return feature of the exact same class.</p> In\u00a0[7]: Copied! <pre>input_features.get(CategoricalInput, exact=True)\n</pre> input_features.get(CategoricalInput, exact=True) Out[7]: <pre>Inputs(type='Inputs', features=[CategoricalInput(type='CategoricalInput', key='x5', categories=['A', 'B', 'C'], allowed=[True, True, False])])</pre> <p>The <code>get_keys</code> method follows the same logic as the <code>get</code> method but returns just the keys of the features instead of the features itself.</p> In\u00a0[8]: Copied! <pre>input_features.get_keys(CategoricalInput)\n</pre> input_features.get_keys(CategoricalInput) Out[8]: <pre>['x6', 'x5']</pre> <p>The input feature container further provides methods to return a feature container with only all fixed or all free features.</p> In\u00a0[9]: Copied! <pre>free_inputs = input_features.get_free()\nfixed_inputs = input_features.get_fixed()\n</pre> free_inputs = input_features.get_free() fixed_inputs = input_features.get_fixed() <p>One can uniformly sample from individual input features.</p> In\u00a0[10]: Copied! <pre>x5.sample(2)\n</pre> x5.sample(2) Out[10]: <pre>0    A\n1    A\nName: x5, dtype: object</pre> <p>Or directly from input feature containers, uniform, sobol and LHS sampling is possible. A default, uniform sampling is used.</p> In\u00a0[11]: Copied! <pre>from bofire.data_models.enum import SamplingMethodEnum\n\nX = input_features.sample(n=10, method=SamplingMethodEnum.LHS)\n\nX\n</pre> from bofire.data_models.enum import SamplingMethodEnum  X = input_features.sample(n=10, method=SamplingMethodEnum.LHS)  X Out[11]: x1 x2 x3 x4 x6 x5 0 0.816629 0.701182 0.199399 1.0 c2 B 1 0.125867 0.671547 0.643904 2.0 c2 A 2 0.043447 0.201667 0.023621 1.0 c3 A 3 0.551177 0.990435 0.760910 5.0 c2 A 4 0.740829 0.806960 0.460355 5.0 c3 A 5 0.901442 0.503359 0.844109 5.0 c1 B 6 0.347634 0.433813 0.213938 2.0 c2 B 7 0.487146 0.346877 0.927307 2.0 c1 B 8 0.679540 0.062551 0.554906 7.5 c1 B 9 0.261995 0.196828 0.328467 7.5 c3 A In\u00a0[12]: Copied! <pre>from bofire.data_models.constraints.api import LinearEqualityConstraint, LinearInequalityConstraint\n\n# A mixture: x1 + x2 + x3 = 1\nconstr1 = LinearEqualityConstraint(features=[\"x1\", \"x2\", \"x3\"], coefficients=[1,1,1], rhs=1)\n\n# x1 + 2 * x3 &lt; 0.8\nconstr2 = LinearInequalityConstraint(features=[\"x1\", \"x3\"], coefficients=[1, 2], rhs=0.8)\n</pre> from bofire.data_models.constraints.api import LinearEqualityConstraint, LinearInequalityConstraint  # A mixture: x1 + x2 + x3 = 1 constr1 = LinearEqualityConstraint(features=[\"x1\", \"x2\", \"x3\"], coefficients=[1,1,1], rhs=1)  # x1 + 2 * x3 &lt; 0.8 constr2 = LinearInequalityConstraint(features=[\"x1\", \"x3\"], coefficients=[1, 2], rhs=0.8) <p>Linear constraints can only operate on <code>ContinuousInput</code> features.</p> <p><code>NonlinearEqualityConstraint</code> and <code>NonlinearInequalityConstraint</code> take any expression that can be evaluated by pandas.eval, including mathematical operators such as <code>sin</code>, <code>exp</code>, <code>log10</code> or exponentiation. So far, they cannot be used in any optimizations.</p> In\u00a0[13]: Copied! <pre>from bofire.data_models.constraints.api import NonlinearEqualityConstraint, NonlinearInequalityConstraint\n\n# The unit circle: x1**2 + x2**2 = 1\nconst3 = NonlinearEqualityConstraint(expression=\"x1**2 + x2**2 - 1\")\nconst3\n</pre> from bofire.data_models.constraints.api import NonlinearEqualityConstraint, NonlinearInequalityConstraint  # The unit circle: x1**2 + x2**2 = 1 const3 = NonlinearEqualityConstraint(expression=\"x1**2 + x2**2 - 1\") const3 Out[13]: <pre>NonlinearEqualityConstraint(type='NonlinearEqualityConstraint', expression='x1**2 + x2**2 - 1', features=None, jacobian_expression=None)</pre> In\u00a0[14]: Copied! <pre>from bofire.data_models.constraints.api import NChooseKConstraint\n\n# Only 2 or 3 out of 3 parameters can be greater than zero\nconstr5 = NChooseKConstraint(features=[\"x1\", \"x2\", \"x3\"], min_count=2, max_count=3, none_also_valid=True)\nconstr5\n</pre> from bofire.data_models.constraints.api import NChooseKConstraint  # Only 2 or 3 out of 3 parameters can be greater than zero constr5 = NChooseKConstraint(features=[\"x1\", \"x2\", \"x3\"], min_count=2, max_count=3, none_also_valid=True) constr5 Out[14]: <pre>NChooseKConstraint(type='NChooseKConstraint', features=['x1', 'x2', 'x3'], min_count=2, max_count=3, none_also_valid=True)</pre> <p>Note that we have to set a boolean, if None is also a valid selection, e.g. if we want to have 2 or 3 or none of the ingredients in our recipe.</p> <p>Similar to the features, constraints can be grouped in a container which acts as the union constraints.</p> In\u00a0[15]: Copied! <pre>from bofire.data_models.domain.api import Constraints\n\n\nconstraints = Constraints(constraints=[constr1, constr2])\n</pre> from bofire.data_models.domain.api import Constraints   constraints = Constraints(constraints=[constr1, constr2])  <p>We can check whether a point satisfies individual constraints or the list of constraints.</p> In\u00a0[16]: Copied! <pre>constr2.is_fulfilled(X).values\n</pre> constr2.is_fulfilled(X).values Out[16]: <pre>array([False, False,  True, False, False, False,  True, False, False,\n       False])</pre> <p>Output constraints can be setup via sigmoid-shaped objectives passed as argument to the respective feature, which can then also be plotted.</p> In\u00a0[17]: Copied! <pre>from bofire.data_models.objectives.api import MinimizeSigmoidObjective\nfrom bofire.plot.api import plot_objective_plotly\n\noutput_constraint = MinimizeSigmoidObjective(\n    w=1.0, \n    steepness=10,\n    tp=0.5\n)\ny3= ContinuousOutput(key=\"y3\", objective=output_constraint)\n\noutput_features = Outputs(features=[y1, y2, y3])\n\nfig = plot_objective_plotly(feature=y3, lower=0, upper=1)\n\nfig.show()\n</pre> from bofire.data_models.objectives.api import MinimizeSigmoidObjective from bofire.plot.api import plot_objective_plotly  output_constraint = MinimizeSigmoidObjective(     w=1.0,      steepness=10,     tp=0.5 ) y3= ContinuousOutput(key=\"y3\", objective=output_constraint)  output_features = Outputs(features=[y1, y2, y3])  fig = plot_objective_plotly(feature=y3, lower=0, upper=1)  fig.show() <pre>/home/aaron/anaconda3/envs/bofire/lib/python3.11/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n</pre> In\u00a0[18]: Copied! <pre>from bofire.data_models.domain.api import Domain\n\ndomain = Domain(\n    inputs=input_features, \n    outputs=output_features, \n    constraints=constraints\n    )\n</pre> from bofire.data_models.domain.api import Domain  domain = Domain(     inputs=input_features,      outputs=output_features,      constraints=constraints     ) <p>In addition one can instantiate the domain also just from lists.</p> In\u00a0[19]: Copied! <pre>domain_single_objective = Domain.from_lists(\n    inputs=[x1, x2, x3, x4, x5, x6], \n    outputs=[y1], \n    constraints=[]\n    )\n</pre> domain_single_objective = Domain.from_lists(     inputs=[x1, x2, x3, x4, x5, x6],      outputs=[y1],      constraints=[]     ) <p>A summary of the defined features and constraints can be obtained by the methods <code>get_feature_reps_df()</code> and <code>get_constraint_reps_df()</code>:</p> In\u00a0[20]: Copied! <pre>domain.get_feature_reps_df()\n</pre> domain.get_feature_reps_df() Out[20]: Type Description x1 ContinuousInput [0.0,1.0] x2 ContinuousInput [0.0,1.0] x3 ContinuousInput [0.0,1.0] x4 DiscreteInput type='DiscreteInput' key='x4' unit=None values... x6 CategoricalDescriptorInput 3 categories x5 CategoricalInput 3 categories y1 ContinuousOutput ContinuousOutputFeature y2 ContinuousOutput ContinuousOutputFeature y3 ContinuousOutput ContinuousOutputFeature In\u00a0[21]: Copied! <pre>domain.get_constraint_reps_df()\n</pre> domain.get_constraint_reps_df() Out[21]: Type Description 0 LinearEqualityConstraint 1.0 * x1 + 1.0 * x2 + 1.0 * x3 = 1.0 1 LinearInequalityConstraint 1.0 * x1 + 2.0 * x3 &lt;= 0.8 In\u00a0[22]: Copied! <pre>from bofire.data_models.strategies.api import RandomStrategy\n\nimport bofire.strategies.mapper as strategy_mapper\n\nstrategy_data_model = RandomStrategy(domain=domain)\n\nrandom_strategy = strategy_mapper.map(strategy_data_model)\nrandom_candidates = random_strategy.ask(2)\n\nrandom_candidates\n</pre> from bofire.data_models.strategies.api import RandomStrategy  import bofire.strategies.mapper as strategy_mapper  strategy_data_model = RandomStrategy(domain=domain)  random_strategy = strategy_mapper.map(strategy_data_model) random_candidates = random_strategy.ask(2)  random_candidates <pre>/home/aaron/Desktop/bofire/bofire/surrogates/xgb.py:12: UserWarning:\n\nxgboost not installed, BoFire's `XGBoostSurrogate` cannot be used.\n\n</pre> Out[22]: x1 x2 x3 x4 x6 x5 0 0.457574 0.462942 0.079484 1.0 c2 B 1 0.042575 0.906909 0.050516 7.5 c2 A In\u00a0[23]: Copied! <pre>from bofire.benchmarks.single import Himmelblau\n\nbenchmark = Himmelblau()\n\nbenchmark.domain.get_feature_reps_df()\n</pre> from bofire.benchmarks.single import Himmelblau  benchmark = Himmelblau()  benchmark.domain.get_feature_reps_df() Out[23]: Type Description x_1 ContinuousInput [-6.0,6.0] x_2 ContinuousInput [-6.0,6.0] y ContinuousOutput ContinuousOutputFeature <p>Generating some initial data works as follows:</p> In\u00a0[26]: Copied! <pre>samples = benchmark.domain.inputs.sample(10)\n\nexperiments = benchmark.f(samples, return_complete=True)\n\nexperiments\n</pre> samples = benchmark.domain.inputs.sample(10)  experiments = benchmark.f(samples, return_complete=True)  experiments Out[26]: x_1 x_2 y valid_y 0 -3.668700 4.138230 85.211320 1 1 4.041522 -2.696756 25.565252 1 2 0.444125 -0.806100 169.647212 1 3 3.165932 -2.169953 10.667477 1 4 -1.858209 4.432227 126.049285 1 5 1.058336 -5.689454 940.856286 1 6 -3.518614 3.832745 44.579338 1 7 -0.076872 -3.937059 293.895692 1 8 -5.209119 -1.009629 353.985415 1 9 5.186002 3.184612 433.368416 1 <p>Let's setup the SOBO strategy and ask for a candidate.</p> In\u00a0[27]: Copied! <pre>from bofire.data_models.strategies.api import SoboStrategy\nfrom bofire.data_models.acquisition_functions.api import qNEI\n\nsobo_strategy_data_model = SoboStrategy(domain=benchmark.domain, acquisition_function=qNEI())\n\nsobo_strategy = strategy_mapper.map(sobo_strategy_data_model)\n\nsobo_strategy.tell(experiments=experiments)\n\nsobo_strategy.ask(candidate_count=1)\n</pre> from bofire.data_models.strategies.api import SoboStrategy from bofire.data_models.acquisition_functions.api import qNEI  sobo_strategy_data_model = SoboStrategy(domain=benchmark.domain, acquisition_function=qNEI())  sobo_strategy = strategy_mapper.map(sobo_strategy_data_model)  sobo_strategy.tell(experiments=experiments)  sobo_strategy.ask(candidate_count=1)  Out[27]: x_1 x_2 y_pred y_sd y_des 0 -6.0 2.459544 115.313408 198.34636 -115.313408 In\u00a0[28]: Copied! <pre>from bofire.strategies.doe.design import find_local_max_ipopt\nimport numpy as np\n\ndomain = Domain(\n    inputs=[x1,x2,x3],\n    outputs=[y1],\n    constraints=[constr1]\n    )\n\nres = find_local_max_ipopt(domain, \"fully-quadratic\")\nnp.round(res,3)\n</pre> from bofire.strategies.doe.design import find_local_max_ipopt import numpy as np  domain = Domain(     inputs=[x1,x2,x3],     outputs=[y1],     constraints=[constr1]     )  res = find_local_max_ipopt(domain, \"fully-quadratic\") np.round(res,3) <pre>\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n******************************************************************************\n\n</pre> Out[28]: x1 x2 x3 exp0 5.000000e-01 -9.992500e-09 5.000000e-01 exp1 5.000000e-01 -9.992500e-09 5.000000e-01 exp2 5.000000e-01 5.000000e-01 -9.992500e-09 exp3 5.000000e-01 5.000000e-01 -9.992500e-09 exp4 -4.998329e-09 -4.998335e-09 1.000000e+00 exp5 5.000000e-01 -9.992500e-09 5.000000e-01 exp6 1.000000e+00 -4.998956e-09 -4.999377e-09 exp7 -9.992500e-09 5.000000e-01 5.000000e-01 exp8 -4.998333e-09 -4.998332e-09 1.000000e+00 exp9 5.000000e-01 5.000000e-01 -9.992500e-09 exp10 -9.992500e-09 5.000000e-01 5.000000e-01 exp11 -4.998976e-09 1.000000e+00 -4.999357e-09 exp12 -9.992500e-09 5.000000e-01 5.000000e-01 <p>The resulting design looks like this:</p> In\u00a0[28]: Copied! <pre>import matplotlib.pyplot as plt\n\nfig = plt.figure(figsize=((10,10)))\nax = fig.add_subplot(111, projection='3d')\nax.view_init(45, 45)\nax.set_title(\"fully-quadratic model\")\nax.set_xlabel(\"$x_1$\")\nax.set_ylabel(\"$x_2$\")\nax.set_zlabel(\"$x_3$\")\nplt.rcParams[\"figure.figsize\"] = (10,8)\n\n#plot feasible polytope\nax.plot(\n    xs=[1,0,0,1],\n    ys=[0,1,0,0],\n    zs=[0,0,1,0],\n    linewidth=2\n)\n\n#plot D-optimal solutions\nax.scatter(xs=res[\"x1\"], ys=res[\"x2\"], zs=res[\"x3\"], marker=\"o\", s=40, color=\"orange\")\n</pre> import matplotlib.pyplot as plt  fig = plt.figure(figsize=((10,10))) ax = fig.add_subplot(111, projection='3d') ax.view_init(45, 45) ax.set_title(\"fully-quadratic model\") ax.set_xlabel(\"$x_1$\") ax.set_ylabel(\"$x_2$\") ax.set_zlabel(\"$x_3$\") plt.rcParams[\"figure.figsize\"] = (10,8)  #plot feasible polytope ax.plot(     xs=[1,0,0,1],     ys=[0,1,0,0],     zs=[0,0,1,0],     linewidth=2 )  #plot D-optimal solutions ax.scatter(xs=res[\"x1\"], ys=res[\"x2\"], zs=res[\"x3\"], marker=\"o\", s=40, color=\"orange\") Out[28]: <pre>&lt;mpl_toolkits.mplot3d.art3d.Path3DCollection at 0x7fc5dce5dfd0&gt;</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"getting_started/#getting-started","title":"Getting started\u00b6","text":"<p>In the following it is showed how to setup optimization problems in BoFire and how to use strategies to solve them.</p>"},{"location":"getting_started/#setting-up-the-optimization-problem","title":"Setting up the optimization problem\u00b6","text":"<p>In BoFire, an optimization problem is defined by defining a domain containing input and output features as well as constraints (optional).</p>"},{"location":"getting_started/#features","title":"Features\u00b6","text":"<p>Input features can be continuous, discrete, categorical, or categorical with descriptors:</p>"},{"location":"getting_started/#constraints","title":"Constraints\u00b6","text":"<p>The search space can be further defined by constraints on the input features. BoFire supports linear equality and inequality constraints, as well as non-linear equality and inequality constraints.</p>"},{"location":"getting_started/#linear-constraints","title":"Linear constraints\u00b6","text":"<p><code>LinearEqualityConstraint</code> and <code>LinearInequalityConstraint</code> are expressions of the form $\\sum_i a_i x_i = b$ or $\\leq b$ for equality and inequality constraints respectively. They take a list of names of the input features they are operating on, a list of left-hand-side coefficients $a_i$ and a right-hand-side constant $b$.</p>"},{"location":"getting_started/#nonlinear-constraints","title":"Nonlinear constraints\u00b6","text":""},{"location":"getting_started/#combinatorial-constraint","title":"Combinatorial constraint\u00b6","text":"<p>Use <code>NChooseKConstraint</code> to express that we only want to have $k$ out of the $n$ parameters to take positive values. Think of a mixture, where we have long list of possible ingredients, but want to limit number of ingredients in any given recipe.</p>"},{"location":"getting_started/#the-domain","title":"The domain\u00b6","text":"<p>The domain holds then all information about an optimization problem and can be understood as a search space defintion.</p>"},{"location":"getting_started/#optimization","title":"Optimization\u00b6","text":"<p>To solve the optimization problem, we further need a solving strategy. BoFire supports strategies without a prediction model such as a random strategy and predictive strategies which are based on a prediction model.</p> <p>All strategies contain an <code>ask</code> method returning a defined number of candidate experiments.</p>"},{"location":"getting_started/#random-strategy","title":"Random Strategy\u00b6","text":""},{"location":"getting_started/#single-objective-bayesian-optimization-strategy","title":"Single objective Bayesian Optimization strategy\u00b6","text":"<p>Since a predictive strategy includes a prediction model, we need to generate some historical data, which we can afterwards pass as training data to the strategy via the tell method.</p> <p>For didactic purposes we just choose here from one of our benchmark methods.</p>"},{"location":"getting_started/#design-of-experiments","title":"Design of Experiments\u00b6","text":"<p>As a simple example for the DoE functionalities we consider the task of finding a D-optimal design for a fully-quadratic model with three design variables with bounds (0,1) and a mixture constraint.</p> <p>We define the design space including the constraint as a domain. Then we pass it to the optimization routine and specify the model. If the user does not indicate a number of experiments it will be chosen automatically based on the number of model terms.</p>"},{"location":"install/","title":"Installation","text":"<p>In BoFire we have several optional depencies.</p>"},{"location":"install/#domain-and-optimization-algorithms","title":"Domain and Optimization Algorithms","text":"<p>To install BoFire with optimization tools you can use <pre><code>pip install bofire[optimization]\n</code></pre> This will also install BoTorch that depends on PyTorch.</p>"},{"location":"install/#design-of-experiments","title":"Design of Experiments","text":"<p>BoFire has functionality to create D-optimal experimental designs via the <code>doe</code> module. This module is depends on  Cyipopt. A comfortable way to install Cyipopt and the dependencies is via <pre><code>conda install -c conda-forge cyipopt\n</code></pre> You have to install Cyipopt manually.</p>"},{"location":"install/#just-domain","title":"Just Domain","text":"<p>If you just want a data structure that represents the domain of an optimization problem you can <pre><code>pip install bofire\n</code></pre></p>"},{"location":"install/#cheminformatics","title":"Cheminformatics","text":"<p>Some features related to molecules and their representation depend on Rdkit. <pre><code>pip install bofire[optimization,cheminfo]\n</code></pre></p>"},{"location":"install/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to BoFire, you might want to install in editable mode including the test dependencies. After cloning the repository via <pre><code>git clone https://github.com/experimental-design/bofire.git\n</code></pre> and cd <code>bofire</code>, you can proceed with <pre><code>pip install -e .[optimization,cheminfo,docs,tests]\n</code></pre></p>"},{"location":"nchoosek_constraint/","title":"Nchoosek constraint","text":"In\u00a0[10]: Copied! <pre>from bofire.strategies.doe.design import find_local_max_ipopt\nfrom bofire.data_models.domain.api import Domain\nfrom bofire.data_models.constraints.api import NChooseKConstraint, LinearEqualityConstraint, LinearInequalityConstraint\nfrom bofire.data_models.features.api import ContinuousInput, ContinuousOutput\nimport numpy as np\n\ndomain = Domain(\n    inputs = [ContinuousInput(key=f\"x{i+1}\", bounds=(0,1)) for i in range(8)],\n    outputs = [ContinuousOutput(key=\"y\")],\n    constraints = [\n        LinearEqualityConstraint(features=[f\"x{i+1}\" for i in range(8)], coefficients=[1,1,1,1,1,1,1,1], rhs=1),\n        NChooseKConstraint(features=[\"x1\",\"x2\",\"x3\"], min_count=0, max_count=1, none_also_valid=True),\n        LinearInequalityConstraint(features=[\"x1\",\"x2\",\"x3\"], coefficients=[1,1,1], rhs=0.7),\n        LinearInequalityConstraint(features=[\"x7\",\"x8\"], coefficients=[-1,-1], rhs=-0.1),\n        LinearInequalityConstraint(features=[\"x7\",\"x8\"], coefficients=[1,1], rhs=0.9),\n    ]\n)\n\nres = find_local_max_ipopt(\n    domain=domain,\n    model_type=\"fully-quadratic\",\n    ipopt_options={\"maxiter\":500},\n)\nnp.round(res,3)\n</pre> from bofire.strategies.doe.design import find_local_max_ipopt from bofire.data_models.domain.api import Domain from bofire.data_models.constraints.api import NChooseKConstraint, LinearEqualityConstraint, LinearInequalityConstraint from bofire.data_models.features.api import ContinuousInput, ContinuousOutput import numpy as np  domain = Domain(     inputs = [ContinuousInput(key=f\"x{i+1}\", bounds=(0,1)) for i in range(8)],     outputs = [ContinuousOutput(key=\"y\")],     constraints = [         LinearEqualityConstraint(features=[f\"x{i+1}\" for i in range(8)], coefficients=[1,1,1,1,1,1,1,1], rhs=1),         NChooseKConstraint(features=[\"x1\",\"x2\",\"x3\"], min_count=0, max_count=1, none_also_valid=True),         LinearInequalityConstraint(features=[\"x1\",\"x2\",\"x3\"], coefficients=[1,1,1], rhs=0.7),         LinearInequalityConstraint(features=[\"x7\",\"x8\"], coefficients=[-1,-1], rhs=-0.1),         LinearInequalityConstraint(features=[\"x7\",\"x8\"], coefficients=[1,1], rhs=0.9),     ] )  res = find_local_max_ipopt(     domain=domain,     model_type=\"fully-quadratic\",     ipopt_options={\"maxiter\":500}, ) np.round(res,3) Out[10]: x1 x2 x3 x4 x5 x6 x7 x8 exp0 0.000 0.00 0.463 -0.000 0.437 -0.000 0.100 -0.000 exp1 0.449 0.00 0.000 -0.000 -0.000 -0.000 -0.000 0.551 exp2 0.000 0.50 0.000 -0.000 -0.000 -0.000 -0.000 0.500 exp3 0.000 0.00 0.700 0.200 -0.000 -0.000 -0.000 0.100 exp4 0.394 0.00 0.000 -0.000 0.506 -0.000 0.100 -0.000 exp5 0.000 0.45 0.000 -0.000 -0.000 0.450 0.029 0.071 exp6 0.000 0.00 0.700 -0.000 -0.000 -0.000 0.300 -0.000 exp7 0.700 0.00 0.000 -0.000 0.200 -0.000 -0.000 0.100 exp8 0.000 -0.00 0.000 -0.000 0.448 -0.000 0.552 -0.000 exp9 0.000 0.00 -0.000 -0.000 0.498 -0.000 -0.000 0.502 exp10 -0.000 0.00 0.000 -0.000 -0.000 0.900 0.100 -0.000 exp11 0.000 -0.00 0.000 -0.000 0.900 -0.000 0.100 -0.000 exp12 0.000 0.00 0.371 -0.000 -0.000 0.529 -0.000 0.100 exp13 0.700 0.00 0.000 -0.000 -0.000 0.200 0.100 -0.000 exp14 0.000 -0.00 0.000 0.100 -0.000 -0.000 0.900 -0.000 exp15 0.000 0.00 0.100 -0.000 -0.000 -0.000 0.443 0.457 exp16 -0.000 0.00 0.000 -0.000 0.450 0.450 0.043 0.057 exp17 0.000 0.70 0.000 -0.000 -0.000 -0.000 0.300 -0.000 exp18 0.000 0.00 -0.000 -0.000 -0.000 0.445 0.555 -0.000 exp19 -0.000 0.00 0.000 0.539 -0.000 -0.000 0.461 -0.000 exp20 0.000 0.35 0.000 -0.000 -0.000 -0.000 0.650 -0.000 exp21 0.000 0.00 0.404 -0.000 -0.000 0.496 0.100 -0.000 exp22 0.491 0.00 0.000 -0.000 -0.000 -0.000 0.509 -0.000 exp23 0.000 0.35 0.000 -0.000 -0.000 -0.000 0.650 -0.000 exp24 0.000 0.00 0.446 -0.000 -0.000 -0.000 -0.000 0.554 exp25 0.384 0.00 0.000 -0.000 -0.000 0.516 -0.000 0.100 exp26 0.000 0.45 0.000 0.450 -0.000 -0.000 0.028 0.072 exp27 0.000 0.00 0.440 -0.000 0.460 -0.000 -0.000 0.100 exp28 0.393 0.00 0.000 0.507 -0.000 -0.000 0.100 -0.000 exp29 0.000 -0.00 0.000 0.450 0.450 -0.000 0.049 0.051 exp30 0.000 0.00 0.700 -0.000 -0.000 0.200 -0.000 0.100 exp31 0.100 0.00 0.000 -0.000 -0.000 -0.000 0.454 0.446 exp32 0.000 -0.00 0.000 -0.000 0.448 -0.000 0.552 -0.000 exp33 0.000 0.00 0.374 -0.000 -0.000 -0.000 0.626 -0.000 exp34 0.388 0.00 0.000 -0.000 -0.000 0.512 0.100 -0.000 exp35 0.000 -0.00 0.000 0.455 -0.000 0.445 0.100 -0.000 exp36 0.000 0.00 0.394 0.506 -0.000 -0.000 0.100 -0.000 exp37 -0.000 0.00 0.000 0.448 -0.000 -0.000 -0.000 0.552 exp38 0.000 0.45 0.000 -0.000 0.450 -0.000 0.023 0.077 exp39 0.000 0.00 -0.000 0.539 -0.000 -0.000 0.461 -0.000 exp40 -0.000 0.00 0.000 -0.000 -0.000 0.445 0.555 -0.000 exp41 0.000 -0.00 0.000 -0.000 -0.000 0.541 -0.000 0.459 exp42 0.000 0.00 -0.000 0.442 -0.000 0.458 -0.000 0.100 exp43 0.700 0.00 0.000 0.200 -0.000 -0.000 -0.000 0.100 exp44 0.000 -0.00 0.000 -0.000 -0.000 0.100 -0.000 0.900 exp45 0.000 0.00 -0.000 0.448 -0.000 -0.000 -0.000 0.552 exp46 -0.000 0.00 0.000 0.900 -0.000 -0.000 -0.000 0.100 exp47 0.000 -0.00 0.000 -0.000 0.498 -0.000 -0.000 0.502 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"nchoosek_constraint/#design-with-nchoosek-constraint","title":"Design with NChooseK constraint\u00b6","text":"<p>The doe subpackage also supports problems with NChooseK constraints. Since IPOPT has problems finding feasible solutions using the gradient of the NChooseK constraint violation, a closely related (but stricter) constraint that suffices to fulfill the NChooseK constraint is imposed onto the problem: For each experiment $j$ N-K decision variables $x_{i_1,j},...,x_{i_{N-K,j}}$ from the NChooseK constraints' names attribute are picked that are forced to be zero. This is done by setting the upper and lower bounds of the picked variables are set to 0 in the corresponding experiments. This causes IPOPT to treat them as \"fixed variables\" (i.e. it will not optimize for them) and will always stick to the only feasible value (which is 0 here). However, this constraint is stricter than the original NChooseK constraint. In combination with other constraints on the same decision variables this can result in a situation where the constraints cannot be fulfilled even though the original constraints would allow for a solution. For example consider a problem with four decision variables $x_1, x_2, x_3, x_4$, an NChooseK constraint on the first four variable that restricts the number of nonzero variables to two. Additionally, we have a linear constraint $$ x_3 + x_4 \\geq 0.1 $$ We can easily find points that fulfill both constraints (e.g. $(0,0,0,0.1)$). Now consider the stricter, linear constraint from above. Eventually, it will happen that $x_3$ and $x_4$ are chosen to be zero for one experiment. For this experiment it is impossible to fulfill the linear constraint $x_3 + x_4 \\geq 0.1$ since $x_3 = x_4 = 0$.</p> <p>Therefore one has to be very careful when imposing linear constraints upon decision variables that already show up in an NChooseK constraint.</p> <p>For practical reasons it necessary that two NChooseK constraints of the same problem must not share any variables.</p> <p>You can find an example for a problem with NChooseK constraints and additional linear constraints imposed on the same variables.</p>"},{"location":"optimality_criteria/","title":"Optimality criteria","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom bofire.data_models.constraints.api import (\n    NonlinearEqualityConstraint,\n    NonlinearInequalityConstraint,\n    LinearEqualityConstraint,\n    LinearInequalityConstraint,\n)\nfrom bofire.data_models.domain.api import Domain\nfrom bofire.data_models.features.api import ContinuousInput, ContinuousOutput\nfrom bofire.strategies.doe.design import find_local_max_ipopt\nfrom bofire.strategies.enum import OptimalityCriterionEnum\n</pre> import numpy as np import matplotlib.pyplot as plt  from bofire.data_models.constraints.api import (     NonlinearEqualityConstraint,     NonlinearInequalityConstraint,     LinearEqualityConstraint,     LinearInequalityConstraint, ) from bofire.data_models.domain.api import Domain from bofire.data_models.features.api import ContinuousInput, ContinuousOutput from bofire.strategies.doe.design import find_local_max_ipopt from bofire.strategies.enum import OptimalityCriterionEnum In\u00a0[\u00a0]: Copied! <pre># Optimal designs for a quadratic model on the unit square\ndomain = Domain(\n    inputs=[ContinuousInput(key=f\"x{i+1}\", bounds=(0, 1)) for i in range(2)],\n    outputs=[ContinuousOutput(key=\"y\")],\n)\nmodel_type = \"fully-quadratic\"\nn_experiments = 13\n\ndesigns = {}\nfor obj in OptimalityCriterionEnum:\n    designs[obj.value] = find_local_max_ipopt(\n        domain,\n        model_type=model_type,\n        n_experiments=n_experiments,\n        objective=obj,\n        ipopt_options={\"maxiter\": 300},\n    ).to_numpy()\n\nfig = plt.figure(figsize=((8, 8)))\nax = fig.add_subplot(111)\nax.set_title(\"Designs with different optimality criteria\")\nax.set_xlabel(\"$x_1$\")\nax.set_ylabel(\"$x_2$\")\nfor obj, X in designs.items():\n    ax.scatter(X[:, 0], X[:, 1], s=40, label=obj)\nax.grid(alpha=0.3)\nax.legend();\n</pre> # Optimal designs for a quadratic model on the unit square domain = Domain(     inputs=[ContinuousInput(key=f\"x{i+1}\", bounds=(0, 1)) for i in range(2)],     outputs=[ContinuousOutput(key=\"y\")], ) model_type = \"fully-quadratic\" n_experiments = 13  designs = {} for obj in OptimalityCriterionEnum:     designs[obj.value] = find_local_max_ipopt(         domain,         model_type=model_type,         n_experiments=n_experiments,         objective=obj,         ipopt_options={\"maxiter\": 300},     ).to_numpy()  fig = plt.figure(figsize=((8, 8))) ax = fig.add_subplot(111) ax.set_title(\"Designs with different optimality criteria\") ax.set_xlabel(\"$x_1$\") ax.set_ylabel(\"$x_2$\") for obj, X in designs.items():     ax.scatter(X[:, 0], X[:, 1], s=40, label=obj) ax.grid(alpha=0.3) ax.legend(); In\u00a0[\u00a0]: Copied! <pre># Space filling design on the unit 2-simplex\ndomain = Domain(\n    inputs=[ContinuousInput(key=f\"x{i+1}\", bounds=(0, 1)) for i in range(3)],\n    outputs=[ContinuousOutput(key=\"y\")],\n    constraints=[\n        LinearEqualityConstraint(\n            features=[\"x1\", \"x2\", \"x3\"], coefficients=[1, 1, 1], rhs=1\n        )\n    ],\n)\n\nX = find_local_max_ipopt(\n    domain,\n    n_experiments=40,\n    model_type=\"linear\",  # the model type does not matter for space filling designs\n    objective=OptimalityCriterionEnum.SPACE_FILLING,\n    ipopt_options={\"maxiter\": 500},\n).to_numpy()\n\n\nfig = plt.figure(figsize=((10, 8)))\nax = fig.add_subplot(111, projection=\"3d\")\nax.view_init(45, 20)\nax.set_title(\"Space filling design\")\nax.set_xlabel(\"$x_1$\")\nax.set_ylabel(\"$x_2$\")\nax.set_zlabel(\"$x_3$\")\n\n# plot feasible polytope\nax.plot(xs=[0, 0, 1, 0], ys=[0, 1, 0, 0], zs=[1, 0, 0, 1], linewidth=2)\n\n# plot design points\nax.scatter(xs=X[:, 0], ys=X[:, 1], zs=X[:, 2], s=40)\n</pre> # Space filling design on the unit 2-simplex domain = Domain(     inputs=[ContinuousInput(key=f\"x{i+1}\", bounds=(0, 1)) for i in range(3)],     outputs=[ContinuousOutput(key=\"y\")],     constraints=[         LinearEqualityConstraint(             features=[\"x1\", \"x2\", \"x3\"], coefficients=[1, 1, 1], rhs=1         )     ], )  X = find_local_max_ipopt(     domain,     n_experiments=40,     model_type=\"linear\",  # the model type does not matter for space filling designs     objective=OptimalityCriterionEnum.SPACE_FILLING,     ipopt_options={\"maxiter\": 500}, ).to_numpy()   fig = plt.figure(figsize=((10, 8))) ax = fig.add_subplot(111, projection=\"3d\") ax.view_init(45, 20) ax.set_title(\"Space filling design\") ax.set_xlabel(\"$x_1$\") ax.set_ylabel(\"$x_2$\") ax.set_zlabel(\"$x_3$\")  # plot feasible polytope ax.plot(xs=[0, 0, 1, 0], ys=[0, 1, 0, 0], zs=[1, 0, 0, 1], linewidth=2)  # plot design points ax.scatter(xs=X[:, 0], ys=X[:, 1], zs=X[:, 2], s=40) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"optimality_criteria/#designs-for-different-optimality-criteria","title":"Designs for different optimality criteria\u00b6","text":""},{"location":"optimality_criteria/#space-filling-design","title":"Space filling design\u00b6","text":""},{"location":"ref-constraints/","title":"Domain","text":""},{"location":"ref-constraints/#bofire.data_models.domain.constraints.Constraints","title":"<code> Constraints            (BaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>bofire/data_models/domain/constraints.py</code> <pre><code>class Constraints(BaseModel):\n    type: Literal[\"Constraints\"] = \"Constraints\"\n    constraints: Sequence[AnyConstraint] = Field(default_factory=lambda: [])\n\n    def __iter__(self):\n        return iter(self.constraints)\n\n    def __len__(self):\n        return len(self.constraints)\n\n    def __getitem__(self, i):\n        return self.constraints[i]\n\n    def __add__(\n        self, other: Union[Sequence[AnyConstraint], \"Constraints\"]\n    ) -&gt; \"Constraints\":\n        if isinstance(other, collections.abc.Sequence):\n            other_constraints = other\n        else:\n            other_constraints = other.constraints\n        constraints = list(chain(self.constraints, other_constraints))\n        return Constraints(constraints=constraints)\n\n    def __call__(self, experiments: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Numerically evaluate all constraints\n\n        Args:\n            experiments (pd.DataFrame): data to evaluate the constraint on\n\n        Returns:\n            pd.DataFrame: Constraint evaluation for each of the constraints\n        \"\"\"\n        return pd.concat([c(experiments) for c in self.constraints], axis=1)\n\n    def jacobian(self, experiments: pd.DataFrame) -&gt; list:\n\"\"\"Numerically evaluate the jacobians of all constraints\n\n        Args:\n            experiments (pd.DataFrame): data to evaluate the constraint jacobians on\n\n        Returns:\n            list: A list containing the jacobians as pd.DataFrames\n        \"\"\"\n        return [c.jacobian(experiments) for c in self.constraints]\n\n    def is_fulfilled(self, experiments: pd.DataFrame, tol: float = 1e-6) -&gt; pd.Series:\n\"\"\"Check if all constraints are fulfilled on all rows of the provided dataframe\n\n        Args:\n            experiments (pd.DataFrame): Dataframe with data, the constraint validity should be tested on\n            tol (float, optional): tolerance parameter. A constraint is considered as not fulfilled if\n                the violation is larger than tol. Defaults to 0.\n\n        Returns:\n            Boolean: True if all constraints are fulfilled for all rows, false if not\n        \"\"\"\n        if len(self.constraints) == 0:\n            return pd.Series([True] * len(experiments), index=experiments.index)\n        return pd.concat(\n            [c.is_fulfilled(experiments, tol) for c in self.constraints], axis=1\n        ).all(axis=1)\n\n    def get(\n        self,\n        includes: Union[Type, List[Type]] = Constraint,\n        excludes: Union[Type, List[Type]] = None,\n        exact: bool = False,\n    ) -&gt; \"Constraints\":\n\"\"\"get constraints of the domain\n\n        Args:\n            includes (Union[Constraint, List[Constraint]], optional): Constraint class or list of specific constraint classes to be returned. Defaults to Constraint.\n            excludes (Union[Type, List[Type]], optional): Constraint class or list of specific constraint classes to be excluded from the return. Defaults to None.\n            exact (bool, optional): Boolean to distinguish if only the exact class listed in includes and no subclasses inherenting from this class shall be returned. Defaults to False.\n\n        Returns:\n            List[Constraint]: List of constraints in the domain fitting to the passed requirements.\n        \"\"\"\n        return Constraints(\n            constraints=filter_by_class(\n                self.constraints,\n                includes=includes,\n                excludes=excludes,\n                exact=exact,\n            )\n        )\n</code></pre>"},{"location":"ref-constraints/#bofire.data_models.domain.constraints.Constraints.__call__","title":"<code>__call__(self, experiments)</code>  <code>special</code>","text":"<p>Numerically evaluate all constraints</p> <p>Parameters:</p> Name Type Description Default <code>experiments</code> <code>pd.DataFrame</code> <p>data to evaluate the constraint on</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Constraint evaluation for each of the constraints</p> Source code in <code>bofire/data_models/domain/constraints.py</code> <pre><code>def __call__(self, experiments: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Numerically evaluate all constraints\n\n    Args:\n        experiments (pd.DataFrame): data to evaluate the constraint on\n\n    Returns:\n        pd.DataFrame: Constraint evaluation for each of the constraints\n    \"\"\"\n    return pd.concat([c(experiments) for c in self.constraints], axis=1)\n</code></pre>"},{"location":"ref-constraints/#bofire.data_models.domain.constraints.Constraints.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-constraints/#bofire.data_models.domain.constraints.Constraints.get","title":"<code>get(self, includes=&lt;class 'bofire.data_models.constraints.constraint.Constraint'&gt;, excludes=None, exact=False)</code>","text":"<p>get constraints of the domain</p> <p>Parameters:</p> Name Type Description Default <code>includes</code> <code>Union[Constraint, List[Constraint]]</code> <p>Constraint class or list of specific constraint classes to be returned. Defaults to Constraint.</p> <code>&lt;class 'bofire.data_models.constraints.constraint.Constraint'&gt;</code> <code>excludes</code> <code>Union[Type, List[Type]]</code> <p>Constraint class or list of specific constraint classes to be excluded from the return. Defaults to None.</p> <code>None</code> <code>exact</code> <code>bool</code> <p>Boolean to distinguish if only the exact class listed in includes and no subclasses inherenting from this class shall be returned. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Constraint]</code> <p>List of constraints in the domain fitting to the passed requirements.</p> Source code in <code>bofire/data_models/domain/constraints.py</code> <pre><code>def get(\n    self,\n    includes: Union[Type, List[Type]] = Constraint,\n    excludes: Union[Type, List[Type]] = None,\n    exact: bool = False,\n) -&gt; \"Constraints\":\n\"\"\"get constraints of the domain\n\n    Args:\n        includes (Union[Constraint, List[Constraint]], optional): Constraint class or list of specific constraint classes to be returned. Defaults to Constraint.\n        excludes (Union[Type, List[Type]], optional): Constraint class or list of specific constraint classes to be excluded from the return. Defaults to None.\n        exact (bool, optional): Boolean to distinguish if only the exact class listed in includes and no subclasses inherenting from this class shall be returned. Defaults to False.\n\n    Returns:\n        List[Constraint]: List of constraints in the domain fitting to the passed requirements.\n    \"\"\"\n    return Constraints(\n        constraints=filter_by_class(\n            self.constraints,\n            includes=includes,\n            excludes=excludes,\n            exact=exact,\n        )\n    )\n</code></pre>"},{"location":"ref-constraints/#bofire.data_models.domain.constraints.Constraints.is_fulfilled","title":"<code>is_fulfilled(self, experiments, tol=1e-06)</code>","text":"<p>Check if all constraints are fulfilled on all rows of the provided dataframe</p> <p>Parameters:</p> Name Type Description Default <code>experiments</code> <code>pd.DataFrame</code> <p>Dataframe with data, the constraint validity should be tested on</p> required <code>tol</code> <code>float</code> <p>tolerance parameter. A constraint is considered as not fulfilled if the violation is larger than tol. Defaults to 0.</p> <code>1e-06</code> <p>Returns:</p> Type Description <code>Boolean</code> <p>True if all constraints are fulfilled for all rows, false if not</p> Source code in <code>bofire/data_models/domain/constraints.py</code> <pre><code>def is_fulfilled(self, experiments: pd.DataFrame, tol: float = 1e-6) -&gt; pd.Series:\n\"\"\"Check if all constraints are fulfilled on all rows of the provided dataframe\n\n    Args:\n        experiments (pd.DataFrame): Dataframe with data, the constraint validity should be tested on\n        tol (float, optional): tolerance parameter. A constraint is considered as not fulfilled if\n            the violation is larger than tol. Defaults to 0.\n\n    Returns:\n        Boolean: True if all constraints are fulfilled for all rows, false if not\n    \"\"\"\n    if len(self.constraints) == 0:\n        return pd.Series([True] * len(experiments), index=experiments.index)\n    return pd.concat(\n        [c.is_fulfilled(experiments, tol) for c in self.constraints], axis=1\n    ).all(axis=1)\n</code></pre>"},{"location":"ref-constraints/#bofire.data_models.domain.constraints.Constraints.jacobian","title":"<code>jacobian(self, experiments)</code>","text":"<p>Numerically evaluate the jacobians of all constraints</p> <p>Parameters:</p> Name Type Description Default <code>experiments</code> <code>pd.DataFrame</code> <p>data to evaluate the constraint jacobians on</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list containing the jacobians as pd.DataFrames</p> Source code in <code>bofire/data_models/domain/constraints.py</code> <pre><code>def jacobian(self, experiments: pd.DataFrame) -&gt; list:\n\"\"\"Numerically evaluate the jacobians of all constraints\n\n    Args:\n        experiments (pd.DataFrame): data to evaluate the constraint jacobians on\n\n    Returns:\n        list: A list containing the jacobians as pd.DataFrames\n    \"\"\"\n    return [c.jacobian(experiments) for c in self.constraints]\n</code></pre>"},{"location":"ref-domain-util/","title":"Domain","text":""},{"location":"ref-domain-util/#bofire.utils.cheminformatics","title":"<code>cheminformatics</code>","text":""},{"location":"ref-domain-util/#bofire.utils.cheminformatics.smiles2bag_of_characters","title":"<code>smiles2bag_of_characters(smiles, max_ngram=5)</code>","text":"<p>Transforms list of smiles to bag of characters.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>List[str]</code> <p>List of smiles</p> required <code>max_ngram</code> <code>int</code> <p>Maximal ngram value. Defaults to 5.</p> <code>5</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Array holding the bag of characters.</p> Source code in <code>bofire/utils/cheminformatics.py</code> <pre><code>def smiles2bag_of_characters(smiles: List[str], max_ngram: int = 5) -&gt; np.ndarray:\n\"\"\"Transforms list of smiles to bag of characters.\n\n    Args:\n        smiles (List[str]): List of smiles\n        max_ngram (int, optional): Maximal ngram value. Defaults to 5.\n\n    Returns:\n        np.ndarray: Array holding the bag of characters.\n    \"\"\"\n    for smi in smiles:\n        smiles2mol(smi)\n    cv = CountVectorizer(ngram_range=(1, max_ngram), analyzer=\"char\", lowercase=False)\n    return cv.fit_transform(smiles).toarray()\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.cheminformatics.smiles2fingerprints","title":"<code>smiles2fingerprints(smiles, bond_radius=5, n_bits=2048)</code>","text":"<p>Transforms a list of smiles to an array of morgan fingerprints.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>List[str]</code> <p>List of smiles</p> required <code>bond_radius</code> <code>int</code> <p>Bond radius to use. Defaults to 5.</p> <code>5</code> <code>n_bits</code> <code>int</code> <p>Number of bits. Defaults to 2048.</p> <code>2048</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Numpy array holding the fingerprints</p> Source code in <code>bofire/utils/cheminformatics.py</code> <pre><code>def smiles2fingerprints(\n    smiles: List[str], bond_radius: int = 5, n_bits: int = 2048\n) -&gt; np.ndarray:\n\"\"\"Transforms a list of smiles to an array of morgan fingerprints.\n\n    Args:\n        smiles (List[str]): List of smiles\n        bond_radius (int, optional): Bond radius to use. Defaults to 5.\n        n_bits (int, optional): Number of bits. Defaults to 2048.\n\n    Returns:\n        np.ndarray: Numpy array holding the fingerprints\n    \"\"\"\n    rdkit_mols = [smiles2mol(m) for m in smiles]\n    fps = [\n        AllChem.GetMorganFingerprintAsBitVect(  # type: ignore\n            mol, radius=bond_radius, nBits=n_bits\n        )\n        for mol in rdkit_mols\n    ]\n\n    return np.asarray(fps)\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.cheminformatics.smiles2fragments","title":"<code>smiles2fragments(smiles)</code>","text":"<p>Transforms smiles to an array of fragments.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>List[str]</code> <p>List of smiles</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Array holding the fragment information.</p> Source code in <code>bofire/utils/cheminformatics.py</code> <pre><code>def smiles2fragments(smiles: List[str]) -&gt; np.ndarray:\n\"\"\"Transforms smiles to an array of fragments.\n\n    Args:\n        smiles (List[str]): List of smiles\n\n    Returns:\n        np.ndarray: Array holding the fragment information.\n    \"\"\"\n    # descList[115:] contains fragment-based features only\n    # (https://www.rdkit.org/docs/source/rdkit.Chem.Fragments.html)\n    # Update: in the new RDKit version the indices are [124:]\n    fragments = {d[0]: d[1] for d in Descriptors.descList[124:]}\n    frags = np.zeros((len(smiles), len(fragments)))\n    for i in range(len(smiles)):\n        mol = smiles2mol(smiles[i])\n        features = [fragments[d](mol) for d in fragments]\n        frags[i, :] = features\n\n    return frags\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.cheminformatics.smiles2mol","title":"<code>smiles2mol(smiles)</code>","text":"<p>Transforms a smiles string to an rdkit mol object.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>str</code> <p>Smiles string.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If string is not a valid smiles.</p> <p>Returns:</p> Type Description <code>rdkit.Mol</code> <p>rdkit.mol object</p> Source code in <code>bofire/utils/cheminformatics.py</code> <pre><code>def smiles2mol(smiles: str):\n\"\"\"Transforms a smiles string to an rdkit mol object.\n\n    Args:\n        smiles (str): Smiles string.\n\n    Raises:\n        ValueError: If string is not a valid smiles.\n\n    Returns:\n        rdkit.Mol: rdkit.mol object\n    \"\"\"\n    mol = MolFromSmiles(smiles)\n    if mol is None:\n        raise ValueError(f\"{smiles} is not a valid smiles string.\")\n    return mol\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.doe","title":"<code>doe</code>","text":""},{"location":"ref-domain-util/#bofire.utils.doe.get_confounding_matrix","title":"<code>get_confounding_matrix(inputs, design, powers=None, interactions=None)</code>","text":"<p>Analyzes the confounding of a design and returns the confounding matrix.</p> <p>Only takes continuous features into account.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Inputs</code> <p>Input features.</p> required <code>design</code> <code>pd.DataFrame</code> <p>Design matrix.</p> required <code>powers</code> <code>List[int]</code> <p>List of powers of the individual factors/features that should be considered. Integers has to be larger than 1. Defaults to [].</p> <code>None</code> <code>interactions</code> <code>List[int]</code> <p>List with interaction levels to be considered. Integers has to be larger than 1. Defaults to [2].</p> <code>None</code> <p>Returns:</p> Type Description <code>_type_</code> <p>description</p> Source code in <code>bofire/utils/doe.py</code> <pre><code>def get_confounding_matrix(\n    inputs: Inputs,\n    design: pd.DataFrame,\n    powers: Optional[List[int]] = None,\n    interactions: Optional[List[int]] = None,\n):\n\"\"\"Analyzes the confounding of a design and returns the confounding matrix.\n\n    Only takes continuous features into account.\n\n    Args:\n        inputs (Inputs): Input features.\n        design (pd.DataFrame): Design matrix.\n        powers (List[int], optional): List of powers of the individual factors/features that should be considered.\n            Integers has to be larger than 1. Defaults to [].\n        interactions (List[int], optional): List with interaction levels to be considered.\n            Integers has to be larger than 1. Defaults to [2].\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    if len(inputs.get(CategoricalInput)) &gt; 0:\n        warnings.warn(\"Categorical input features will be ignored.\")\n\n    keys = inputs.get_keys(ContinuousInput)\n    scaler = MinMaxScaler(feature_range=(-1, 1))\n    scaled_design = pd.DataFrame(\n        data=scaler.fit_transform(design[keys]),\n        columns=keys,\n    )\n\n    # add powers\n    if powers is not None:\n        for p in powers:\n            assert p &gt; 1, \"Power has to be at least of degree two.\"\n            for key in keys:\n                scaled_design[f\"{key}**{p}\"] = scaled_design[key] ** p\n\n    # add interactions\n    if interactions is None:\n        interactions = [2]\n\n    for i in interactions:\n        assert i &gt; 1, \"Interaction has to be at least of degree two.\"\n        assert i &lt; len(keys) + 1, f\"Interaction has to be smaller than {len(keys)+1}.\"\n        for combi in itertools.combinations(keys, i):\n            scaled_design[\":\".join(combi)] = scaled_design[list(combi)].prod(axis=1)\n\n    return scaled_design.corr()\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.multiobjective","title":"<code>multiobjective</code>","text":""},{"location":"ref-domain-util/#bofire.utils.multiobjective.get_ref_point_mask","title":"<code>get_ref_point_mask(domain, output_feature_keys=None)</code>","text":"<p>Method to get a mask for the reference points taking into account if we want to maximize or minimize an objective. In case it is maximize the value in the mask is 1, in case we want to minimize it is -1.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>Domain for which the mask should be generated.</p> required <code>output_feature_keys</code> <code>Optional[list]</code> <p>Name of output feature keys that should be considered in the mask. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>description</p> Source code in <code>bofire/utils/multiobjective.py</code> <pre><code>def get_ref_point_mask(\n    domain: Domain, output_feature_keys: Optional[list] = None\n) -&gt; np.ndarray:\n\"\"\"Method to get a mask for the reference points taking into account if we\n    want to maximize or minimize an objective. In case it is maximize the value\n    in the mask is 1, in case we want to minimize it is -1.\n\n    Args:\n        domain (Domain): Domain for which the mask should be generated.\n        output_feature_keys (Optional[list], optional): Name of output feature keys\n            that should be considered in the mask. Defaults to None.\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    if output_feature_keys is None:\n        output_feature_keys = domain.outputs.get_keys_by_objective(\n            includes=[MaximizeObjective, MinimizeObjective, CloseToTargetObjective]\n        )\n    if len(output_feature_keys) &lt; 2:\n        raise ValueError(\"At least two output features have to be provided.\")\n    mask = []\n    for key in output_feature_keys:\n        feat = domain.get_feature(key)\n        if isinstance(feat.objective, MaximizeObjective):  # type: ignore\n            mask.append(1.0)\n        elif isinstance(feat.objective, MinimizeObjective):  # type: ignore\n            mask.append(-1.0)\n        elif isinstance(feat.objective, CloseToTargetObjective):  # type: ignore\n            mask.append(-1.0)\n        else:\n            raise ValueError(\n                \"Only `MaximizeObjective` and `MinimizeObjective` supported\"\n            )\n    return np.array(mask)\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.reduce","title":"<code>reduce</code>","text":""},{"location":"ref-domain-util/#bofire.utils.reduce.AffineTransform","title":"<code> AffineTransform        </code>","text":"<p>Class to switch back and forth from the reduced to the original domain.</p> Source code in <code>bofire/utils/reduce.py</code> <pre><code>class AffineTransform:\n\"\"\"Class to switch back and forth from the reduced to the original domain.\"\"\"\n\n    def __init__(self, equalities: List[Tuple[str, List[str], List[float]]]):\n\"\"\"Initializes a `AffineTransformation` object.\n\n        Args:\n            equalities (List[Tuple[str,List[str],List[float]]]): List of equalities. Every equality\n                is defined as a tuple, in which the first entry is the key of the reduced feature, the second\n                one is a list of feature keys that can be used to compute the feature and the third list of floats\n                are the corresponding coefficients.\n        \"\"\"\n        self.equalities = equalities\n\n    def augment_data(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Restore the eliminated features in a dataframe\n\n        Args:\n            data (pd.DataFrame): Dataframe that should be restored.\n\n        Returns:\n            pd.DataFrame: Restored dataframe\n        \"\"\"\n        if len(self.equalities) == 0:\n            return data\n        data = data.copy()\n        for name_lhs, names_rhs, coeffs in self.equalities:\n            data[name_lhs] = coeffs[-1]\n            for i, name in enumerate(names_rhs):\n                data[name_lhs] += coeffs[i] * data[name]\n        return data\n\n    def drop_data(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Drop eliminated features from a dataframe.\n\n        Args:\n            data (pd.DataFrame): Dataframe with features to be dropped.\n\n        Returns:\n            pd.DataFrame: Reduced dataframe.\n        \"\"\"\n        if len(self.equalities) == 0:\n            return data\n        drop = []\n        for name_lhs, _, _ in self.equalities:\n            if name_lhs in data.columns:\n                drop.append(name_lhs)\n        return data.drop(columns=drop)\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.reduce.AffineTransform.__init__","title":"<code>__init__(self, equalities)</code>  <code>special</code>","text":"<p>Initializes a <code>AffineTransformation</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>equalities</code> <code>List[Tuple[str,List[str],List[float]]]</code> <p>List of equalities. Every equality is defined as a tuple, in which the first entry is the key of the reduced feature, the second one is a list of feature keys that can be used to compute the feature and the third list of floats are the corresponding coefficients.</p> required Source code in <code>bofire/utils/reduce.py</code> <pre><code>def __init__(self, equalities: List[Tuple[str, List[str], List[float]]]):\n\"\"\"Initializes a `AffineTransformation` object.\n\n    Args:\n        equalities (List[Tuple[str,List[str],List[float]]]): List of equalities. Every equality\n            is defined as a tuple, in which the first entry is the key of the reduced feature, the second\n            one is a list of feature keys that can be used to compute the feature and the third list of floats\n            are the corresponding coefficients.\n    \"\"\"\n    self.equalities = equalities\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.reduce.AffineTransform.augment_data","title":"<code>augment_data(self, data)</code>","text":"<p>Restore the eliminated features in a dataframe</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>Dataframe that should be restored.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Restored dataframe</p> Source code in <code>bofire/utils/reduce.py</code> <pre><code>def augment_data(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Restore the eliminated features in a dataframe\n\n    Args:\n        data (pd.DataFrame): Dataframe that should be restored.\n\n    Returns:\n        pd.DataFrame: Restored dataframe\n    \"\"\"\n    if len(self.equalities) == 0:\n        return data\n    data = data.copy()\n    for name_lhs, names_rhs, coeffs in self.equalities:\n        data[name_lhs] = coeffs[-1]\n        for i, name in enumerate(names_rhs):\n            data[name_lhs] += coeffs[i] * data[name]\n    return data\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.reduce.AffineTransform.drop_data","title":"<code>drop_data(self, data)</code>","text":"<p>Drop eliminated features from a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>Dataframe with features to be dropped.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Reduced dataframe.</p> Source code in <code>bofire/utils/reduce.py</code> <pre><code>def drop_data(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Drop eliminated features from a dataframe.\n\n    Args:\n        data (pd.DataFrame): Dataframe with features to be dropped.\n\n    Returns:\n        pd.DataFrame: Reduced dataframe.\n    \"\"\"\n    if len(self.equalities) == 0:\n        return data\n    drop = []\n    for name_lhs, _, _ in self.equalities:\n        if name_lhs in data.columns:\n            drop.append(name_lhs)\n    return data.drop(columns=drop)\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.reduce.adjust_boundary","title":"<code>adjust_boundary(feature, coef, rhs)</code>","text":"<p>Adjusts the boundaries of a feature.</p> <p>Parameters:</p> Name Type Description Default <code>feature</code> <code>ContinuousInput</code> <p>Feature to be adjusted.</p> required <code>coef</code> <code>float</code> <p>Coefficient.</p> required <code>rhs</code> <code>float</code> <p>Right-hand-side of the constraint.</p> required Source code in <code>bofire/utils/reduce.py</code> <pre><code>def adjust_boundary(feature: ContinuousInput, coef: float, rhs: float):\n\"\"\"Adjusts the boundaries of a feature.\n\n    Args:\n        feature (ContinuousInput): Feature to be adjusted.\n        coef (float): Coefficient.\n        rhs (float): Right-hand-side of the constraint.\n    \"\"\"\n    boundary = rhs / coef\n    if coef &gt; 0:\n        if boundary &gt; feature.lower_bound:\n            feature.bounds = (boundary, feature.upper_bound)\n    else:\n        if boundary &lt; feature.upper_bound:\n            feature.bounds = (feature.lower_bound, boundary)\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.reduce.check_domain_for_reduction","title":"<code>check_domain_for_reduction(domain)</code>","text":"<p>Check if the reduction can be applied or if a trivial case is present.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>Domain to be checked.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if reducable, else False.</p> Source code in <code>bofire/utils/reduce.py</code> <pre><code>def check_domain_for_reduction(domain: Domain) -&gt; bool:\n\"\"\"Check if the reduction can be applied or if a trivial case is present.\n\n    Args:\n        domain (Domain): Domain to be checked.\n    Returns:\n        bool: True if reducable, else False.\n    \"\"\"\n    # are there any constraints?\n    if len(domain.constraints) == 0:\n        return False\n\n    # are there any linear equality constraints?\n    linear_equalities = domain.constraints.get(LinearEqualityConstraint)\n    if len(linear_equalities) == 0:\n        return False\n\n    # are there no NChooseKConstraint constraints?\n    if len(domain.constraints.get([NChooseKConstraint])) &gt; 0:\n        return False\n\n    # are there continuous inputs\n    continuous_inputs = domain.get_features(ContinuousInput)\n    if len(continuous_inputs) == 0:\n        return False\n\n    # check that equality constraints only contain continuous inputs\n    for c in linear_equalities:\n        assert isinstance(c, LinearConstraint)\n        for feat in c.features:\n            if feat not in domain.get_feature_keys(ContinuousInput):\n                return False\n    return True\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.reduce.check_existence_of_solution","title":"<code>check_existence_of_solution(A_aug)</code>","text":"<p>Given an augmented coefficient matrix this function determines the existence (and uniqueness) of solution using the rank theorem.</p> Source code in <code>bofire/utils/reduce.py</code> <pre><code>def check_existence_of_solution(A_aug):\n\"\"\"Given an augmented coefficient matrix this function determines the existence (and uniqueness) of solution using the rank theorem.\"\"\"\n    A = A_aug[:, :-1]\n    b = A_aug[:, -1]\n    len_inputs = np.shape(A)[1]\n\n    # catch special cases\n    rk_A_aug = np.linalg.matrix_rank(A_aug)\n    rk_A = np.linalg.matrix_rank(A)\n\n    if rk_A == rk_A_aug:\n        if rk_A &lt; len_inputs:\n            return  # all good\n        else:\n            x = np.linalg.solve(A, b)\n            raise Exception(\n                f\"There is a unique solution x for the linear equality constraints: x={x}\"\n            )\n    elif rk_A &lt; rk_A_aug:\n        raise Exception(\n            \"There is no solution fulfilling the linear equality constraints.\"\n        )\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.reduce.reduce_domain","title":"<code>reduce_domain(domain)</code>","text":"<p>Reduce a domain with linear equality constraints to a subdomain where linear equality constraints are eliminated.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>Domain to be reduced.</p> required <p>Returns:</p> Type Description <code>Tuple[Domain, AffineTransform]</code> <p>reduced domain and the according transformation to switch between the     reduced and orginal domain.</p> Source code in <code>bofire/utils/reduce.py</code> <pre><code>def reduce_domain(domain: Domain) -&gt; Tuple[Domain, AffineTransform]:\n\"\"\"Reduce a domain with linear equality constraints to a subdomain where linear equality constraints are eliminated.\n\n    Args:\n        domain (Domain): Domain to be reduced.\n\n    Returns:\n        Tuple[Domain, AffineTransform]: reduced domain and the according transformation to switch between the\n            reduced and orginal domain.\n    \"\"\"\n    # check if the domain can be reduced\n    if not check_domain_for_reduction(domain):\n        return domain, AffineTransform([])\n\n    # find linear equality constraints\n    linear_equalities = domain.constraints.get(LinearEqualityConstraint)\n    other_constraints = domain.constraints.get(\n        Constraint, excludes=[LinearEqualityConstraint]\n    )\n\n    # only consider continuous inputs\n    continuous_inputs = [\n        cast(ContinuousInput, f) for f in domain.get_features(ContinuousInput)\n    ]\n    other_inputs = domain.inputs.get(Input, excludes=[ContinuousInput])\n\n    # assemble Matrix A from equality constraints\n    N = len(linear_equalities)\n    M = len(continuous_inputs) + 1\n    names = np.concatenate(([feat.key for feat in continuous_inputs], [\"rhs\"]))\n\n    A_aug = pd.DataFrame(data=np.zeros(shape=(N, M)), columns=names)\n\n    for i in range(len(linear_equalities)):\n        c = linear_equalities[i]\n        assert isinstance(c, LinearEqualityConstraint)\n        A_aug.loc[i, c.features] = c.coefficients  # type: ignore\n        A_aug.loc[i, \"rhs\"] = c.rhs\n    A_aug = A_aug.values\n\n    # catch special cases\n    check_existence_of_solution(A_aug)\n\n    # bring A_aug to reduced row-echelon form\n    A_aug_rref, pivots = rref(A_aug)\n    pivots = np.array(pivots)\n    A_aug_rref = np.array(A_aug_rref).astype(np.float64)\n\n    # formulate box bounds as linear inequality constraints in matrix form\n    B = np.zeros(shape=(2 * (M - 1), M))\n    B[: M - 1, : M - 1] = np.eye(M - 1)\n    B[M - 1 :, : M - 1] = -np.eye(M - 1)\n\n    B[: M - 1, -1] = np.array([feat.upper_bound for feat in continuous_inputs])\n    B[M - 1 :, -1] = -1.0 * np.array([feat.lower_bound for feat in continuous_inputs])\n\n    # eliminate columns with pivot element\n    for i in range(len(pivots)):\n        p = pivots[i]\n        B[p, :] -= A_aug_rref[i, :]\n        B[p + M - 1, :] += A_aug_rref[i, :]\n\n    # build up reduced domain\n    _domain = Domain.construct(\n        # _fields_set = {\"inputs\", \"outputs\", \"constraints\"}\n        inputs=deepcopy(other_inputs),\n        outputs=deepcopy(domain.outputs),\n        constraints=deepcopy(other_constraints),\n    )\n    new_inputs = [\n        deepcopy(feat) for i, feat in enumerate(continuous_inputs) if i not in pivots\n    ]\n    all_inputs = _domain.inputs + new_inputs\n    assert isinstance(all_inputs, Inputs)\n    _domain.inputs = all_inputs\n\n    constraints: List[AnyConstraint] = []\n    for i in pivots:\n        # reduce equation system of upper bounds\n        ind = np.where(B[i, :-1] != 0)[0]\n        if len(ind) &gt; 0 and B[i, -1] &lt; np.inf:\n            if len(list(names[ind])) &gt; 1:\n                c = LinearInequalityConstraint.from_greater_equal(\n                    features=list(names[ind]),\n                    coefficients=(-1.0 * B[i, ind]).tolist(),\n                    rhs=B[i, -1] * -1.0,\n                )\n                constraints.append(c)\n            else:\n                key = names[ind][0]\n                feat = cast(ContinuousInput, _domain.get_feature(key))\n                adjust_boundary(feat, (-1.0 * B[i, ind])[0], B[i, -1] * -1.0)\n        else:\n            if B[i, -1] &lt; -1e-16:\n                raise Exception(\"There is no solution that fulfills the constraints.\")\n\n        # reduce equation system of lower bounds\n        ind = np.where(B[i + M - 1, :-1] != 0)[0]\n        if len(ind) &gt; 0 and B[i + M - 1, -1] &lt; np.inf:\n            if len(list(names[ind])) &gt; 1:\n                c = LinearInequalityConstraint.from_greater_equal(\n                    features=list(names[ind]),\n                    coefficients=(-1.0 * B[i + M - 1, ind]).tolist(),\n                    rhs=B[i + M - 1, -1] * -1.0,\n                )\n                constraints.append(c)\n            else:\n                key = names[ind][0]\n                feat = cast(ContinuousInput, _domain.get_feature(key))\n                adjust_boundary(\n                    feat,\n                    (-1.0 * B[i + M - 1, ind])[0],\n                    B[i + M - 1, -1] * -1.0,\n                )\n        else:\n            if B[i + M - 1, -1] &lt; -1e-16:\n                raise Exception(\"There is no solution that fulfills the constraints.\")\n\n    if len(constraints) &gt; 0:\n        _domain._set_constraints_unvalidated(_domain.constraints + constraints)\n\n    # assemble equalities\n    _equalities = []\n    for i in range(len(pivots)):\n        name_lhs = names[pivots[i]]\n        names_rhs = []\n        coeffs = []\n\n        for j in range(len(names) - 1):\n            if A_aug_rref[i, j] != 0 and j != pivots[i]:\n                coeffs.append(-A_aug_rref[i, j])\n                names_rhs.append(names[j])\n\n        coeffs.append(A_aug_rref[i, -1])\n\n        _equalities.append((name_lhs, names_rhs, coeffs))\n\n    trafo = AffineTransform(_equalities)\n    # remove remaining dependencies of eliminated inputs from the problem\n    _domain = remove_eliminated_inputs(_domain, trafo)\n    return _domain, trafo\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.reduce.remove_eliminated_inputs","title":"<code>remove_eliminated_inputs(domain, transform)</code>","text":"<p>Eliminates remaining occurences of eliminated inputs in linear constraints.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>Domain in which the linear constraints should be purged.</p> required <code>transform</code> <code>AffineTransform</code> <p>Affine transformation object that defines the obsolete features.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If feature occurs in a constraint different from a linear one.</p> <p>Returns:</p> Type Description <code>Domain</code> <p>Purged domain.</p> Source code in <code>bofire/utils/reduce.py</code> <pre><code>def remove_eliminated_inputs(domain: Domain, transform: AffineTransform) -&gt; Domain:\n\"\"\"Eliminates remaining occurences of eliminated inputs in linear constraints.\n\n    Args:\n        domain (Domain): Domain in which the linear constraints should be purged.\n        transform (AffineTransform): Affine transformation object that defines the obsolete features.\n\n    Raises:\n        ValueError: If feature occurs in a constraint different from a linear one.\n\n    Returns:\n        Domain: Purged domain.\n    \"\"\"\n    inputs_names = domain.get_feature_keys()\n    M = len(inputs_names)\n\n    # write the equalities for the backtransformation into one matrix\n    inputs_dict = {inputs_names[i]: i for i in range(M)}\n\n    # build up dict from domain.equalities e.g. {\"xi1\": [coeff(xj1), ..., coeff(xjn)], ... \"xik\":...}\n    coeffs_dict = {}\n    for e in transform.equalities:\n        coeffs = np.zeros(M + 1)\n        for j, name in enumerate(e[1]):\n            coeffs[inputs_dict[name]] = e[2][j]\n        coeffs[-1] = e[2][-1]\n        coeffs_dict[e[0]] = coeffs\n\n    constraints = []\n    for c in domain.constraints.get():\n        # Nonlinear constraints not supported\n        if not isinstance(c, LinearConstraint):\n            raise ValueError(\n                \"Elimination of variables is only supported for LinearEquality and LinearInequality constraints.\"\n            )\n\n        # no changes, if the constraint does not contain eliminated inputs\n        elif all(name in inputs_names for name in c.features):\n            constraints.append(c)\n\n        # remove inputs from the constraint that were eliminated from the inputs before\n        else:\n            totally_removed = False\n            _features = np.array(inputs_names)\n            _rhs = c.rhs\n\n            # create new lhs and rhs from the old one and knowledge from problem._equalities\n            _coefficients = np.zeros(M)\n            for j, name in enumerate(c.features):\n                if name in inputs_names:\n                    _coefficients[inputs_dict[name]] += c.coefficients[j]\n                else:\n                    _coefficients += c.coefficients[j] * coeffs_dict[name][:-1]\n                    _rhs -= c.coefficients[j] * coeffs_dict[name][-1]\n\n            _features = _features[np.abs(_coefficients) &gt; 1e-16]\n            _coefficients = _coefficients[np.abs(_coefficients) &gt; 1e-16]\n            _c = None\n            if isinstance(c, LinearEqualityConstraint):\n                if len(_features) &gt; 1:\n                    _c = LinearEqualityConstraint(\n                        features=_features.tolist(),\n                        coefficients=_coefficients.tolist(),\n                        rhs=_rhs,\n                    )\n                elif len(_features) == 0:\n                    totally_removed = True\n                else:\n                    feat: ContinuousInput = ContinuousInput(\n                        **domain.get_feature(_features[0]).dict()\n                    )\n                    feat.bounds = (_coefficients[0], _coefficients[0])\n                    totally_removed = True\n            else:\n                if len(_features) &gt; 1:\n                    _c = LinearInequalityConstraint(\n                        features=_features.tolist(),\n                        coefficients=_coefficients.tolist(),\n                        rhs=_rhs,\n                    )\n                elif len(_features) == 0:\n                    totally_removed = True\n                else:\n                    feat = cast(ContinuousInput, domain.get_feature(_features[0]))\n                    adjust_boundary(feat, _coefficients[0], _rhs)\n                    totally_removed = True\n\n            # check if constraint is always fulfilled/not fulfilled\n            if not totally_removed:\n                assert _c is not None\n                if len(_c.features) == 0 and _c.rhs &gt;= 0:\n                    pass\n                elif len(_c.features) == 0 and _c.rhs &lt; 0:\n                    raise Exception(\"Linear constraints cannot be fulfilled.\")\n                elif np.isinf(_c.rhs):\n                    pass\n                else:\n                    constraints.append(_c)\n    domain.constraints = Constraints(constraints=constraints)\n    return domain\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.reduce.rref","title":"<code>rref(A, tol=1e-08)</code>","text":"<p>Computes the reduced row echelon form of a Matrix</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>ndarray</code> <p>2d array representing a matrix.</p> required <code>tol</code> <code>float</code> <p>tolerance for rounding to 0. Defaults to 1e-8.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>Tuple[numpy.ndarray, List[int]]</code> <p>(A_rref, pivots), where A_rref is the reduced row echelon form of A and pivots is a numpy array containing the pivot columns of A_rref</p> Source code in <code>bofire/utils/reduce.py</code> <pre><code>def rref(A: np.ndarray, tol: float = 1e-8) -&gt; Tuple[np.ndarray, List[int]]:\n\"\"\"Computes the reduced row echelon form of a Matrix\n\n    Args:\n        A (ndarray): 2d array representing a matrix.\n        tol (float, optional): tolerance for rounding to 0. Defaults to 1e-8.\n\n    Returns:\n        (A_rref, pivots), where A_rref is the reduced row echelon form of A and pivots\n        is a numpy array containing the pivot columns of A_rref\n    \"\"\"\n    A = np.array(A, dtype=np.float64)\n    n, m = np.shape(A)\n\n    col = 0\n    row = 0\n    pivots = []\n\n    for col in range(m):\n        # does a pivot element exist?\n        if all(np.abs(A[row:, col]) &lt; tol):\n            pass\n        # if yes: start elimination\n        else:\n            pivots.append(col)\n            max_row = np.argmax(np.abs(A[row:, col])) + row\n            # switch to most stable row\n            A[[row, max_row], :] = A[[max_row, row], :]  # type: ignore\n            # normalize row\n            A[row, :] /= A[row, col]\n            # eliminate other elements from column\n            for r in range(n):\n                if r != row:\n                    A[r, :] -= A[r, col] / A[row, col] * A[row, :]\n            row += 1\n\n    prec = int(-np.log10(tol))\n    return np.round(A, prec), pivots\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.subdomain","title":"<code>subdomain</code>","text":""},{"location":"ref-domain-util/#bofire.utils.subdomain.get_subdomain","title":"<code>get_subdomain(domain, feature_keys)</code>","text":"<p>removes all features not defined as argument creating a subdomain of the provided domain</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>the original domain wherefrom a subdomain should be created</p> required <code>feature_keys</code> <code>List</code> <p>List of features that shall be included in the subdomain</p> required <p>Exceptions:</p> Type Description <code>Assert</code> <p>when in total less than 2 features are provided</p> <code>ValueError</code> <p>when a provided feature key is not present in the provided domain</p> <code>Assert</code> <p>when no output feature is provided</p> <code>Assert</code> <p>when no input feature is provided</p> <code>ValueError</code> <p>description</p> <p>Returns:</p> Type Description <code>Domain</code> <p>A new domain containing only parts of the original domain</p> Source code in <code>bofire/utils/subdomain.py</code> <pre><code>def get_subdomain(\n    domain: Domain,\n    feature_keys: List,\n) -&gt; Domain:\n\"\"\"removes all features not defined as argument creating a subdomain of the provided domain\n\n    Args:\n        domain (Domain): the original domain wherefrom a subdomain should be created\n        feature_keys (List): List of features that shall be included in the subdomain\n\n    Raises:\n        Assert: when in total less than 2 features are provided\n        ValueError: when a provided feature key is not present in the provided domain\n        Assert: when no output feature is provided\n        Assert: when no input feature is provided\n        ValueError: _description_\n\n    Returns:\n        Domain: A new domain containing only parts of the original domain\n    \"\"\"\n    assert len(feature_keys) &gt;= 2, \"At least two features have to be provided.\"\n    outputs = []\n    inputs = []\n    for key in feature_keys:\n        try:\n            feat = domain.get_feature(key)\n        except KeyError:\n            raise ValueError(f\"Feature {key} not present in domain.\")\n        if isinstance(feat, Input):\n            inputs.append(feat)\n        else:\n            outputs.append(feat)\n    assert len(outputs) &gt; 0, \"At least one output feature has to be provided.\"\n    assert len(inputs) &gt; 0, \"At least one input feature has to be provided.\"\n    inputs = Inputs(features=inputs)\n    outputs = Outputs(features=outputs)\n    # loop over constraints and make sure that all features used in constraints are in the input_feature_keys\n    for c in domain.constraints:\n        for key in c.features:  # type: ignore\n            if key not in inputs.get_keys():\n                raise ValueError(\n                    f\"Removed input feature {key} is used in a constraint.\"\n                )\n    subdomain = deepcopy(domain)\n    subdomain.inputs = inputs\n    subdomain.outputs = outputs\n    return subdomain\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.torch_tools","title":"<code>torch_tools</code>","text":""},{"location":"ref-domain-util/#bofire.utils.torch_tools.constrained_objective2botorch","title":"<code>constrained_objective2botorch(idx, objective)</code>","text":"<p>Create a callable that can be used by <code>botorch.utils.objective.apply_constraints</code> to setup ouput constrained optimizations.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index of the constraint objective in the list of outputs.</p> required <code>objective</code> <code>BotorchConstrainedObjective</code> <p>The objective that should be transformed.</p> required <p>Returns:</p> Type Description <code>Tuple[List[Callable[[Tensor], Tensor]], List[float]]</code> <p>List of callables that can be used by botorch for setting up the constrained objective, and     list of the corresponding botorch eta values.</p> Source code in <code>bofire/utils/torch_tools.py</code> <pre><code>def constrained_objective2botorch(\n    idx: int,\n    objective: ConstrainedObjective,\n) -&gt; Tuple[List[Callable[[Tensor], Tensor]], List[float]]:\n\"\"\"Create a callable that can be used by `botorch.utils.objective.apply_constraints`\n    to setup ouput constrained optimizations.\n\n    Args:\n        idx (int): Index of the constraint objective in the list of outputs.\n        objective (BotorchConstrainedObjective): The objective that should be transformed.\n\n    Returns:\n        Tuple[List[Callable[[Tensor], Tensor]], List[float]]: List of callables that can be used by botorch for setting up the constrained objective, and\n            list of the corresponding botorch eta values.\n    \"\"\"\n    assert isinstance(\n        objective, ConstrainedObjective\n    ), \"Objective is not a `ConstrainedObjective`.\"\n    if isinstance(objective, MaximizeSigmoidObjective):\n        return [lambda Z: (Z[..., idx] - objective.tp) * -1.0], [\n            1.0 / objective.steepness\n        ]\n    elif isinstance(objective, MinimizeSigmoidObjective):\n        return [lambda Z: (Z[..., idx] - objective.tp)], [1.0 / objective.steepness]\n    elif isinstance(objective, TargetObjective):\n        return [\n            lambda Z: (Z[..., idx] - (objective.target_value - objective.tolerance))\n            * -1.0,\n            lambda Z: (Z[..., idx] - (objective.target_value + objective.tolerance)),\n        ], [1.0 / objective.steepness, 1.0 / objective.steepness]\n    else:\n        raise ValueError(f\"Objective {objective.__class__.__name__} not known.\")\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.torch_tools.get_initial_conditions_generator","title":"<code>get_initial_conditions_generator(strategy, transform_specs, ask_options=None, sequential=True)</code>","text":"<p>Takes a strategy object and returns a callable which uses this strategy to return a generator callable which can be used in botorch<code>s</code>gen_batch_initial_conditions` to generate samples.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>Strategy</code> <p>Strategy that should be used to generate samples.</p> required <code>transform_specs</code> <code>Dict</code> <p>Dictionary indicating how the samples should be transformed.</p> required <code>ask_options</code> <code>Dict</code> <p>Dictionary of keyword arguments that are passed to the <code>ask</code> method of the strategy. Defaults to {}.</p> <code>None</code> <code>sequential</code> <code>bool</code> <p>If True, samples for every q-batch are generate indepenent from each other. If False, the <code>n x q</code> samples are generated at once.</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable[[int, int, int], Tensor]</code> <p>Callable that can be passed to     <code>batch_initial_conditions</code>.</p> Source code in <code>bofire/utils/torch_tools.py</code> <pre><code>def get_initial_conditions_generator(\n    strategy: Strategy,\n    transform_specs: Dict,\n    ask_options: Optional[Dict] = None,\n    sequential: bool = True,\n) -&gt; Callable[[int, int, int], Tensor]:\n\"\"\"Takes a strategy object and returns a callable which uses this\n    strategy to return a generator callable which can be used in botorch`s\n    `gen_batch_initial_conditions` to generate samples.\n\n    Args:\n        strategy (Strategy): Strategy that should be used to generate samples.\n        transform_specs (Dict): Dictionary indicating how the samples should be\n            transformed.\n        ask_options (Dict, optional): Dictionary of keyword arguments that are\n            passed to the `ask` method of the strategy. Defaults to {}.\n        sequential (bool, optional): If True, samples for every q-batch are\n            generate indepenent from each other. If False, the `n x q` samples\n            are generated at once.\n\n    Returns:\n        Callable[[int, int, int], Tensor]: Callable that can be passed to\n            `batch_initial_conditions`.\n    \"\"\"\n    if ask_options is None:\n        ask_options = {}\n\n    def generator(n: int, q: int, seed: int) -&gt; Tensor:\n        if sequential:\n            initial_conditions = []\n            for _ in range(n):\n                candidates = strategy.ask(q, **ask_options)\n                # transform it\n                transformed_candidates = strategy.domain.inputs.transform(\n                    candidates, transform_specs\n                )\n                # transform to tensor\n                initial_conditions.append(\n                    torch.from_numpy(transformed_candidates.values).to(**tkwargs)\n                )\n            return torch.stack(initial_conditions, dim=0)\n        else:\n            candidates = strategy.ask(n * q, **ask_options)\n            # transform it\n            transformed_candidates = strategy.domain.inputs.transform(\n                candidates, transform_specs\n            )\n            return (\n                torch.from_numpy(transformed_candidates.values)\n                .to(**tkwargs)\n                .reshape(n, q, transformed_candidates.shape[1])\n            )\n\n    return generator\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.torch_tools.get_linear_constraints","title":"<code>get_linear_constraints(domain, constraint, unit_scaled=False)</code>","text":"<p>Converts linear constraints to the form required by BoTorch.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>Optimization problem definition.</p> required <code>constraint</code> <code>Union[LinearEqualityConstraint, LinearInequalityConstraint]</code> <p>Type of constraint that should be converted.</p> required <code>unit_scaled</code> <code>bool</code> <p>If True, transforms constraints by assuming that the bound for the continuous features are [0,1]. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Tuple[Tensor, Tensor, float]]</code> <p>List of tuples, each tuple consists of a tensor with the feature indices, coefficients and a float for the rhs.</p> Source code in <code>bofire/utils/torch_tools.py</code> <pre><code>def get_linear_constraints(\n    domain: Domain,\n    constraint: Union[LinearEqualityConstraint, LinearInequalityConstraint],\n    unit_scaled: bool = False,\n) -&gt; List[Tuple[Tensor, Tensor, float]]:\n\"\"\"Converts linear constraints to the form required by BoTorch.\n\n    Args:\n        domain (Domain): Optimization problem definition.\n        constraint (Union[LinearEqualityConstraint, LinearInequalityConstraint]): Type of constraint that should be converted.\n        unit_scaled (bool, optional): If True, transforms constraints by assuming that the bound for the continuous features are [0,1]. Defaults to False.\n\n    Returns:\n        List[Tuple[Tensor, Tensor, float]]: List of tuples, each tuple consists of a tensor with the feature indices, coefficients and a float for the rhs.\n    \"\"\"\n    constraints = []\n    for c in domain.constraints.get(constraint):\n        indices = []\n        coefficients = []\n        lower = []\n        upper = []\n        rhs = 0.0\n        for i, featkey in enumerate(c.features):  # type: ignore\n            idx = domain.get_feature_keys(Input).index(featkey)\n            feat = domain.get_feature(featkey)\n            if feat.is_fixed():  # type: ignore\n                rhs -= feat.fixed_value()[0] * c.coefficients[i]  # type: ignore\n            else:\n                lower.append(feat.lower_bound)  # type: ignore\n                upper.append(feat.upper_bound)  # type: ignore\n                indices.append(idx)\n                coefficients.append(\n                    c.coefficients[i]  # type: ignore\n                )  # if unit_scaled == False else c_scaled.coefficients[i])\n        if unit_scaled:\n            lower = np.array(lower)\n            upper = np.array(upper)\n            s = upper - lower\n            scaled_coefficients = s * np.array(coefficients)\n            constraints.append(\n                (\n                    torch.tensor(indices),\n                    -torch.tensor(scaled_coefficients).to(**tkwargs),\n                    -(rhs + c.rhs - np.sum(np.array(coefficients) * lower)),  # type: ignore\n                )\n            )\n        else:\n            constraints.append(\n                (\n                    torch.tensor(indices),\n                    -torch.tensor(coefficients).to(**tkwargs),\n                    -(rhs + c.rhs),  # type: ignore\n                )\n            )\n    return constraints\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.torch_tools.get_multiobjective_objective","title":"<code>get_multiobjective_objective(outputs)</code>","text":"<p>Returns</p> <p>Parameters:</p> Name Type Description Default <code>outputs</code> <code>Outputs</code> <p>description</p> required <p>Returns:</p> Type Description <code>Callable[[Tensor], Tensor]</code> <p>description</p> Source code in <code>bofire/utils/torch_tools.py</code> <pre><code>def get_multiobjective_objective(\n    outputs: Outputs,\n) -&gt; Callable[[Tensor, Optional[Tensor]], Tensor]:\n\"\"\"Returns\n\n    Args:\n        outputs (Outputs): _description_\n\n    Returns:\n        Callable[[Tensor], Tensor]: _description_\n    \"\"\"\n    callables = [\n        get_objective_callable(idx=i, objective=feat.objective)  # type: ignore\n        for i, feat in enumerate(outputs.get())\n        if feat.objective is not None  # type: ignore\n        and isinstance(\n            feat.objective,  # type: ignore\n            (MaximizeObjective, MinimizeObjective, CloseToTargetObjective),\n        )\n    ]\n\n    def objective(samples: Tensor, X: Optional[Tensor] = None) -&gt; Tensor:\n        return torch.stack([c(samples, None) for c in callables], dim=-1)\n\n    return objective\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.torch_tools.get_nchoosek_constraints","title":"<code>get_nchoosek_constraints(domain)</code>","text":"<p>Transforms NChooseK constraints into a list of non-linear inequality constraint callables that can be parsed by pydantic. For this purpose the NChooseK constraint is continuously relaxed by countig the number of zeros in a candidate by a sum of narrow gaussians centered at zero.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>Optimization problem definition.</p> required <p>Returns:</p> Type Description <code>List[Callable[[Tensor], float]]</code> <p>List of callables that can be used     as nonlinear equality constraints in botorch.</p> Source code in <code>bofire/utils/torch_tools.py</code> <pre><code>def get_nchoosek_constraints(domain: Domain) -&gt; List[Callable[[Tensor], float]]:\n\"\"\"Transforms NChooseK constraints into a list of non-linear inequality constraint callables\n    that can be parsed by pydantic. For this purpose the NChooseK constraint is continuously\n    relaxed by countig the number of zeros in a candidate by a sum of narrow gaussians centered\n    at zero.\n\n    Args:\n        domain (Domain): Optimization problem definition.\n\n    Returns:\n        List[Callable[[Tensor], float]]: List of callables that can be used\n            as nonlinear equality constraints in botorch.\n    \"\"\"\n\n    def narrow_gaussian(x, ell=1e-3):\n        return torch.exp(-0.5 * (x / ell) ** 2)\n\n    def max_constraint(indices: Tensor, num_features: int, max_count: int):\n        return lambda x: narrow_gaussian(x=x[..., indices]).sum(dim=-1) - (\n            num_features - max_count\n        )\n\n    def min_constraint(indices: Tensor, num_features: int, min_count: int):\n        return lambda x: -narrow_gaussian(x=x[..., indices]).sum(dim=-1) + (\n            num_features - min_count\n        )\n\n    constraints = []\n    # ignore none also valid for the start\n    for c in domain.constraints.get(NChooseKConstraint):\n        assert isinstance(c, NChooseKConstraint)\n        indices = torch.tensor(\n            [domain.get_feature_keys(ContinuousInput).index(key) for key in c.features],\n            dtype=torch.int64,\n        )\n        if c.max_count != len(c.features):\n            constraints.append(\n                max_constraint(\n                    indices=indices, num_features=len(c.features), max_count=c.max_count\n                )\n            )\n        if c.min_count &gt; 0:\n            constraints.append(\n                min_constraint(\n                    indices=indices, num_features=len(c.features), min_count=c.min_count\n                )\n            )\n    return constraints\n</code></pre>"},{"location":"ref-domain-util/#bofire.utils.torch_tools.get_output_constraints","title":"<code>get_output_constraints(outputs)</code>","text":"<p>Method to translate output constraint objectives into a list of callables and list of etas for use in botorch.</p> <p>Parameters:</p> Name Type Description Default <code>outputs</code> <code>Outputs</code> <p>Output feature object that should be processed.</p> required <p>Returns:</p> Type Description <code>Tuple[List[Callable[[Tensor], Tensor]], List[float]]</code> <p>List of constraint callables,     list of associated etas.</p> Source code in <code>bofire/utils/torch_tools.py</code> <pre><code>def get_output_constraints(\n    outputs: Outputs,\n) -&gt; Tuple[List[Callable[[Tensor], Tensor]], List[float]]:\n\"\"\"Method to translate output constraint objectives into a list of\n    callables and list of etas for use in botorch.\n\n    Args:\n        outputs (Outputs): Output feature object that should\n            be processed.\n\n    Returns:\n        Tuple[List[Callable[[Tensor], Tensor]], List[float]]: List of constraint callables,\n            list of associated etas.\n    \"\"\"\n    constraints = []\n    etas = []\n    for idx, feat in enumerate(outputs.get()):\n        if isinstance(feat.objective, ConstrainedObjective):  # type: ignore\n            iconstraints, ietas = constrained_objective2botorch(\n                idx, objective=feat.objective  # type: ignore\n            )\n            constraints += iconstraints\n            etas += ietas\n    return constraints, etas\n</code></pre>"},{"location":"ref-domain/","title":"Domain","text":""},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain","title":"<code> Domain            (BaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>bofire/data_models/domain/domain.py</code> <pre><code>class Domain(BaseModel):\n    type: Literal[\"Domain\"] = \"Domain\"\n\n    inputs: Inputs = Field(default_factory=lambda: Inputs())\n    outputs: Outputs = Field(default_factory=lambda: Outputs())\n\n    constraints: Constraints = Field(default_factory=lambda: Constraints())\n\n\"\"\"Representation of the optimization problem/domain\n\n    Attributes:\n        inputs (List[Input], optional): List of input features. Defaults to [].\n        outputs (List[Output], optional): List of output features. Defaults to [].\n        constraints (List[Constraint], optional): List of constraints. Defaults to [].\n    \"\"\"\n\n    @classmethod\n    def from_lists(\n        cls,\n        inputs: Optional[Sequence[AnyInput]] = None,\n        outputs: Optional[Sequence[AnyOutput]] = None,\n        constraints: Optional[Sequence[AnyConstraint]] = None,\n    ):\n        inputs = [] if inputs is None else inputs\n        outputs = [] if outputs is None else outputs\n        constraints = [] if constraints is None else constraints\n        return cls(\n            inputs=Inputs(features=inputs),\n            outputs=Outputs(features=outputs),\n            constraints=Constraints(constraints=constraints),\n        )\n\n    @validator(\"inputs\", always=True, pre=True)\n    def validate_inputs_list(cls, v, values):\n        if isinstance(v, collections.abc.Sequence):\n            v = Inputs(features=v)\n            return v\n        if isinstance_or_union(v, AnyInput):\n            return Inputs(features=[v])\n        else:\n            return v\n\n    @validator(\"outputs\", always=True, pre=True)\n    def validate_outputs_list(cls, v, values):\n        if isinstance(v, collections.abc.Sequence):\n            return Outputs(features=v)\n        if isinstance_or_union(v, AnyOutput):\n            return Outputs(features=[v])\n        else:\n            return v\n\n    @validator(\"constraints\", always=True, pre=True)\n    def validate_constraints_list(cls, v, values):\n        if isinstance(v, list):\n            return Constraints(constraints=v)\n        if isinstance_or_union(v, AnyConstraint):\n            return Constraints(constraints=[v])\n        else:\n            return v\n\n    @validator(\"outputs\", always=True)\n    def validate_unique_feature_keys(cls, v: Outputs, values) -&gt; Outputs:\n\"\"\"Validates if provided input and output feature keys are unique\n\n        Args:\n            v (Outputs): List of all output features of the domain.\n            value (Dict[str, Inputs]): Dict containing a list of input features as single entry.\n\n        Raises:\n            ValueError: Feature keys are not unique.\n\n        Returns:\n            Outputs: Keeps output features as given.\n        \"\"\"\n        if \"inputs\" not in values:\n            return v\n        features = v + values[\"inputs\"]\n        keys = [f.key for f in features]\n        if len(set(keys)) != len(keys):\n            raise ValueError(\"feature keys are not unique\")\n        return v\n\n    @validator(\"constraints\", always=True)\n    def validate_constraints(cls, v, values):\n\"\"\"Validate if all features included in the constraints are also defined as features for the domain.\n\n        Args:\n            v (List[Constraint]): List of constraints or empty if no constraints are defined\n            values (List[Input]): List of input features of the domain\n\n        Raises:\n            ValueError: Feature key in constraint is unknown.\n\n        Returns:\n            List[Constraint]: List of constraints defined for the domain\n        \"\"\"\n        if \"inputs\" not in values:\n            return v\n        keys = [f.key for f in values[\"inputs\"]]\n        for c in v:\n            if isinstance(c, LinearConstraint) or isinstance(c, NChooseKConstraint):\n                for f in c.features:\n                    if f not in keys:\n                        raise ValueError(f\"feature {f} in constraint unknown ({keys})\")\n        return v\n\n    @validator(\"constraints\", always=True)\n    def validate_linear_constraints(cls, v, values):\n\"\"\"Validate if all features included in linear constraints are continuous ones.\n\n        Args:\n            v (List[Constraint]): List of constraints or empty if no constraints are defined\n            values (List[Input]): List of input features of the domain\n\n        Raises:\n            ValueError: _description_\n\n\n        Returns:\n           List[Constraint]: List of constraints defined for the domain\n        \"\"\"\n        if \"inputs\" not in values:\n            return v\n\n        # gather continuous inputs in dictionary\n        continuous_inputs_dict = {}\n        for f in values[\"inputs\"]:\n            if type(f) is ContinuousInput:\n                continuous_inputs_dict[f.key] = f\n\n        # check if non continuous input features appear in linear constraints\n        for c in v:\n            if isinstance(c, LinearConstraint):\n                for f in c.features:\n                    assert f in continuous_inputs_dict, f\"{f} must be continuous.\"\n        return v\n\n    def get_feature_reps_df(self) -&gt; pd.DataFrame:\n\"\"\"Returns a pandas dataframe describing the features contained in the optimization domain.\"\"\"\n        df = pd.DataFrame(\n            index=self.get_feature_keys(Feature),\n            columns=[\"Type\", \"Description\"],\n            data={\n                \"Type\": [\n                    feat.__class__.__name__ for feat in self.get_features(Feature)\n                ],\n                \"Description\": [feat.__str__() for feat in self.get_features(Feature)],\n            },\n        )\n        return df\n\n    def get_constraint_reps_df(self):\n\"\"\"Provides a tabular overwiev of all constraints within the domain\n\n        Returns:\n            pd.DataFrame: DataFrame listing all constraints of the domain with a description\n        \"\"\"\n        df = pd.DataFrame(\n            index=range(len(self.constraints)),\n            columns=[\"Type\", \"Description\"],\n            data={\n                \"Type\": [feat.__class__.__name__ for feat in self.constraints],\n                \"Description\": [\n                    constraint.__str__() for constraint in self.constraints\n                ],\n            },\n        )\n        return df\n\n    def get_features(\n        self,\n        includes: Union[Type[Feature], List[Type[Feature]]] = Feature,\n        excludes: Union[Type[Feature], List[Type[Feature]], None] = None,\n        exact: bool = False,\n    ) -&gt; Features:\n\"\"\"get features of the domain\n\n        Args:\n            includes (Union[Type, List[Type]], optional): Feature class or list of specific feature classes to be returned. Defaults to Feature.\n            excludes (Union[Type, List[Type]], optional): Feature class or list of specific feature classes to be excluded from the return. Defaults to None.\n            exact (bool, optional): Boolean to distinguish if only the exact class listed in includes and no subclasses inherenting from this class shall be returned. Defaults to False.\n            by_attribute (str, optional): If set it is filtered by the attribute specified in by `by_attribute`. Defaults to None.\n\n        Returns:\n            List[Feature]: List of features in the domain fitting to the passed requirements.\n        \"\"\"\n        assert isinstance(self.inputs, Inputs)\n        features = self.inputs + self.outputs\n        return features.get(includes, excludes, exact)\n\n    def get_feature_keys(\n        self,\n        includes: Union[Type, List[Type]] = Feature,\n        excludes: Union[Type, List[Type]] = None,\n        exact: bool = False,\n    ) -&gt; List[str]:\n\"\"\"Method to get feature keys of the domain\n\n        Args:\n            includes (Union[Type, List[Type]], optional): Feature class or list of specific feature classes to be returned. Defaults to Feature.\n            excludes (Union[Type, List[Type]], optional): Feature class or list of specific feature classes to be excluded from the return. Defaults to None.\n            exact (bool, optional): Boolean to distinguish if only the exact class listed in includes and no subclasses inherenting from this class shall be returned. Defaults to False.\n\n        Returns:\n            List[str]: List of feature keys fitting to the passed requirements.\n        \"\"\"\n        return [\n            f.key\n            for f in self.get_features(\n                includes=includes,\n                excludes=excludes,\n                exact=exact,\n            )\n        ]\n\n    def get_feature(self, key: str):\n\"\"\"get a specific feature by its key\n\n        Args:\n            key (str): Feature key\n\n        Returns:\n            Feature: The feature with the passed key\n        \"\"\"\n        assert isinstance(self.inputs, Inputs)\n        return {f.key: f for f in self.inputs + self.outputs}[key]\n\n    # TODO: tidy this up\n    def get_nchoosek_combinations(self, exhaustive: bool = False):  # noqa: C901\n\"\"\"get all possible NChooseK combinations\n\n        Args:\n            exhaustive (bool, optional): if True all combinations are returned. Defaults to False.\n\n        Returns:\n            Tuple(used_features_list, unused_features_list): used_features_list is a list of lists containing features used in each NChooseK combination.\n                unused_features_list is a list of lists containing features unused in each NChooseK combination.\n        \"\"\"\n\n        if len(self.constraints.get(NChooseKConstraint)) == 0:\n            used_continuous_features = self.get_feature_keys(ContinuousInput)\n            return used_continuous_features, []\n\n        used_features_list_all = []\n\n        # loops through each NChooseK constraint\n        for con in self.constraints.get(NChooseKConstraint):\n            assert isinstance(con, NChooseKConstraint)\n            used_features_list = []\n\n            if exhaustive:\n                for n in range(con.min_count, con.max_count + 1):\n                    used_features_list.extend(itertools.combinations(con.features, n))\n\n                if con.none_also_valid:\n                    used_features_list.append(())\n            else:\n                used_features_list.extend(\n                    itertools.combinations(con.features, con.max_count)\n                )\n\n            used_features_list_all.append(used_features_list)\n\n        used_features_list_all = list(\n            itertools.product(*used_features_list_all)\n        )  # product between NChooseK constraints\n\n        # format into a list of used features\n        used_features_list_formatted = []\n        for used_features_list in used_features_list_all:\n            used_features_list_flattened = [\n                item for sublist in used_features_list for item in sublist\n            ]\n            used_features_list_formatted.append(list(set(used_features_list_flattened)))\n\n        # sort lists\n        used_features_list_sorted = []\n        for used_features in used_features_list_formatted:\n            used_features_list_sorted.append(sorted(used_features))\n\n        # drop duplicates\n        used_features_list_no_dup = []\n        for used_features in used_features_list_sorted:\n            if used_features not in used_features_list_no_dup:\n                used_features_list_no_dup.append(used_features)\n\n        # print(f\"duplicates dropped: {len(used_features_list_sorted)-len(used_features_list_no_dup)}\")\n\n        # remove combinations not fulfilling constraints\n        used_features_list_final = []\n        for combo in used_features_list_no_dup:\n            fulfil_constraints = (\n                []\n            )  # list of bools tracking if constraints are fulfilled\n            for con in self.constraints.get(NChooseKConstraint):\n                assert isinstance(con, NChooseKConstraint)\n                count = 0  # count of features in combo that are in con.features\n                for f in combo:\n                    if f in con.features:\n                        count += 1\n                if count &gt;= con.min_count and count &lt;= con.max_count:\n                    fulfil_constraints.append(True)\n                elif count == 0 and con.none_also_valid:\n                    fulfil_constraints.append(True)\n                else:\n                    fulfil_constraints.append(False)\n            if np.all(fulfil_constraints):\n                used_features_list_final.append(combo)\n\n        # print(f\"violators dropped: {len(used_features_list_no_dup)-len(used_features_list_final)}\")\n\n        # features unused\n        features_in_cc = []\n        for con in self.constraints.get(NChooseKConstraint):\n            assert isinstance(con, NChooseKConstraint)\n            features_in_cc.extend(con.features)\n        features_in_cc = list(set(features_in_cc))\n        features_in_cc.sort()\n        unused_features_list = []\n        for used_features in used_features_list_final:\n            unused_features_list.append(\n                [f_key for f_key in features_in_cc if f_key not in used_features]\n            )\n\n        # postprocess\n        # used_features_list_final2 = []\n        # unused_features_list2 = []\n        # for used, unused in zip(used_features_list_final,unused_features_list):\n        #     if len(used) == 3:\n        #         used_features_list_final2.append(used), unused_features_list2.append(unused)\n\n        return used_features_list_final, unused_features_list\n\n    def coerce_invalids(self, experiments: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Coerces all invalid output measurements to np.nan\n\n        Args:\n            experiments (pd.DataFrame): Dataframe containing experimental data\n\n        Returns:\n            pd.DataFrame: coerced dataframe\n        \"\"\"\n        # coerce invalid to nan\n        for feat in self.get_feature_keys(Output):\n            experiments.loc[experiments[f\"valid_{feat}\"] == 0, feat] = np.nan\n        return experiments\n\n    def aggregate_by_duplicates(\n        self, experiments: pd.DataFrame, prec: int, delimiter: str = \"-\"\n    ) -&gt; Tuple[pd.DataFrame, list]:\n\"\"\"Aggregate the dataframe by duplicate experiments\n\n        Duplicates are identified based on the experiments with the same input features. Continuous input features\n        are rounded before identifying the duplicates. Aggregation is performed by taking the average of the\n        involved output features.\n\n        Args:\n            experiments (pd.DataFrame): Dataframe containing experimental data\n            prec (int): Precision of the rounding of the continuous input features\n            delimiter (str, optional): Delimiter used when combining the orig. labcodes to a new one. Defaults to \"-\".\n\n        Returns:\n            Tuple[pd.DataFrame, list]: Dataframe holding the aggregated experiments, list of lists holding the labcodes of the duplicates\n        \"\"\"\n        # prepare the parent frame\n\n        preprocessed = self.outputs.preprocess_experiments_any_valid_output(experiments)\n        assert preprocessed is not None\n        experiments = preprocessed.copy()\n        if \"labcode\" not in experiments.columns:\n            experiments[\"labcode\"] = [\n                str(i + 1).zfill(int(np.ceil(np.log10(experiments.shape[0]))))\n                for i in range(experiments.shape[0])\n            ]\n\n        # round it\n        experiments[self.get_feature_keys(ContinuousInput)] = experiments[\n            self.get_feature_keys(ContinuousInput)\n        ].round(prec)\n\n        # coerce invalid to nan\n        experiments = self.coerce_invalids(experiments)\n\n        # group and aggregate\n        agg: Dict[str, Any] = {\n            feat: \"mean\" for feat in self.get_feature_keys(ContinuousOutput)\n        }\n        agg[\"labcode\"] = lambda x: delimiter.join(sorted(x.tolist()))\n        for feat in self.get_feature_keys(Output):\n            agg[f\"valid_{feat}\"] = lambda x: 1\n\n        grouped = experiments.groupby(self.get_feature_keys(Input))\n        duplicated_labcodes = [\n            sorted(group.labcode.to_numpy().tolist())\n            for _, group in grouped\n            if group.shape[0] &gt; 1\n        ]\n\n        experiments = grouped.aggregate(agg).reset_index(drop=False)\n        for feat in self.get_feature_keys(Output):\n            experiments.loc[experiments[feat].isna(), f\"valid_{feat}\"] = 0\n\n        experiments = experiments.sort_values(by=\"labcode\")\n        experiments = experiments.reset_index(drop=True)\n        return experiments, sorted(duplicated_labcodes)\n\n    def validate_experiments(\n        self,\n        experiments: pd.DataFrame,\n        strict: bool = False,\n    ) -&gt; pd.DataFrame:\n\"\"\"checks the experimental data on validity\n\n        Args:\n            experiments (pd.DataFrame): Dataframe with experimental data\n\n        Raises:\n            ValueError: empty dataframe\n            ValueError: the column for a specific feature is missing the provided data\n            ValueError: there are labcodes with null value\n            ValueError: there are labcodes with nan value\n            ValueError: labcodes are not unique\n            ValueError: the provided columns do no match to the defined domain\n            ValueError: the provided columns do no match to the defined domain\n            ValueError: Input with null values\n            ValueError: Input with nan values\n\n        Returns:\n            pd.DataFrame: The provided dataframe with experimental data\n        \"\"\"\n\n        if len(experiments) == 0:\n            raise ValueError(\"no experiments provided (empty dataframe)\")\n        # check that each feature is a col\n        feature_keys = self.get_feature_keys()\n        for feature_key in feature_keys:\n            if feature_key not in experiments:\n                raise ValueError(f\"no col in experiments for feature {feature_key}\")\n        # add valid_{key} cols if missing\n        valid_keys = [\n            f\"valid_{output_feature_key}\"\n            for output_feature_key in self.get_feature_keys(Output)\n        ]\n        for valid_key in valid_keys:\n            if valid_key not in experiments:\n                experiments[valid_key] = True\n        # check all cols\n        expected = feature_keys + valid_keys\n        cols = list(experiments.columns)\n        # we allow here for a column named labcode used to identify experiments\n        if \"labcode\" in cols:\n            # test that labcodes are not na\n            if experiments.labcode.isnull().to_numpy().any():\n                raise ValueError(\"there are labcodes with null value\")\n            if experiments.labcode.isna().to_numpy().any():\n                raise ValueError(\"there are labcodes with nan value\")\n            # test that labcodes are distinct\n            if (\n                len(set(experiments.labcode.to_numpy().tolist()))\n                != experiments.shape[0]\n            ):\n                raise ValueError(\"labcodes are not unique\")\n            # we remove the labcode from the cols list to proceed as before\n            cols.remove(\"labcode\")\n        if len(expected) != len(cols):\n            raise ValueError(f\"expected the following cols: `{expected}`, got `{cols}`\")\n        if len(set(expected + cols)) != len(cols):\n            raise ValueError(f\"expected the following cols: `{expected}`, got `{cols}`\")\n        # check values of continuous input features\n        if experiments[self.get_feature_keys(Input)].isnull().to_numpy().any():\n            raise ValueError(\"there are null values\")\n        if experiments[self.get_feature_keys(Input)].isna().to_numpy().any():\n            raise ValueError(\"there are na values\")\n        # run the individual validators\n        for feat in self.get_features(Input):\n            assert isinstance(feat, Input)\n            feat.validate_experimental(experiments[feat.key], strict=strict)\n        return experiments\n\n    def describe_experiments(self, experiments: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Method to get a tabular overview of how many measurements and how many valid entries are included in the input data for each output feature\n\n        Args:\n            experiments (pd.DataFrame): Dataframe with experimental data\n\n        Returns:\n            pd.DataFrame: Dataframe with counts how many measurements and how many valid entries are included in the input data for each output feature\n        \"\"\"\n        data = {}\n        for feat in self.get_feature_keys(Output):\n            data[feat] = [\n                experiments.loc[experiments[feat].notna()].shape[0],\n                experiments.loc[experiments[feat].notna(), \"valid_%s\" % feat].sum(),\n            ]\n        preprocessed = self.outputs.preprocess_experiments_all_valid_outputs(\n            experiments\n        )\n        assert preprocessed is not None\n        data[\"all\"] = [\n            experiments.shape[0],\n            preprocessed.shape[0],\n        ]\n        return pd.DataFrame.from_dict(\n            data, orient=\"index\", columns=[\"measured\", \"valid\"]\n        )\n\n    def validate_candidates(\n        self,\n        candidates: pd.DataFrame,\n        only_inputs: bool = False,\n        tol: float = 1e-5,\n        raise_validation_error: bool = True,\n    ) -&gt; pd.DataFrame:\n\"\"\"Method to check the validty of porposed candidates\n\n        Args:\n            candidates (pd.DataFrame): Dataframe with suggested new experiments (candidates)\n            only_inputs (bool,optional): If True, only the input columns are validated. Defaults to False.\n            tol (float,optional): tolerance parameter for constraints. A constraint is considered as not fulfilled if the violation\n                is larger than tol. Defaults to 1e-6.\n            raise_validation_error (bool, optional): If true an error will be raised if candidates violate constraints,\n                otherwise only a warning will be displayed. Defaults to True.\n\n        Raises:\n            ValueError: when a column is missing for a defined input feature\n            ValueError: when a column is missing for a defined output feature\n            ValueError: when a non-numerical value is proposed\n            ValueError: when an additional column is found\n            ConstraintNotFulfilledError: when the constraints are not fulfilled and `raise_validation_error = True`\n\n        Returns:\n            pd.DataFrame: dataframe with suggested experiments (candidates)\n        \"\"\"\n        # check that each input feature has a col and is valid in itself\n        assert isinstance(self.inputs, Inputs)\n        self.inputs.validate_inputs(candidates)\n        # check if all constraints are fulfilled\n        if not self.constraints.is_fulfilled(candidates, tol=tol).all():\n            if raise_validation_error:\n                raise ConstraintNotFulfilledError(\n                    f\"Constraints not fulfilled: {candidates}\"\n                )\n            warnings.warn(\"Not all constraints are fulfilled.\")\n        # for each continuous output feature with an attached objective object\n        if not only_inputs:\n            assert isinstance(self.outputs, Outputs)\n\n            cols = list(\n                itertools.chain.from_iterable(\n                    [\n                        [f\"{key}_pred\", f\"{key}_sd\", f\"{key}_des\"]\n                        for key in self.outputs.get_keys_by_objective(Objective)\n                    ]\n                    + [\n                        [f\"{key}_pred\", f\"{key}_sd\"]\n                        for key in self.outputs.get_keys_by_objective(\n                            excludes=Objective, includes=None  # type: ignore\n                        )\n                    ]\n                )\n            )\n\n            # check that pred, sd, and des cols are specified and numerical\n            for col in cols:\n                if col not in candidates:\n                    raise ValueError(f\"missing column {col}\")\n                if (not is_numeric(candidates[col])) and (\n                    not candidates[col].isnull().to_numpy().all()\n                ):\n                    raise ValueError(f\"not all values of column `{col}` are numerical\")\n\n            # validate no additional cols exist\n            if_count = len(self.get_features(Input))\n            of_count = len(self.outputs.get_by_objective(includes=Objective))\n            of_count_w = len(self.outputs.get_by_objective(excludes=Objective, includes=None))  # type: ignore\n            # input features, prediction, standard deviation and reward for each output feature, 3 additional usefull infos: reward, aquisition function, strategy\n            if len(candidates.columns) != if_count + 3 * of_count + 2 * of_count_w:\n                raise ValueError(\"additional columns found\")\n        return candidates\n\n    @property\n    def experiment_column_names(self):\n\"\"\"the columns in the experimental dataframe\n\n        Returns:\n            List[str]: List of columns in the experiment dataframe (output feature keys + valid_output feature keys)\n        \"\"\"\n        return self.get_feature_keys() + [\n            f\"valid_{output_feature_key}\"\n            for output_feature_key in self.get_feature_keys(Output)\n        ]\n\n    @property\n    def candidate_column_names(self):\n\"\"\"the columns in the candidate dataframe\n\n        Returns:\n            List[str]: List of columns in the candidate dataframe (input feature keys + input feature keys_pred, input feature keys_sd, input feature keys_des)\n        \"\"\"\n        assert isinstance(self.outputs, Outputs)\n        return (\n            self.get_feature_keys(Input)\n            + [\n                f\"{output_feature_key}_pred\"\n                for output_feature_key in self.outputs.get_keys_by_objective(Objective)\n            ]\n            + [\n                f\"{output_feature_key}_sd\"\n                for output_feature_key in self.outputs.get_keys_by_objective(Objective)\n            ]\n            + [\n                f\"{output_feature_key}_des\"\n                for output_feature_key in self.outputs.get_keys_by_objective(Objective)\n            ]\n        )\n\n    def _set_constraints_unvalidated(\n        self, constraints: Union[Sequence[AnyConstraint], Constraints]\n    ):\n\"\"\"Hack for reduce_domain\"\"\"\n        self.constraints = Constraints(constraints=[])\n        if isinstance(constraints, Constraints):\n            constraints = constraints.constraints\n        self.constraints.constraints = constraints\n</code></pre>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.candidate_column_names","title":"<code>candidate_column_names</code>  <code>property</code> <code>readonly</code>","text":"<p>the columns in the candidate dataframe</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of columns in the candidate dataframe (input feature keys + input feature keys_pred, input feature keys_sd, input feature keys_des)</p>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.experiment_column_names","title":"<code>experiment_column_names</code>  <code>property</code> <code>readonly</code>","text":"<p>the columns in the experimental dataframe</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of columns in the experiment dataframe (output feature keys + valid_output feature keys)</p>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.aggregate_by_duplicates","title":"<code>aggregate_by_duplicates(self, experiments, prec, delimiter='-')</code>","text":"<p>Aggregate the dataframe by duplicate experiments</p> <p>Duplicates are identified based on the experiments with the same input features. Continuous input features are rounded before identifying the duplicates. Aggregation is performed by taking the average of the involved output features.</p> <p>Parameters:</p> Name Type Description Default <code>experiments</code> <code>pd.DataFrame</code> <p>Dataframe containing experimental data</p> required <code>prec</code> <code>int</code> <p>Precision of the rounding of the continuous input features</p> required <code>delimiter</code> <code>str</code> <p>Delimiter used when combining the orig. labcodes to a new one. Defaults to \"-\".</p> <code>'-'</code> <p>Returns:</p> Type Description <code>Tuple[pd.DataFrame, list]</code> <p>Dataframe holding the aggregated experiments, list of lists holding the labcodes of the duplicates</p> Source code in <code>bofire/data_models/domain/domain.py</code> <pre><code>def aggregate_by_duplicates(\n    self, experiments: pd.DataFrame, prec: int, delimiter: str = \"-\"\n) -&gt; Tuple[pd.DataFrame, list]:\n\"\"\"Aggregate the dataframe by duplicate experiments\n\n    Duplicates are identified based on the experiments with the same input features. Continuous input features\n    are rounded before identifying the duplicates. Aggregation is performed by taking the average of the\n    involved output features.\n\n    Args:\n        experiments (pd.DataFrame): Dataframe containing experimental data\n        prec (int): Precision of the rounding of the continuous input features\n        delimiter (str, optional): Delimiter used when combining the orig. labcodes to a new one. Defaults to \"-\".\n\n    Returns:\n        Tuple[pd.DataFrame, list]: Dataframe holding the aggregated experiments, list of lists holding the labcodes of the duplicates\n    \"\"\"\n    # prepare the parent frame\n\n    preprocessed = self.outputs.preprocess_experiments_any_valid_output(experiments)\n    assert preprocessed is not None\n    experiments = preprocessed.copy()\n    if \"labcode\" not in experiments.columns:\n        experiments[\"labcode\"] = [\n            str(i + 1).zfill(int(np.ceil(np.log10(experiments.shape[0]))))\n            for i in range(experiments.shape[0])\n        ]\n\n    # round it\n    experiments[self.get_feature_keys(ContinuousInput)] = experiments[\n        self.get_feature_keys(ContinuousInput)\n    ].round(prec)\n\n    # coerce invalid to nan\n    experiments = self.coerce_invalids(experiments)\n\n    # group and aggregate\n    agg: Dict[str, Any] = {\n        feat: \"mean\" for feat in self.get_feature_keys(ContinuousOutput)\n    }\n    agg[\"labcode\"] = lambda x: delimiter.join(sorted(x.tolist()))\n    for feat in self.get_feature_keys(Output):\n        agg[f\"valid_{feat}\"] = lambda x: 1\n\n    grouped = experiments.groupby(self.get_feature_keys(Input))\n    duplicated_labcodes = [\n        sorted(group.labcode.to_numpy().tolist())\n        for _, group in grouped\n        if group.shape[0] &gt; 1\n    ]\n\n    experiments = grouped.aggregate(agg).reset_index(drop=False)\n    for feat in self.get_feature_keys(Output):\n        experiments.loc[experiments[feat].isna(), f\"valid_{feat}\"] = 0\n\n    experiments = experiments.sort_values(by=\"labcode\")\n    experiments = experiments.reset_index(drop=True)\n    return experiments, sorted(duplicated_labcodes)\n</code></pre>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.coerce_invalids","title":"<code>coerce_invalids(self, experiments)</code>","text":"<p>Coerces all invalid output measurements to np.nan</p> <p>Parameters:</p> Name Type Description Default <code>experiments</code> <code>pd.DataFrame</code> <p>Dataframe containing experimental data</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>coerced dataframe</p> Source code in <code>bofire/data_models/domain/domain.py</code> <pre><code>def coerce_invalids(self, experiments: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Coerces all invalid output measurements to np.nan\n\n    Args:\n        experiments (pd.DataFrame): Dataframe containing experimental data\n\n    Returns:\n        pd.DataFrame: coerced dataframe\n    \"\"\"\n    # coerce invalid to nan\n    for feat in self.get_feature_keys(Output):\n        experiments.loc[experiments[f\"valid_{feat}\"] == 0, feat] = np.nan\n    return experiments\n</code></pre>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.describe_experiments","title":"<code>describe_experiments(self, experiments)</code>","text":"<p>Method to get a tabular overview of how many measurements and how many valid entries are included in the input data for each output feature</p> <p>Parameters:</p> Name Type Description Default <code>experiments</code> <code>pd.DataFrame</code> <p>Dataframe with experimental data</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Dataframe with counts how many measurements and how many valid entries are included in the input data for each output feature</p> Source code in <code>bofire/data_models/domain/domain.py</code> <pre><code>def describe_experiments(self, experiments: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Method to get a tabular overview of how many measurements and how many valid entries are included in the input data for each output feature\n\n    Args:\n        experiments (pd.DataFrame): Dataframe with experimental data\n\n    Returns:\n        pd.DataFrame: Dataframe with counts how many measurements and how many valid entries are included in the input data for each output feature\n    \"\"\"\n    data = {}\n    for feat in self.get_feature_keys(Output):\n        data[feat] = [\n            experiments.loc[experiments[feat].notna()].shape[0],\n            experiments.loc[experiments[feat].notna(), \"valid_%s\" % feat].sum(),\n        ]\n    preprocessed = self.outputs.preprocess_experiments_all_valid_outputs(\n        experiments\n    )\n    assert preprocessed is not None\n    data[\"all\"] = [\n        experiments.shape[0],\n        preprocessed.shape[0],\n    ]\n    return pd.DataFrame.from_dict(\n        data, orient=\"index\", columns=[\"measured\", \"valid\"]\n    )\n</code></pre>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.get_constraint_reps_df","title":"<code>get_constraint_reps_df(self)</code>","text":"<p>Provides a tabular overwiev of all constraints within the domain</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>DataFrame listing all constraints of the domain with a description</p> Source code in <code>bofire/data_models/domain/domain.py</code> <pre><code>def get_constraint_reps_df(self):\n\"\"\"Provides a tabular overwiev of all constraints within the domain\n\n    Returns:\n        pd.DataFrame: DataFrame listing all constraints of the domain with a description\n    \"\"\"\n    df = pd.DataFrame(\n        index=range(len(self.constraints)),\n        columns=[\"Type\", \"Description\"],\n        data={\n            \"Type\": [feat.__class__.__name__ for feat in self.constraints],\n            \"Description\": [\n                constraint.__str__() for constraint in self.constraints\n            ],\n        },\n    )\n    return df\n</code></pre>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.get_feature","title":"<code>get_feature(self, key)</code>","text":"<p>get a specific feature by its key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Feature key</p> required <p>Returns:</p> Type Description <code>Feature</code> <p>The feature with the passed key</p> Source code in <code>bofire/data_models/domain/domain.py</code> <pre><code>def get_feature(self, key: str):\n\"\"\"get a specific feature by its key\n\n    Args:\n        key (str): Feature key\n\n    Returns:\n        Feature: The feature with the passed key\n    \"\"\"\n    assert isinstance(self.inputs, Inputs)\n    return {f.key: f for f in self.inputs + self.outputs}[key]\n</code></pre>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.get_feature_keys","title":"<code>get_feature_keys(self, includes=&lt;class 'bofire.data_models.features.feature.Feature'&gt;, excludes=None, exact=False)</code>","text":"<p>Method to get feature keys of the domain</p> <p>Parameters:</p> Name Type Description Default <code>includes</code> <code>Union[Type, List[Type]]</code> <p>Feature class or list of specific feature classes to be returned. Defaults to Feature.</p> <code>&lt;class 'bofire.data_models.features.feature.Feature'&gt;</code> <code>excludes</code> <code>Union[Type, List[Type]]</code> <p>Feature class or list of specific feature classes to be excluded from the return. Defaults to None.</p> <code>None</code> <code>exact</code> <code>bool</code> <p>Boolean to distinguish if only the exact class listed in includes and no subclasses inherenting from this class shall be returned. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of feature keys fitting to the passed requirements.</p> Source code in <code>bofire/data_models/domain/domain.py</code> <pre><code>def get_feature_keys(\n    self,\n    includes: Union[Type, List[Type]] = Feature,\n    excludes: Union[Type, List[Type]] = None,\n    exact: bool = False,\n) -&gt; List[str]:\n\"\"\"Method to get feature keys of the domain\n\n    Args:\n        includes (Union[Type, List[Type]], optional): Feature class or list of specific feature classes to be returned. Defaults to Feature.\n        excludes (Union[Type, List[Type]], optional): Feature class or list of specific feature classes to be excluded from the return. Defaults to None.\n        exact (bool, optional): Boolean to distinguish if only the exact class listed in includes and no subclasses inherenting from this class shall be returned. Defaults to False.\n\n    Returns:\n        List[str]: List of feature keys fitting to the passed requirements.\n    \"\"\"\n    return [\n        f.key\n        for f in self.get_features(\n            includes=includes,\n            excludes=excludes,\n            exact=exact,\n        )\n    ]\n</code></pre>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.get_feature_reps_df","title":"<code>get_feature_reps_df(self)</code>","text":"<p>Returns a pandas dataframe describing the features contained in the optimization domain.</p> Source code in <code>bofire/data_models/domain/domain.py</code> <pre><code>def get_feature_reps_df(self) -&gt; pd.DataFrame:\n\"\"\"Returns a pandas dataframe describing the features contained in the optimization domain.\"\"\"\n    df = pd.DataFrame(\n        index=self.get_feature_keys(Feature),\n        columns=[\"Type\", \"Description\"],\n        data={\n            \"Type\": [\n                feat.__class__.__name__ for feat in self.get_features(Feature)\n            ],\n            \"Description\": [feat.__str__() for feat in self.get_features(Feature)],\n        },\n    )\n    return df\n</code></pre>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.get_features","title":"<code>get_features(self, includes=&lt;class 'bofire.data_models.features.feature.Feature'&gt;, excludes=None, exact=False)</code>","text":"<p>get features of the domain</p> <p>Parameters:</p> Name Type Description Default <code>includes</code> <code>Union[Type, List[Type]]</code> <p>Feature class or list of specific feature classes to be returned. Defaults to Feature.</p> <code>&lt;class 'bofire.data_models.features.feature.Feature'&gt;</code> <code>excludes</code> <code>Union[Type, List[Type]]</code> <p>Feature class or list of specific feature classes to be excluded from the return. Defaults to None.</p> <code>None</code> <code>exact</code> <code>bool</code> <p>Boolean to distinguish if only the exact class listed in includes and no subclasses inherenting from this class shall be returned. Defaults to False.</p> <code>False</code> <code>by_attribute</code> <code>str</code> <p>If set it is filtered by the attribute specified in by <code>by_attribute</code>. Defaults to None.</p> required <p>Returns:</p> Type Description <code>List[Feature]</code> <p>List of features in the domain fitting to the passed requirements.</p> Source code in <code>bofire/data_models/domain/domain.py</code> <pre><code>def get_features(\n    self,\n    includes: Union[Type[Feature], List[Type[Feature]]] = Feature,\n    excludes: Union[Type[Feature], List[Type[Feature]], None] = None,\n    exact: bool = False,\n) -&gt; Features:\n\"\"\"get features of the domain\n\n    Args:\n        includes (Union[Type, List[Type]], optional): Feature class or list of specific feature classes to be returned. Defaults to Feature.\n        excludes (Union[Type, List[Type]], optional): Feature class or list of specific feature classes to be excluded from the return. Defaults to None.\n        exact (bool, optional): Boolean to distinguish if only the exact class listed in includes and no subclasses inherenting from this class shall be returned. Defaults to False.\n        by_attribute (str, optional): If set it is filtered by the attribute specified in by `by_attribute`. Defaults to None.\n\n    Returns:\n        List[Feature]: List of features in the domain fitting to the passed requirements.\n    \"\"\"\n    assert isinstance(self.inputs, Inputs)\n    features = self.inputs + self.outputs\n    return features.get(includes, excludes, exact)\n</code></pre>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.get_nchoosek_combinations","title":"<code>get_nchoosek_combinations(self, exhaustive=False)</code>","text":"<p>get all possible NChooseK combinations</p> <p>Parameters:</p> Name Type Description Default <code>exhaustive</code> <code>bool</code> <p>if True all combinations are returned. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple(used_features_list, unused_features_list)</code> <p>used_features_list is a list of lists containing features used in each NChooseK combination.     unused_features_list is a list of lists containing features unused in each NChooseK combination.</p> Source code in <code>bofire/data_models/domain/domain.py</code> <pre><code>def get_nchoosek_combinations(self, exhaustive: bool = False):  # noqa: C901\n\"\"\"get all possible NChooseK combinations\n\n    Args:\n        exhaustive (bool, optional): if True all combinations are returned. Defaults to False.\n\n    Returns:\n        Tuple(used_features_list, unused_features_list): used_features_list is a list of lists containing features used in each NChooseK combination.\n            unused_features_list is a list of lists containing features unused in each NChooseK combination.\n    \"\"\"\n\n    if len(self.constraints.get(NChooseKConstraint)) == 0:\n        used_continuous_features = self.get_feature_keys(ContinuousInput)\n        return used_continuous_features, []\n\n    used_features_list_all = []\n\n    # loops through each NChooseK constraint\n    for con in self.constraints.get(NChooseKConstraint):\n        assert isinstance(con, NChooseKConstraint)\n        used_features_list = []\n\n        if exhaustive:\n            for n in range(con.min_count, con.max_count + 1):\n                used_features_list.extend(itertools.combinations(con.features, n))\n\n            if con.none_also_valid:\n                used_features_list.append(())\n        else:\n            used_features_list.extend(\n                itertools.combinations(con.features, con.max_count)\n            )\n\n        used_features_list_all.append(used_features_list)\n\n    used_features_list_all = list(\n        itertools.product(*used_features_list_all)\n    )  # product between NChooseK constraints\n\n    # format into a list of used features\n    used_features_list_formatted = []\n    for used_features_list in used_features_list_all:\n        used_features_list_flattened = [\n            item for sublist in used_features_list for item in sublist\n        ]\n        used_features_list_formatted.append(list(set(used_features_list_flattened)))\n\n    # sort lists\n    used_features_list_sorted = []\n    for used_features in used_features_list_formatted:\n        used_features_list_sorted.append(sorted(used_features))\n\n    # drop duplicates\n    used_features_list_no_dup = []\n    for used_features in used_features_list_sorted:\n        if used_features not in used_features_list_no_dup:\n            used_features_list_no_dup.append(used_features)\n\n    # print(f\"duplicates dropped: {len(used_features_list_sorted)-len(used_features_list_no_dup)}\")\n\n    # remove combinations not fulfilling constraints\n    used_features_list_final = []\n    for combo in used_features_list_no_dup:\n        fulfil_constraints = (\n            []\n        )  # list of bools tracking if constraints are fulfilled\n        for con in self.constraints.get(NChooseKConstraint):\n            assert isinstance(con, NChooseKConstraint)\n            count = 0  # count of features in combo that are in con.features\n            for f in combo:\n                if f in con.features:\n                    count += 1\n            if count &gt;= con.min_count and count &lt;= con.max_count:\n                fulfil_constraints.append(True)\n            elif count == 0 and con.none_also_valid:\n                fulfil_constraints.append(True)\n            else:\n                fulfil_constraints.append(False)\n        if np.all(fulfil_constraints):\n            used_features_list_final.append(combo)\n\n    # print(f\"violators dropped: {len(used_features_list_no_dup)-len(used_features_list_final)}\")\n\n    # features unused\n    features_in_cc = []\n    for con in self.constraints.get(NChooseKConstraint):\n        assert isinstance(con, NChooseKConstraint)\n        features_in_cc.extend(con.features)\n    features_in_cc = list(set(features_in_cc))\n    features_in_cc.sort()\n    unused_features_list = []\n    for used_features in used_features_list_final:\n        unused_features_list.append(\n            [f_key for f_key in features_in_cc if f_key not in used_features]\n        )\n\n    # postprocess\n    # used_features_list_final2 = []\n    # unused_features_list2 = []\n    # for used, unused in zip(used_features_list_final,unused_features_list):\n    #     if len(used) == 3:\n    #         used_features_list_final2.append(used), unused_features_list2.append(unused)\n\n    return used_features_list_final, unused_features_list\n</code></pre>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.validate_candidates","title":"<code>validate_candidates(self, candidates, only_inputs=False, tol=1e-05, raise_validation_error=True)</code>","text":"<p>Method to check the validty of porposed candidates</p> <p>Parameters:</p> Name Type Description Default <code>candidates</code> <code>pd.DataFrame</code> <p>Dataframe with suggested new experiments (candidates)</p> required <code>only_inputs</code> <code>bool,optional</code> <p>If True, only the input columns are validated. Defaults to False.</p> <code>False</code> <code>tol</code> <code>float,optional</code> <p>tolerance parameter for constraints. A constraint is considered as not fulfilled if the violation is larger than tol. Defaults to 1e-6.</p> <code>1e-05</code> <code>raise_validation_error</code> <code>bool</code> <p>If true an error will be raised if candidates violate constraints, otherwise only a warning will be displayed. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>when a column is missing for a defined input feature</p> <code>ValueError</code> <p>when a column is missing for a defined output feature</p> <code>ValueError</code> <p>when a non-numerical value is proposed</p> <code>ValueError</code> <p>when an additional column is found</p> <code>ConstraintNotFulfilledError</code> <p>when the constraints are not fulfilled and <code>raise_validation_error = True</code></p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>dataframe with suggested experiments (candidates)</p> Source code in <code>bofire/data_models/domain/domain.py</code> <pre><code>def validate_candidates(\n    self,\n    candidates: pd.DataFrame,\n    only_inputs: bool = False,\n    tol: float = 1e-5,\n    raise_validation_error: bool = True,\n) -&gt; pd.DataFrame:\n\"\"\"Method to check the validty of porposed candidates\n\n    Args:\n        candidates (pd.DataFrame): Dataframe with suggested new experiments (candidates)\n        only_inputs (bool,optional): If True, only the input columns are validated. Defaults to False.\n        tol (float,optional): tolerance parameter for constraints. A constraint is considered as not fulfilled if the violation\n            is larger than tol. Defaults to 1e-6.\n        raise_validation_error (bool, optional): If true an error will be raised if candidates violate constraints,\n            otherwise only a warning will be displayed. Defaults to True.\n\n    Raises:\n        ValueError: when a column is missing for a defined input feature\n        ValueError: when a column is missing for a defined output feature\n        ValueError: when a non-numerical value is proposed\n        ValueError: when an additional column is found\n        ConstraintNotFulfilledError: when the constraints are not fulfilled and `raise_validation_error = True`\n\n    Returns:\n        pd.DataFrame: dataframe with suggested experiments (candidates)\n    \"\"\"\n    # check that each input feature has a col and is valid in itself\n    assert isinstance(self.inputs, Inputs)\n    self.inputs.validate_inputs(candidates)\n    # check if all constraints are fulfilled\n    if not self.constraints.is_fulfilled(candidates, tol=tol).all():\n        if raise_validation_error:\n            raise ConstraintNotFulfilledError(\n                f\"Constraints not fulfilled: {candidates}\"\n            )\n        warnings.warn(\"Not all constraints are fulfilled.\")\n    # for each continuous output feature with an attached objective object\n    if not only_inputs:\n        assert isinstance(self.outputs, Outputs)\n\n        cols = list(\n            itertools.chain.from_iterable(\n                [\n                    [f\"{key}_pred\", f\"{key}_sd\", f\"{key}_des\"]\n                    for key in self.outputs.get_keys_by_objective(Objective)\n                ]\n                + [\n                    [f\"{key}_pred\", f\"{key}_sd\"]\n                    for key in self.outputs.get_keys_by_objective(\n                        excludes=Objective, includes=None  # type: ignore\n                    )\n                ]\n            )\n        )\n\n        # check that pred, sd, and des cols are specified and numerical\n        for col in cols:\n            if col not in candidates:\n                raise ValueError(f\"missing column {col}\")\n            if (not is_numeric(candidates[col])) and (\n                not candidates[col].isnull().to_numpy().all()\n            ):\n                raise ValueError(f\"not all values of column `{col}` are numerical\")\n\n        # validate no additional cols exist\n        if_count = len(self.get_features(Input))\n        of_count = len(self.outputs.get_by_objective(includes=Objective))\n        of_count_w = len(self.outputs.get_by_objective(excludes=Objective, includes=None))  # type: ignore\n        # input features, prediction, standard deviation and reward for each output feature, 3 additional usefull infos: reward, aquisition function, strategy\n        if len(candidates.columns) != if_count + 3 * of_count + 2 * of_count_w:\n            raise ValueError(\"additional columns found\")\n    return candidates\n</code></pre>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.validate_constraints","title":"<code>validate_constraints(v, values)</code>  <code>classmethod</code>","text":"<p>Validate if all features included in the constraints are also defined as features for the domain.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>List[Constraint]</code> <p>List of constraints or empty if no constraints are defined</p> required <code>values</code> <code>List[Input]</code> <p>List of input features of the domain</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>Feature key in constraint is unknown.</p> <p>Returns:</p> Type Description <code>List[Constraint]</code> <p>List of constraints defined for the domain</p> Source code in <code>bofire/data_models/domain/domain.py</code> <pre><code>@validator(\"constraints\", always=True)\ndef validate_constraints(cls, v, values):\n\"\"\"Validate if all features included in the constraints are also defined as features for the domain.\n\n    Args:\n        v (List[Constraint]): List of constraints or empty if no constraints are defined\n        values (List[Input]): List of input features of the domain\n\n    Raises:\n        ValueError: Feature key in constraint is unknown.\n\n    Returns:\n        List[Constraint]: List of constraints defined for the domain\n    \"\"\"\n    if \"inputs\" not in values:\n        return v\n    keys = [f.key for f in values[\"inputs\"]]\n    for c in v:\n        if isinstance(c, LinearConstraint) or isinstance(c, NChooseKConstraint):\n            for f in c.features:\n                if f not in keys:\n                    raise ValueError(f\"feature {f} in constraint unknown ({keys})\")\n    return v\n</code></pre>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.validate_experiments","title":"<code>validate_experiments(self, experiments, strict=False)</code>","text":"<p>checks the experimental data on validity</p> <p>Parameters:</p> Name Type Description Default <code>experiments</code> <code>pd.DataFrame</code> <p>Dataframe with experimental data</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>empty dataframe</p> <code>ValueError</code> <p>the column for a specific feature is missing the provided data</p> <code>ValueError</code> <p>there are labcodes with null value</p> <code>ValueError</code> <p>there are labcodes with nan value</p> <code>ValueError</code> <p>labcodes are not unique</p> <code>ValueError</code> <p>the provided columns do no match to the defined domain</p> <code>ValueError</code> <p>the provided columns do no match to the defined domain</p> <code>ValueError</code> <p>Input with null values</p> <code>ValueError</code> <p>Input with nan values</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>The provided dataframe with experimental data</p> Source code in <code>bofire/data_models/domain/domain.py</code> <pre><code>def validate_experiments(\n    self,\n    experiments: pd.DataFrame,\n    strict: bool = False,\n) -&gt; pd.DataFrame:\n\"\"\"checks the experimental data on validity\n\n    Args:\n        experiments (pd.DataFrame): Dataframe with experimental data\n\n    Raises:\n        ValueError: empty dataframe\n        ValueError: the column for a specific feature is missing the provided data\n        ValueError: there are labcodes with null value\n        ValueError: there are labcodes with nan value\n        ValueError: labcodes are not unique\n        ValueError: the provided columns do no match to the defined domain\n        ValueError: the provided columns do no match to the defined domain\n        ValueError: Input with null values\n        ValueError: Input with nan values\n\n    Returns:\n        pd.DataFrame: The provided dataframe with experimental data\n    \"\"\"\n\n    if len(experiments) == 0:\n        raise ValueError(\"no experiments provided (empty dataframe)\")\n    # check that each feature is a col\n    feature_keys = self.get_feature_keys()\n    for feature_key in feature_keys:\n        if feature_key not in experiments:\n            raise ValueError(f\"no col in experiments for feature {feature_key}\")\n    # add valid_{key} cols if missing\n    valid_keys = [\n        f\"valid_{output_feature_key}\"\n        for output_feature_key in self.get_feature_keys(Output)\n    ]\n    for valid_key in valid_keys:\n        if valid_key not in experiments:\n            experiments[valid_key] = True\n    # check all cols\n    expected = feature_keys + valid_keys\n    cols = list(experiments.columns)\n    # we allow here for a column named labcode used to identify experiments\n    if \"labcode\" in cols:\n        # test that labcodes are not na\n        if experiments.labcode.isnull().to_numpy().any():\n            raise ValueError(\"there are labcodes with null value\")\n        if experiments.labcode.isna().to_numpy().any():\n            raise ValueError(\"there are labcodes with nan value\")\n        # test that labcodes are distinct\n        if (\n            len(set(experiments.labcode.to_numpy().tolist()))\n            != experiments.shape[0]\n        ):\n            raise ValueError(\"labcodes are not unique\")\n        # we remove the labcode from the cols list to proceed as before\n        cols.remove(\"labcode\")\n    if len(expected) != len(cols):\n        raise ValueError(f\"expected the following cols: `{expected}`, got `{cols}`\")\n    if len(set(expected + cols)) != len(cols):\n        raise ValueError(f\"expected the following cols: `{expected}`, got `{cols}`\")\n    # check values of continuous input features\n    if experiments[self.get_feature_keys(Input)].isnull().to_numpy().any():\n        raise ValueError(\"there are null values\")\n    if experiments[self.get_feature_keys(Input)].isna().to_numpy().any():\n        raise ValueError(\"there are na values\")\n    # run the individual validators\n    for feat in self.get_features(Input):\n        assert isinstance(feat, Input)\n        feat.validate_experimental(experiments[feat.key], strict=strict)\n    return experiments\n</code></pre>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.validate_linear_constraints","title":"<code>validate_linear_constraints(v, values)</code>  <code>classmethod</code>","text":"<p>Validate if all features included in linear constraints are continuous ones.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>List[Constraint]</code> <p>List of constraints or empty if no constraints are defined</p> required <code>values</code> <code>List[Input]</code> <p>List of input features of the domain</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>description</p> <p>Returns:</p> Type Description <code>List[Constraint]</code> <p>List of constraints defined for the domain</p> Source code in <code>bofire/data_models/domain/domain.py</code> <pre><code>@validator(\"constraints\", always=True)\ndef validate_linear_constraints(cls, v, values):\n\"\"\"Validate if all features included in linear constraints are continuous ones.\n\n    Args:\n        v (List[Constraint]): List of constraints or empty if no constraints are defined\n        values (List[Input]): List of input features of the domain\n\n    Raises:\n        ValueError: _description_\n\n\n    Returns:\n       List[Constraint]: List of constraints defined for the domain\n    \"\"\"\n    if \"inputs\" not in values:\n        return v\n\n    # gather continuous inputs in dictionary\n    continuous_inputs_dict = {}\n    for f in values[\"inputs\"]:\n        if type(f) is ContinuousInput:\n            continuous_inputs_dict[f.key] = f\n\n    # check if non continuous input features appear in linear constraints\n    for c in v:\n        if isinstance(c, LinearConstraint):\n            for f in c.features:\n                assert f in continuous_inputs_dict, f\"{f} must be continuous.\"\n    return v\n</code></pre>"},{"location":"ref-domain/#bofire.data_models.domain.domain.Domain.validate_unique_feature_keys","title":"<code>validate_unique_feature_keys(v, values)</code>  <code>classmethod</code>","text":"<p>Validates if provided input and output feature keys are unique</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Outputs</code> <p>List of all output features of the domain.</p> required <code>value</code> <code>Dict[str, Inputs]</code> <p>Dict containing a list of input features as single entry.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>Feature keys are not unique.</p> <p>Returns:</p> Type Description <code>Outputs</code> <p>Keeps output features as given.</p> Source code in <code>bofire/data_models/domain/domain.py</code> <pre><code>@validator(\"outputs\", always=True)\ndef validate_unique_feature_keys(cls, v: Outputs, values) -&gt; Outputs:\n\"\"\"Validates if provided input and output feature keys are unique\n\n    Args:\n        v (Outputs): List of all output features of the domain.\n        value (Dict[str, Inputs]): Dict containing a list of input features as single entry.\n\n    Raises:\n        ValueError: Feature keys are not unique.\n\n    Returns:\n        Outputs: Keeps output features as given.\n    \"\"\"\n    if \"inputs\" not in values:\n        return v\n    features = v + values[\"inputs\"]\n    keys = [f.key for f in features]\n    if len(set(keys)) != len(keys):\n        raise ValueError(\"feature keys are not unique\")\n    return v\n</code></pre>"},{"location":"ref-features/","title":"Domain","text":""},{"location":"ref-features/#bofire.data_models.features.categorical","title":"<code>categorical</code>","text":""},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput","title":"<code> CategoricalInput            (Input)         </code>  <code>pydantic-model</code>","text":"<p>Base class for all categorical input features.</p> <p>Attributes:</p> Name Type Description <code>categories</code> <code>List[str]</code> <p>Names of the categories.</p> <code>allowed</code> <code>List[bool]</code> <p>List of bools indicating if a category is allowed within the optimization.</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>class CategoricalInput(Input):\n\"\"\"Base class for all categorical input features.\n\n    Attributes:\n        categories (List[str]): Names of the categories.\n        allowed (List[bool]): List of bools indicating if a category is allowed within the optimization.\n    \"\"\"\n\n    type: Literal[\"CategoricalInput\"] = \"CategoricalInput\"\n    order_id: ClassVar[int] = 5\n\n    categories: TCategoryVals\n    allowed: TAllowedVals = None\n\n    @validator(\"categories\")\n    def validate_categories_unique(cls, categories):\n\"\"\"validates that categories have unique names\n\n        Args:\n            categories (List[str]): List of category names\n\n        Raises:\n            ValueError: when categories have non-unique names\n\n        Returns:\n            List[str]: List of the categories\n        \"\"\"\n        categories = list(categories)\n        if len(categories) != len(set(categories)):\n            raise ValueError(\"categories must be unique\")\n        return categories\n\n    @root_validator(pre=False, skip_on_failure=True)\n    def init_allowed(cls, values):\n\"\"\"validates the list of allowed/not allowed categories\n\n        Args:\n            values (Dict): Dictionary with attributes\n\n        Raises:\n            ValueError: when the number of allowences does not fit to the number of categories\n            ValueError: when no category is allowed\n\n        Returns:\n            Dict: Dictionary with attributes\n        \"\"\"\n        if \"categories\" not in values or values[\"categories\"] is None:\n            return values\n        if \"allowed\" not in values or values[\"allowed\"] is None:\n            values[\"allowed\"] = [True for _ in range(len(values[\"categories\"]))]\n        if len(values[\"allowed\"]) != len(values[\"categories\"]):\n            raise ValueError(\"allowed must have same length as categories\")\n        if sum(values[\"allowed\"]) == 0:\n            raise ValueError(\"no category is allowed\")\n        return values\n\n    def is_fixed(self) -&gt; bool:\n\"\"\"Returns True if there is only one allowed category.\n\n        Returns:\n            [bool]: True if there is only one allowed category\n        \"\"\"\n        if self.allowed is None:\n            return False\n        return sum(self.allowed) == 1\n\n    def fixed_value(\n        self, transform_type: Optional[TTransform] = None\n    ) -&gt; Union[List[str], List[float], None]:\n\"\"\"Returns the categories to which the feature is fixed, None if the feature is not fixed\n\n        Returns:\n            List[str]: List of categories or None\n        \"\"\"\n        if self.is_fixed():\n            val = self.get_allowed_categories()[0]\n            if transform_type is None:\n                return [val]\n            elif transform_type == CategoricalEncodingEnum.ONE_HOT:\n                return self.to_onehot_encoding(pd.Series([val])).values[0].tolist()\n            elif transform_type == CategoricalEncodingEnum.DUMMY:\n                return self.to_dummy_encoding(pd.Series([val])).values[0].tolist()\n            elif transform_type == CategoricalEncodingEnum.ORDINAL:\n                return self.to_ordinal_encoding(pd.Series([val])).tolist()\n            else:\n                raise ValueError(\n                    f\"Unkwon transform type {transform_type} for categorical input {self.key}\"\n                )\n        else:\n            return None\n\n    def get_allowed_categories(self):\n\"\"\"Returns the allowed categories.\n\n        Returns:\n            list of str: The allowed categories\n        \"\"\"\n        if self.allowed is None:\n            return []\n        return [c for c, a in zip(self.categories, self.allowed) if a]\n\n    def validate_experimental(\n        self, values: pd.Series, strict: bool = False\n    ) -&gt; pd.Series:\n\"\"\"Method to validate the experimental dataFrame\n\n        Args:\n            values (pd.Series): A dataFrame with experiments\n            strict (bool, optional): Boolean to distinguish if the occurence of fixed features in the dataset should be considered or not. Defaults to False.\n\n        Raises:\n            ValueError: when an entry is not in the list of allowed categories\n            ValueError: when there is no variation in a feature provided by the experimental data\n\n        Returns:\n            pd.Series: A dataFrame with experiments\n        \"\"\"\n        if sum(values.isin(self.categories)) != len(values):\n            raise ValueError(\n                f\"invalid values for `{self.key}`, allowed are: `{self.categories}`\"\n            )\n        if strict:\n            possible_categories = self.get_possible_categories(values)\n            if len(possible_categories) != len(self.categories):\n                raise ValueError(\n                    f\"Categories {list(set(self.categories)-set(possible_categories))} of feature {self.key} not used. Remove them.\"\n                )\n        return values\n\n    def validate_candidental(self, values: pd.Series) -&gt; pd.Series:\n\"\"\"Method to validate the suggested candidates\n\n        Args:\n            values (pd.Series): A dataFrame with candidates\n\n        Raises:\n            ValueError: when not all values for a feature are one of the allowed categories\n\n        Returns:\n            pd.Series: The passed dataFrame with candidates\n        \"\"\"\n        if sum(values.isin(self.get_allowed_categories())) != len(values):\n            raise ValueError(\n                f\"not all values of input feature `{self.key}` are a valid allowed category from {self.get_allowed_categories()}\"\n            )\n        return values\n\n    def get_forbidden_categories(self):\n\"\"\"Returns the non-allowed categories\n\n        Returns:\n            List[str]: List of the non-allowed categories\n        \"\"\"\n        return list(set(self.categories) - set(self.get_allowed_categories()))\n\n    def get_possible_categories(self, values: pd.Series) -&gt; list:\n\"\"\"Return the superset of categories that have been used in the experimental dataset and\n        that can be used in the optimization\n\n        Args:\n            values (pd.Series): Series with the values for this feature\n\n        Returns:\n            list: list of possible categories\n        \"\"\"\n        return sorted(set(list(set(values.tolist())) + self.get_allowed_categories()))\n\n    def to_onehot_encoding(self, values: pd.Series) -&gt; pd.DataFrame:\n\"\"\"Converts values to a one-hot encoding.\n\n        Args:\n            values (pd.Series): Series to be transformed.\n\n        Returns:\n            pd.DataFrame: One-hot transformed data frame.\n        \"\"\"\n        return pd.DataFrame(\n            {f\"{self.key}{_CAT_SEP}{c}\": values == c for c in self.categories},\n            dtype=float,\n            index=values.index,\n        )\n\n    def from_onehot_encoding(self, values: pd.DataFrame) -&gt; pd.Series:\n\"\"\"Converts values back from one-hot encoding.\n\n        Args:\n            values (pd.DataFrame): One-hot encoded values.\n\n        Raises:\n            ValueError: If one-hot columns not present in `values`.\n\n        Returns:\n            pd.Series: Series with categorical values.\n        \"\"\"\n        cat_cols = [f\"{self.key}{_CAT_SEP}{c}\" for c in self.categories]\n        # we allow here explicitly that the dataframe can have more columns than needed to have it\n        # easier in the backtransform.\n        if np.any([c not in values.columns for c in cat_cols]):\n            raise ValueError(\n                f\"{self.key}: Column names don't match categorical levels: {values.columns}, {cat_cols}.\"\n            )\n        s = values[cat_cols].idxmax(1).str.split(_CAT_SEP, expand=True).iloc[:, -1]\n        s.name = self.key\n        return s\n\n    def to_dummy_encoding(self, values: pd.Series) -&gt; pd.DataFrame:\n\"\"\"Converts values to a dummy-hot encoding, dropping the first categorical level.\n\n        Args:\n            values (pd.Series): Series to be transformed.\n\n        Returns:\n            pd.DataFrame: Dummy-hot transformed data frame.\n        \"\"\"\n        return pd.DataFrame(\n            {f\"{self.key}{_CAT_SEP}{c}\": values == c for c in self.categories[1:]},\n            dtype=float,\n            index=values.index,\n        )\n\n    def from_dummy_encoding(self, values: pd.DataFrame) -&gt; pd.Series:\n\"\"\"Convert points back from dummy encoding.\n\n        Args:\n            values (pd.DataFrame): Dummy-hot encoded values.\n\n        Raises:\n            ValueError: If one-hot columns not present in `values`.\n\n        Returns:\n            pd.Series: Series with categorical values.\n        \"\"\"\n        cat_cols = [f\"{self.key}{_CAT_SEP}{c}\" for c in self.categories]\n        # we allow here explicitly that the dataframe can have more columns than needed to have it\n        # easier in the backtransform.\n        if np.any([c not in values.columns for c in cat_cols[1:]]):\n            raise ValueError(\n                f\"{self.key}: Column names don't match categorical levels: {values.columns}, {cat_cols[1:]}.\"\n            )\n        values = values.copy()\n        values[cat_cols[0]] = 1 - values[cat_cols[1:]].sum(axis=1)\n        s = values[cat_cols].idxmax(1).str.split(_CAT_SEP, expand=True).iloc[:, -1]\n        s.name = self.key\n        return s\n\n    def to_ordinal_encoding(self, values: pd.Series) -&gt; pd.Series:\n\"\"\"Converts values to an ordinal integer based encoding.\n\n        Args:\n            values (pd.Series): Series to be transformed.\n\n        Returns:\n            pd.Series: Ordinal encoded values.\n        \"\"\"\n        enc = pd.Series(range(len(self.categories)), index=list(self.categories))\n        s = enc[values]\n        s.index = values.index\n        s.name = self.key\n        return s\n\n    def from_ordinal_encoding(self, values: pd.Series) -&gt; pd.Series:\n\"\"\"Convertes values back from ordinal encoding.\n\n        Args:\n            values (pd.Series): Ordinal encoded series.\n\n        Returns:\n            pd.Series: Series with categorical values.\n        \"\"\"\n        enc = np.array(self.categories)\n        return pd.Series(enc[values], index=values.index, name=self.key)\n\n    def sample(self, n: int) -&gt; pd.Series:\n\"\"\"Draw random samples from the feature.\n\n        Args:\n            n (int): number of samples.\n\n        Returns:\n            pd.Series: drawn samples.\n        \"\"\"\n        return pd.Series(\n            name=self.key, data=np.random.choice(self.get_allowed_categories(), n)\n        )\n\n    def get_bounds(\n        self,\n        transform_type: TTransform,\n        values: Optional[pd.Series] = None,\n    ) -&gt; Tuple[List[float], List[float]]:\n        assert isinstance(transform_type, CategoricalEncodingEnum)\n        if transform_type == CategoricalEncodingEnum.ORDINAL:\n            return [0], [len(self.categories) - 1]\n        if transform_type == CategoricalEncodingEnum.ONE_HOT:\n            # in the case that values are None, we return the bounds\n            # based on the optimization bounds, else we return the true\n            # bounds as this is for model fitting.\n            if values is None:\n                lower = [0.0 for _ in self.categories]\n                upper = [\n                    1.0 if self.allowed[i] is True else 0.0  # type: ignore\n                    for i, _ in enumerate(self.categories)\n                ]\n            else:\n                lower = [0.0 for _ in self.categories]\n                upper = [1.0 for _ in self.categories]\n            return lower, upper\n        if transform_type == CategoricalEncodingEnum.DUMMY:\n            lower = [0.0 for _ in range(len(self.categories) - 1)]\n            upper = [1.0 for _ in range(len(self.categories) - 1)]\n            return lower, upper\n        if transform_type == CategoricalEncodingEnum.DESCRIPTOR:\n            raise ValueError(\n                f\"Invalid descriptor transform for categorical {self.key}.\"\n            )\n        else:\n            raise ValueError(\n                f\"Invalid transform_type {transform_type} provided for categorical {self.key}.\"\n            )\n\n    def __str__(self) -&gt; str:\n\"\"\"Returns the number of categories as str\n\n        Returns:\n            str: Number of categories\n        \"\"\"\n        return f\"{len(self.categories)} categories\"\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.__str__","title":"<code>__str__(self)</code>  <code>special</code>","text":"<p>Returns the number of categories as str</p> <p>Returns:</p> Type Description <code>str</code> <p>Number of categories</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the number of categories as str\n\n    Returns:\n        str: Number of categories\n    \"\"\"\n    return f\"{len(self.categories)} categories\"\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.fixed_value","title":"<code>fixed_value(self, transform_type=None)</code>","text":"<p>Returns the categories to which the feature is fixed, None if the feature is not fixed</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of categories or None</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def fixed_value(\n    self, transform_type: Optional[TTransform] = None\n) -&gt; Union[List[str], List[float], None]:\n\"\"\"Returns the categories to which the feature is fixed, None if the feature is not fixed\n\n    Returns:\n        List[str]: List of categories or None\n    \"\"\"\n    if self.is_fixed():\n        val = self.get_allowed_categories()[0]\n        if transform_type is None:\n            return [val]\n        elif transform_type == CategoricalEncodingEnum.ONE_HOT:\n            return self.to_onehot_encoding(pd.Series([val])).values[0].tolist()\n        elif transform_type == CategoricalEncodingEnum.DUMMY:\n            return self.to_dummy_encoding(pd.Series([val])).values[0].tolist()\n        elif transform_type == CategoricalEncodingEnum.ORDINAL:\n            return self.to_ordinal_encoding(pd.Series([val])).tolist()\n        else:\n            raise ValueError(\n                f\"Unkwon transform type {transform_type} for categorical input {self.key}\"\n            )\n    else:\n        return None\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.from_dummy_encoding","title":"<code>from_dummy_encoding(self, values)</code>","text":"<p>Convert points back from dummy encoding.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.DataFrame</code> <p>Dummy-hot encoded values.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If one-hot columns not present in <code>values</code>.</p> <p>Returns:</p> Type Description <code>pd.Series</code> <p>Series with categorical values.</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def from_dummy_encoding(self, values: pd.DataFrame) -&gt; pd.Series:\n\"\"\"Convert points back from dummy encoding.\n\n    Args:\n        values (pd.DataFrame): Dummy-hot encoded values.\n\n    Raises:\n        ValueError: If one-hot columns not present in `values`.\n\n    Returns:\n        pd.Series: Series with categorical values.\n    \"\"\"\n    cat_cols = [f\"{self.key}{_CAT_SEP}{c}\" for c in self.categories]\n    # we allow here explicitly that the dataframe can have more columns than needed to have it\n    # easier in the backtransform.\n    if np.any([c not in values.columns for c in cat_cols[1:]]):\n        raise ValueError(\n            f\"{self.key}: Column names don't match categorical levels: {values.columns}, {cat_cols[1:]}.\"\n        )\n    values = values.copy()\n    values[cat_cols[0]] = 1 - values[cat_cols[1:]].sum(axis=1)\n    s = values[cat_cols].idxmax(1).str.split(_CAT_SEP, expand=True).iloc[:, -1]\n    s.name = self.key\n    return s\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.from_onehot_encoding","title":"<code>from_onehot_encoding(self, values)</code>","text":"<p>Converts values back from one-hot encoding.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.DataFrame</code> <p>One-hot encoded values.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If one-hot columns not present in <code>values</code>.</p> <p>Returns:</p> Type Description <code>pd.Series</code> <p>Series with categorical values.</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def from_onehot_encoding(self, values: pd.DataFrame) -&gt; pd.Series:\n\"\"\"Converts values back from one-hot encoding.\n\n    Args:\n        values (pd.DataFrame): One-hot encoded values.\n\n    Raises:\n        ValueError: If one-hot columns not present in `values`.\n\n    Returns:\n        pd.Series: Series with categorical values.\n    \"\"\"\n    cat_cols = [f\"{self.key}{_CAT_SEP}{c}\" for c in self.categories]\n    # we allow here explicitly that the dataframe can have more columns than needed to have it\n    # easier in the backtransform.\n    if np.any([c not in values.columns for c in cat_cols]):\n        raise ValueError(\n            f\"{self.key}: Column names don't match categorical levels: {values.columns}, {cat_cols}.\"\n        )\n    s = values[cat_cols].idxmax(1).str.split(_CAT_SEP, expand=True).iloc[:, -1]\n    s.name = self.key\n    return s\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.from_ordinal_encoding","title":"<code>from_ordinal_encoding(self, values)</code>","text":"<p>Convertes values back from ordinal encoding.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>Ordinal encoded series.</p> required <p>Returns:</p> Type Description <code>pd.Series</code> <p>Series with categorical values.</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def from_ordinal_encoding(self, values: pd.Series) -&gt; pd.Series:\n\"\"\"Convertes values back from ordinal encoding.\n\n    Args:\n        values (pd.Series): Ordinal encoded series.\n\n    Returns:\n        pd.Series: Series with categorical values.\n    \"\"\"\n    enc = np.array(self.categories)\n    return pd.Series(enc[values], index=values.index, name=self.key)\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.get_allowed_categories","title":"<code>get_allowed_categories(self)</code>","text":"<p>Returns the allowed categories.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>The allowed categories</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def get_allowed_categories(self):\n\"\"\"Returns the allowed categories.\n\n    Returns:\n        list of str: The allowed categories\n    \"\"\"\n    if self.allowed is None:\n        return []\n    return [c for c, a in zip(self.categories, self.allowed) if a]\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.get_bounds","title":"<code>get_bounds(self, transform_type, values=None)</code>","text":"<p>Returns the bounds of an input feature depending on the requested transform type.</p> <p>Parameters:</p> Name Type Description Default <code>transform_type</code> <code>Optional[TTransform]</code> <p>The requested transform type. Defaults to None.</p> required <code>values</code> <code>Optional[pd.Series]</code> <p>If values are provided the bounds are returned taking the most extreme values for the feature into account. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[List[float], List[float]]</code> <p>List of lower bound values, list of upper bound values.</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def get_bounds(\n    self,\n    transform_type: TTransform,\n    values: Optional[pd.Series] = None,\n) -&gt; Tuple[List[float], List[float]]:\n    assert isinstance(transform_type, CategoricalEncodingEnum)\n    if transform_type == CategoricalEncodingEnum.ORDINAL:\n        return [0], [len(self.categories) - 1]\n    if transform_type == CategoricalEncodingEnum.ONE_HOT:\n        # in the case that values are None, we return the bounds\n        # based on the optimization bounds, else we return the true\n        # bounds as this is for model fitting.\n        if values is None:\n            lower = [0.0 for _ in self.categories]\n            upper = [\n                1.0 if self.allowed[i] is True else 0.0  # type: ignore\n                for i, _ in enumerate(self.categories)\n            ]\n        else:\n            lower = [0.0 for _ in self.categories]\n            upper = [1.0 for _ in self.categories]\n        return lower, upper\n    if transform_type == CategoricalEncodingEnum.DUMMY:\n        lower = [0.0 for _ in range(len(self.categories) - 1)]\n        upper = [1.0 for _ in range(len(self.categories) - 1)]\n        return lower, upper\n    if transform_type == CategoricalEncodingEnum.DESCRIPTOR:\n        raise ValueError(\n            f\"Invalid descriptor transform for categorical {self.key}.\"\n        )\n    else:\n        raise ValueError(\n            f\"Invalid transform_type {transform_type} provided for categorical {self.key}.\"\n        )\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.get_forbidden_categories","title":"<code>get_forbidden_categories(self)</code>","text":"<p>Returns the non-allowed categories</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of the non-allowed categories</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def get_forbidden_categories(self):\n\"\"\"Returns the non-allowed categories\n\n    Returns:\n        List[str]: List of the non-allowed categories\n    \"\"\"\n    return list(set(self.categories) - set(self.get_allowed_categories()))\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.get_possible_categories","title":"<code>get_possible_categories(self, values)</code>","text":"<p>Return the superset of categories that have been used in the experimental dataset and that can be used in the optimization</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>Series with the values for this feature</p> required <p>Returns:</p> Type Description <code>list</code> <p>list of possible categories</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def get_possible_categories(self, values: pd.Series) -&gt; list:\n\"\"\"Return the superset of categories that have been used in the experimental dataset and\n    that can be used in the optimization\n\n    Args:\n        values (pd.Series): Series with the values for this feature\n\n    Returns:\n        list: list of possible categories\n    \"\"\"\n    return sorted(set(list(set(values.tolist())) + self.get_allowed_categories()))\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.init_allowed","title":"<code>init_allowed(values)</code>  <code>classmethod</code>","text":"<p>validates the list of allowed/not allowed categories</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Dict</code> <p>Dictionary with attributes</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>when the number of allowences does not fit to the number of categories</p> <code>ValueError</code> <p>when no category is allowed</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary with attributes</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>@root_validator(pre=False, skip_on_failure=True)\ndef init_allowed(cls, values):\n\"\"\"validates the list of allowed/not allowed categories\n\n    Args:\n        values (Dict): Dictionary with attributes\n\n    Raises:\n        ValueError: when the number of allowences does not fit to the number of categories\n        ValueError: when no category is allowed\n\n    Returns:\n        Dict: Dictionary with attributes\n    \"\"\"\n    if \"categories\" not in values or values[\"categories\"] is None:\n        return values\n    if \"allowed\" not in values or values[\"allowed\"] is None:\n        values[\"allowed\"] = [True for _ in range(len(values[\"categories\"]))]\n    if len(values[\"allowed\"]) != len(values[\"categories\"]):\n        raise ValueError(\"allowed must have same length as categories\")\n    if sum(values[\"allowed\"]) == 0:\n        raise ValueError(\"no category is allowed\")\n    return values\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.is_fixed","title":"<code>is_fixed(self)</code>","text":"<p>Returns True if there is only one allowed category.</p> <p>Returns:</p> Type Description <code>[bool]</code> <p>True if there is only one allowed category</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def is_fixed(self) -&gt; bool:\n\"\"\"Returns True if there is only one allowed category.\n\n    Returns:\n        [bool]: True if there is only one allowed category\n    \"\"\"\n    if self.allowed is None:\n        return False\n    return sum(self.allowed) == 1\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.sample","title":"<code>sample(self, n)</code>","text":"<p>Draw random samples from the feature.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>number of samples.</p> required <p>Returns:</p> Type Description <code>pd.Series</code> <p>drawn samples.</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def sample(self, n: int) -&gt; pd.Series:\n\"\"\"Draw random samples from the feature.\n\n    Args:\n        n (int): number of samples.\n\n    Returns:\n        pd.Series: drawn samples.\n    \"\"\"\n    return pd.Series(\n        name=self.key, data=np.random.choice(self.get_allowed_categories(), n)\n    )\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.to_dummy_encoding","title":"<code>to_dummy_encoding(self, values)</code>","text":"<p>Converts values to a dummy-hot encoding, dropping the first categorical level.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>Series to be transformed.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Dummy-hot transformed data frame.</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def to_dummy_encoding(self, values: pd.Series) -&gt; pd.DataFrame:\n\"\"\"Converts values to a dummy-hot encoding, dropping the first categorical level.\n\n    Args:\n        values (pd.Series): Series to be transformed.\n\n    Returns:\n        pd.DataFrame: Dummy-hot transformed data frame.\n    \"\"\"\n    return pd.DataFrame(\n        {f\"{self.key}{_CAT_SEP}{c}\": values == c for c in self.categories[1:]},\n        dtype=float,\n        index=values.index,\n    )\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.to_onehot_encoding","title":"<code>to_onehot_encoding(self, values)</code>","text":"<p>Converts values to a one-hot encoding.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>Series to be transformed.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>One-hot transformed data frame.</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def to_onehot_encoding(self, values: pd.Series) -&gt; pd.DataFrame:\n\"\"\"Converts values to a one-hot encoding.\n\n    Args:\n        values (pd.Series): Series to be transformed.\n\n    Returns:\n        pd.DataFrame: One-hot transformed data frame.\n    \"\"\"\n    return pd.DataFrame(\n        {f\"{self.key}{_CAT_SEP}{c}\": values == c for c in self.categories},\n        dtype=float,\n        index=values.index,\n    )\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.to_ordinal_encoding","title":"<code>to_ordinal_encoding(self, values)</code>","text":"<p>Converts values to an ordinal integer based encoding.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>Series to be transformed.</p> required <p>Returns:</p> Type Description <code>pd.Series</code> <p>Ordinal encoded values.</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def to_ordinal_encoding(self, values: pd.Series) -&gt; pd.Series:\n\"\"\"Converts values to an ordinal integer based encoding.\n\n    Args:\n        values (pd.Series): Series to be transformed.\n\n    Returns:\n        pd.Series: Ordinal encoded values.\n    \"\"\"\n    enc = pd.Series(range(len(self.categories)), index=list(self.categories))\n    s = enc[values]\n    s.index = values.index\n    s.name = self.key\n    return s\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.validate_candidental","title":"<code>validate_candidental(self, values)</code>","text":"<p>Method to validate the suggested candidates</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>A dataFrame with candidates</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>when not all values for a feature are one of the allowed categories</p> <p>Returns:</p> Type Description <code>pd.Series</code> <p>The passed dataFrame with candidates</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def validate_candidental(self, values: pd.Series) -&gt; pd.Series:\n\"\"\"Method to validate the suggested candidates\n\n    Args:\n        values (pd.Series): A dataFrame with candidates\n\n    Raises:\n        ValueError: when not all values for a feature are one of the allowed categories\n\n    Returns:\n        pd.Series: The passed dataFrame with candidates\n    \"\"\"\n    if sum(values.isin(self.get_allowed_categories())) != len(values):\n        raise ValueError(\n            f\"not all values of input feature `{self.key}` are a valid allowed category from {self.get_allowed_categories()}\"\n        )\n    return values\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.validate_categories_unique","title":"<code>validate_categories_unique(categories)</code>  <code>classmethod</code>","text":"<p>validates that categories have unique names</p> <p>Parameters:</p> Name Type Description Default <code>categories</code> <code>List[str]</code> <p>List of category names</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>when categories have non-unique names</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of the categories</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>@validator(\"categories\")\ndef validate_categories_unique(cls, categories):\n\"\"\"validates that categories have unique names\n\n    Args:\n        categories (List[str]): List of category names\n\n    Raises:\n        ValueError: when categories have non-unique names\n\n    Returns:\n        List[str]: List of the categories\n    \"\"\"\n    categories = list(categories)\n    if len(categories) != len(set(categories)):\n        raise ValueError(\"categories must be unique\")\n    return categories\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalInput.validate_experimental","title":"<code>validate_experimental(self, values, strict=False)</code>","text":"<p>Method to validate the experimental dataFrame</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>A dataFrame with experiments</p> required <code>strict</code> <code>bool</code> <p>Boolean to distinguish if the occurence of fixed features in the dataset should be considered or not. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>when an entry is not in the list of allowed categories</p> <code>ValueError</code> <p>when there is no variation in a feature provided by the experimental data</p> <p>Returns:</p> Type Description <code>pd.Series</code> <p>A dataFrame with experiments</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def validate_experimental(\n    self, values: pd.Series, strict: bool = False\n) -&gt; pd.Series:\n\"\"\"Method to validate the experimental dataFrame\n\n    Args:\n        values (pd.Series): A dataFrame with experiments\n        strict (bool, optional): Boolean to distinguish if the occurence of fixed features in the dataset should be considered or not. Defaults to False.\n\n    Raises:\n        ValueError: when an entry is not in the list of allowed categories\n        ValueError: when there is no variation in a feature provided by the experimental data\n\n    Returns:\n        pd.Series: A dataFrame with experiments\n    \"\"\"\n    if sum(values.isin(self.categories)) != len(values):\n        raise ValueError(\n            f\"invalid values for `{self.key}`, allowed are: `{self.categories}`\"\n        )\n    if strict:\n        possible_categories = self.get_possible_categories(values)\n        if len(possible_categories) != len(self.categories):\n            raise ValueError(\n                f\"Categories {list(set(self.categories)-set(possible_categories))} of feature {self.key} not used. Remove them.\"\n            )\n    return values\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalOutput","title":"<code> CategoricalOutput            (Output)         </code>  <code>pydantic-model</code>","text":"Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>class CategoricalOutput(Output):\n    type: Literal[\"CategoricalOutput\"] = \"CategoricalOutput\"\n    order_id: ClassVar[int] = 8\n\n    categories: TCategoryVals\n    objective: Annotated[\n        List[Annotated[float, Field(type=float, ge=0, le=1)]], Field(min_items=2)\n    ]\n\n    @validator(\"categories\")\n    def validate_categories_unique(cls, categories):\n\"\"\"validates that categories have unique names\n\n        Args:\n            categories (List[str]): List of category names\n\n        Raises:\n            ValueError: when categories have non-unique names\n\n        Returns:\n            List[str]: List of the categories\n        \"\"\"\n        categories = list(categories)\n        if len(categories) != len(set(categories)):\n            raise ValueError(\"categories must be unique\")\n        return categories\n\n    @validator(\"objective\")\n    def validate_objective(cls, objective, values):\n        if len(objective) != len(values[\"categories\"]):\n            raise ValueError(\"Length of objectives and categories do not match.\")\n        for o in objective:\n            if o &gt; 1:\n                raise ValueError(\"Objective values has to be smaller equal than 1.\")\n            if o &lt; 0:\n                raise ValueError(\"Objective values has to be larger equal than zero\")\n        return objective\n\n    def to_dict(self) -&gt; Dict:\n\"\"\"Returns the catergories and corresponding objective values as dictionary\"\"\"\n        return dict(zip(self.categories, self.objective))\n\n    def __call__(self, values: pd.Series) -&gt; pd.Series:\n        return values.map(self.to_dict()).astype(float)\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalOutput.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalOutput.to_dict","title":"<code>to_dict(self)</code>","text":"<p>Returns the catergories and corresponding objective values as dictionary</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n\"\"\"Returns the catergories and corresponding objective values as dictionary\"\"\"\n    return dict(zip(self.categories, self.objective))\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.categorical.CategoricalOutput.validate_categories_unique","title":"<code>validate_categories_unique(categories)</code>  <code>classmethod</code>","text":"<p>validates that categories have unique names</p> <p>Parameters:</p> Name Type Description Default <code>categories</code> <code>List[str]</code> <p>List of category names</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>when categories have non-unique names</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of the categories</p> Source code in <code>bofire/data_models/features/categorical.py</code> <pre><code>@validator(\"categories\")\ndef validate_categories_unique(cls, categories):\n\"\"\"validates that categories have unique names\n\n    Args:\n        categories (List[str]): List of category names\n\n    Raises:\n        ValueError: when categories have non-unique names\n\n    Returns:\n        List[str]: List of the categories\n    \"\"\"\n    categories = list(categories)\n    if len(categories) != len(set(categories)):\n        raise ValueError(\"categories must be unique\")\n    return categories\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.continuous","title":"<code>continuous</code>","text":""},{"location":"ref-features/#bofire.data_models.features.continuous.ContinuousInput","title":"<code> ContinuousInput            (NumericalInput)         </code>  <code>pydantic-model</code>","text":"<p>Base class for all continuous input features.</p> <p>Attributes:</p> Name Type Description <code>bounds</code> <code>Tuple[float, float]</code> <p>A tuple that stores the lower and upper bound of the feature.</p> <code>stepsize</code> <code>float</code> <p>Float indicating the allowed stepsize between lower and upper. Defaults to None.</p> Source code in <code>bofire/data_models/features/continuous.py</code> <pre><code>class ContinuousInput(NumericalInput):\n\"\"\"Base class for all continuous input features.\n\n    Attributes:\n        bounds (Tuple[float, float]): A tuple that stores the lower and upper bound of the feature.\n        stepsize (float, optional): Float indicating the allowed stepsize between lower and upper. Defaults to None.\n    \"\"\"\n\n    type: Literal[\"ContinuousInput\"] = \"ContinuousInput\"\n    order_id: ClassVar[int] = 1\n\n    bounds: Tuple[float, float]\n    stepsize: Optional[float] = None\n\n    @property\n    def lower_bound(self) -&gt; float:\n        return self.bounds[0]\n\n    @property\n    def upper_bound(self) -&gt; float:\n        return self.bounds[1]\n\n    @validator(\"stepsize\")\n    def validate_step_size(cls, v, values):\n        if v is None:\n            return v\n        lower, upper = values[\"bounds\"]\n        if lower == upper and v is not None:\n            raise ValueError(\n                \"Stepsize cannot be provided for a fixed continuous input.\"\n            )\n        range = upper - lower\n        if np.arange(lower, upper + v, v)[-1] != upper:\n            raise ValueError(\n                f\"Stepsize of {v} does not match the provided interval [{lower},{upper}].\"\n            )\n        if range // v == 1:\n            raise ValueError(\"Stepsize is too big, only one value allowed.\")\n        return v\n\n    def round(self, values: pd.Series) -&gt; pd.Series:\n\"\"\"Round values to the stepsize of the feature. If no stepsize is provided return the\n        provided values.\n\n        Args:\n            values (pd.Series): The values that should be rounded.\n\n        Returns:\n            pd.Series: The rounded values\n        \"\"\"\n        if self.stepsize is None:\n            return values\n        self.validate_candidental(values=values)\n        allowed_values = np.arange(\n            self.lower_bound, self.upper_bound + self.stepsize, self.stepsize\n        )\n        idx = abs(values.values.reshape([3, 1]) - allowed_values).argmin(axis=1)  # type: ignore\n        return pd.Series(\n            data=self.lower_bound + idx * self.stepsize, index=values.index\n        )\n\n    @root_validator(pre=False, skip_on_failure=True)\n    def validate_lower_upper(cls, values):\n\"\"\"Validates that the lower bound is lower than the upper bound\n\n        Args:\n            values (Dict): Dictionary with attributes key, lower and upper bound\n\n        Raises:\n            ValueError: when the lower bound is higher than the upper bound\n\n        Returns:\n            Dict: The attributes as dictionary\n        \"\"\"\n        if values[\"bounds\"][0] &gt; values[\"bounds\"][1]:\n            raise ValueError(\n                f'lower bound must be &lt;= upper bound, got {values[\"lower_bound\"]} &gt; {values[\"upper_bound\"]}'\n            )\n        return values\n\n    def validate_candidental(self, values: pd.Series) -&gt; pd.Series:\n\"\"\"Method to validate the suggested candidates\n\n        Args:\n            values (pd.Series): A dataFrame with candidates\n\n        Raises:\n            ValueError: when non numerical values are passed\n            ValueError: when values are larger than the upper bound of the feature\n            ValueError: when values are lower than the lower bound of the feature\n\n        Returns:\n            pd.Series: The passed dataFrame with candidates\n        \"\"\"\n\n        noise = 10e-6\n        super().validate_candidental(values)\n        if (values &lt; self.lower_bound - noise).any():\n            raise ValueError(\n                f\"not all values of input feature `{self.key}`are larger than lower bound `{self.lower_bound}` \"\n            )\n        if (values &gt; self.upper_bound + noise).any():\n            raise ValueError(\n                f\"not all values of input feature `{self.key}`are smaller than upper bound `{self.upper_bound}` \"\n            )\n        return values\n\n    def sample(self, n: int) -&gt; pd.Series:\n\"\"\"Draw random samples from the feature.\n\n        Args:\n            n (int): number of samples.\n\n        Returns:\n            pd.Series: drawn samples.\n        \"\"\"\n        return pd.Series(\n            name=self.key,\n            data=np.random.uniform(self.lower_bound, self.upper_bound, n),\n        )\n\n    def __str__(self) -&gt; str:\n\"\"\"Method to return a string of lower and upper bound\n\n        Returns:\n            str: String of a list with lower and upper bound\n        \"\"\"\n        return f\"[{self.lower_bound},{self.upper_bound}]\"\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.continuous.ContinuousInput.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-features/#bofire.data_models.features.continuous.ContinuousInput.__str__","title":"<code>__str__(self)</code>  <code>special</code>","text":"<p>Method to return a string of lower and upper bound</p> <p>Returns:</p> Type Description <code>str</code> <p>String of a list with lower and upper bound</p> Source code in <code>bofire/data_models/features/continuous.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Method to return a string of lower and upper bound\n\n    Returns:\n        str: String of a list with lower and upper bound\n    \"\"\"\n    return f\"[{self.lower_bound},{self.upper_bound}]\"\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.continuous.ContinuousInput.round","title":"<code>round(self, values)</code>","text":"<p>Round values to the stepsize of the feature. If no stepsize is provided return the provided values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>The values that should be rounded.</p> required <p>Returns:</p> Type Description <code>pd.Series</code> <p>The rounded values</p> Source code in <code>bofire/data_models/features/continuous.py</code> <pre><code>def round(self, values: pd.Series) -&gt; pd.Series:\n\"\"\"Round values to the stepsize of the feature. If no stepsize is provided return the\n    provided values.\n\n    Args:\n        values (pd.Series): The values that should be rounded.\n\n    Returns:\n        pd.Series: The rounded values\n    \"\"\"\n    if self.stepsize is None:\n        return values\n    self.validate_candidental(values=values)\n    allowed_values = np.arange(\n        self.lower_bound, self.upper_bound + self.stepsize, self.stepsize\n    )\n    idx = abs(values.values.reshape([3, 1]) - allowed_values).argmin(axis=1)  # type: ignore\n    return pd.Series(\n        data=self.lower_bound + idx * self.stepsize, index=values.index\n    )\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.continuous.ContinuousInput.sample","title":"<code>sample(self, n)</code>","text":"<p>Draw random samples from the feature.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>number of samples.</p> required <p>Returns:</p> Type Description <code>pd.Series</code> <p>drawn samples.</p> Source code in <code>bofire/data_models/features/continuous.py</code> <pre><code>def sample(self, n: int) -&gt; pd.Series:\n\"\"\"Draw random samples from the feature.\n\n    Args:\n        n (int): number of samples.\n\n    Returns:\n        pd.Series: drawn samples.\n    \"\"\"\n    return pd.Series(\n        name=self.key,\n        data=np.random.uniform(self.lower_bound, self.upper_bound, n),\n    )\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.continuous.ContinuousInput.validate_candidental","title":"<code>validate_candidental(self, values)</code>","text":"<p>Method to validate the suggested candidates</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>A dataFrame with candidates</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>when non numerical values are passed</p> <code>ValueError</code> <p>when values are larger than the upper bound of the feature</p> <code>ValueError</code> <p>when values are lower than the lower bound of the feature</p> <p>Returns:</p> Type Description <code>pd.Series</code> <p>The passed dataFrame with candidates</p> Source code in <code>bofire/data_models/features/continuous.py</code> <pre><code>def validate_candidental(self, values: pd.Series) -&gt; pd.Series:\n\"\"\"Method to validate the suggested candidates\n\n    Args:\n        values (pd.Series): A dataFrame with candidates\n\n    Raises:\n        ValueError: when non numerical values are passed\n        ValueError: when values are larger than the upper bound of the feature\n        ValueError: when values are lower than the lower bound of the feature\n\n    Returns:\n        pd.Series: The passed dataFrame with candidates\n    \"\"\"\n\n    noise = 10e-6\n    super().validate_candidental(values)\n    if (values &lt; self.lower_bound - noise).any():\n        raise ValueError(\n            f\"not all values of input feature `{self.key}`are larger than lower bound `{self.lower_bound}` \"\n        )\n    if (values &gt; self.upper_bound + noise).any():\n        raise ValueError(\n            f\"not all values of input feature `{self.key}`are smaller than upper bound `{self.upper_bound}` \"\n        )\n    return values\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.continuous.ContinuousInput.validate_lower_upper","title":"<code>validate_lower_upper(values)</code>  <code>classmethod</code>","text":"<p>Validates that the lower bound is lower than the upper bound</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Dict</code> <p>Dictionary with attributes key, lower and upper bound</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>when the lower bound is higher than the upper bound</p> <p>Returns:</p> Type Description <code>Dict</code> <p>The attributes as dictionary</p> Source code in <code>bofire/data_models/features/continuous.py</code> <pre><code>@root_validator(pre=False, skip_on_failure=True)\ndef validate_lower_upper(cls, values):\n\"\"\"Validates that the lower bound is lower than the upper bound\n\n    Args:\n        values (Dict): Dictionary with attributes key, lower and upper bound\n\n    Raises:\n        ValueError: when the lower bound is higher than the upper bound\n\n    Returns:\n        Dict: The attributes as dictionary\n    \"\"\"\n    if values[\"bounds\"][0] &gt; values[\"bounds\"][1]:\n        raise ValueError(\n            f'lower bound must be &lt;= upper bound, got {values[\"lower_bound\"]} &gt; {values[\"upper_bound\"]}'\n        )\n    return values\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.continuous.ContinuousOutput","title":"<code> ContinuousOutput            (Output)         </code>  <code>pydantic-model</code>","text":"<p>The base class for a continuous output feature</p> <p>Attributes:</p> Name Type Description <code>objective</code> <code>objective</code> <p>objective of the feature indicating in which direction it should be optimzed. Defaults to <code>MaximizeObjective</code>.</p> Source code in <code>bofire/data_models/features/continuous.py</code> <pre><code>class ContinuousOutput(Output):\n\"\"\"The base class for a continuous output feature\n\n    Attributes:\n        objective (objective, optional): objective of the feature indicating in which direction it should be optimzed. Defaults to `MaximizeObjective`.\n    \"\"\"\n\n    type: Literal[\"ContinuousOutput\"] = \"ContinuousOutput\"\n    order_id: ClassVar[int] = 7\n    unit: Optional[str] = None\n\n    objective: Optional[AnyObjective] = Field(\n        default_factory=lambda: MaximizeObjective(w=1.0)\n    )\n\n    def __call__(self, values: pd.Series) -&gt; pd.Series:\n        if self.objective is None:\n            return pd.Series(\n                data=[np.nan for _ in range(len(values))],\n                index=values.index,\n                name=values.name,\n            )\n        return self.objective(values)  # type: ignore\n\n    def __str__(self) -&gt; str:\n        return \"ContinuousOutputFeature\"\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.continuous.ContinuousOutput.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-features/#bofire.data_models.features.continuous.ContinuousOutput.__str__","title":"<code>__str__(self)</code>  <code>special</code>","text":"<p>Return str(self).</p> Source code in <code>bofire/data_models/features/continuous.py</code> <pre><code>def __str__(self) -&gt; str:\n    return \"ContinuousOutputFeature\"\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.descriptor","title":"<code>descriptor</code>","text":""},{"location":"ref-features/#bofire.data_models.features.descriptor.CategoricalDescriptorInput","title":"<code> CategoricalDescriptorInput            (CategoricalInput)         </code>  <code>pydantic-model</code>","text":"<p>Class for categorical input features with descriptors</p> <p>Attributes:</p> Name Type Description <code>categories</code> <code>List[str]</code> <p>Names of the categories.</p> <code>allowed</code> <code>List[bool]</code> <p>List of bools indicating if a category is allowed within the optimization.</p> <code>descriptors</code> <code>List[str]</code> <p>List of strings representing the names of the descriptors.</p> <code>values</code> <code>List[List[float]]</code> <p>List of lists representing the descriptor values.</p> Source code in <code>bofire/data_models/features/descriptor.py</code> <pre><code>class CategoricalDescriptorInput(CategoricalInput):\n\"\"\"Class for categorical input features with descriptors\n\n    Attributes:\n        categories (List[str]): Names of the categories.\n        allowed (List[bool]): List of bools indicating if a category is allowed within the optimization.\n        descriptors (List[str]): List of strings representing the names of the descriptors.\n        values (List[List[float]]): List of lists representing the descriptor values.\n    \"\"\"\n\n    type: Literal[\"CategoricalDescriptorInput\"] = \"CategoricalDescriptorInput\"\n    order_id: ClassVar[int] = 4\n\n    descriptors: TDescriptors\n    values: TCategoricalDescriptorVals\n\n    @validator(\"descriptors\")\n    def validate_descriptors(cls, descriptors):\n\"\"\"validates that descriptors have unique names\n\n        Args:\n            categories (List[str]): List of descriptor names\n\n        Raises:\n            ValueError: when descriptors have non-unique names\n\n        Returns:\n            List[str]: List of the descriptors\n        \"\"\"\n        descriptors = list(descriptors)\n        if len(descriptors) != len(set(descriptors)):\n            raise ValueError(\"descriptors must be unique\")\n        return descriptors\n\n    @validator(\"values\")\n    def validate_values(cls, v, values):\n\"\"\"validates the compatability of passed values for the descriptors and the defined categories\n\n        Args:\n            v (List[List[float]]): Nested list with descriptor values\n            values (Dict): Dictionary with attributes\n\n        Raises:\n            ValueError: when values have different length than categories\n            ValueError: when rows in values have different length than descriptors\n            ValueError: when a descriptor shows no variance in the data\n\n        Returns:\n            List[List[float]]: Nested list with descriptor values\n        \"\"\"\n        if len(v) != len(values[\"categories\"]):\n            raise ValueError(\"values must have same length as categories\")\n        for row in v:\n            if len(row) != len(values[\"descriptors\"]):\n                raise ValueError(\"rows in values must have same length as descriptors\")\n        a = np.array(v)\n        for i, d in enumerate(values[\"descriptors\"]):\n            if len(set(a[:, i])) == 1:\n                raise ValueError(f\"No variation for descriptor {d}.\")\n        return v\n\n    def to_df(self):\n\"\"\"tabular overview of the feature as DataFrame\n\n        Returns:\n            pd.DataFrame: tabular overview of the feature as DataFrame\n        \"\"\"\n        data = dict(zip(self.categories, self.values))\n        return pd.DataFrame.from_dict(data, orient=\"index\", columns=self.descriptors)\n\n    def fixed_value(\n        self, transform_type: Optional[TTransform] = None\n    ) -&gt; Union[List[str], List[float], None]:\n\"\"\"Returns the categories to which the feature is fixed, None if the feature is not fixed\n\n        Returns:\n            List[str]: List of categories or None\n        \"\"\"\n        if transform_type != CategoricalEncodingEnum.DESCRIPTOR:\n            return super().fixed_value(transform_type)\n        else:\n            val = self.get_allowed_categories()[0]\n            return self.to_descriptor_encoding(pd.Series([val])).values[0].tolist()\n\n    def get_bounds(\n        self, transform_type: TTransform, values: Optional[pd.Series] = None\n    ) -&gt; Tuple[List[float], List[float]]:\n        if transform_type != CategoricalEncodingEnum.DESCRIPTOR:\n            return super().get_bounds(transform_type, values)\n        else:\n            # in case that values is None, we return the optimization bounds\n            # else we return the complete bounds\n            if values is None:\n                df = self.to_df().loc[self.get_allowed_categories()]\n            else:\n                df = self.to_df()\n            lower = df.min().values.tolist()  # type: ignore\n            upper = df.max().values.tolist()  # type: ignore\n            return lower, upper\n\n    def validate_experimental(\n        self, values: pd.Series, strict: bool = False\n    ) -&gt; pd.Series:\n\"\"\"Method to validate the experimental dataFrame\n\n        Args:\n            values (pd.Series): A dataFrame with experiments\n            strict (bool, optional): Boolean to distinguish if the occurence of fixed features in the dataset should be considered or not. Defaults to False.\n\n        Raises:\n            ValueError: when an entry is not in the list of allowed categories\n            ValueError: when there is no variation in a feature provided by the experimental data\n            ValueError: when no variation is present or planed for a given descriptor\n\n        Returns:\n            pd.Series: A dataFrame with experiments\n        \"\"\"\n        values = super().validate_experimental(values, strict)\n        if strict:\n            lower, upper = self.get_bounds(\n                transform_type=CategoricalEncodingEnum.DESCRIPTOR, values=values\n            )\n            for i, desc in enumerate(self.descriptors):\n                if lower[i] == upper[i]:\n                    raise ValueError(\n                        f\"No variation present or planned for descriptor {desc} for feature {self.key}. Remove the descriptor.\"\n                    )\n        return values\n\n    @classmethod\n    def from_df(cls, key: str, df: pd.DataFrame):\n\"\"\"Creates a feature from a dataframe\n\n        Args:\n            key (str): The name of the feature\n            df (pd.DataFrame): Categories as rows and descriptors as columns\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        return cls(\n            key=key,\n            categories=list(df.index),\n            allowed=[True for _ in range(len(df))],\n            descriptors=list(df.columns),\n            values=df.values.tolist(),\n        )\n\n    def to_descriptor_encoding(self, values: pd.Series) -&gt; pd.DataFrame:\n\"\"\"Converts values to descriptor encoding.\n\n        Args:\n            values (pd.Series): Values to transform.\n\n        Returns:\n            pd.DataFrame: Descriptor encoded dataframe.\n        \"\"\"\n        return pd.DataFrame(\n            data=values.map(\n                dict(zip(self.categories, self.values))\n            ).values.tolist(),  # type: ignore\n            columns=[f\"{self.key}{_CAT_SEP}{d}\" for d in self.descriptors],\n            index=values.index,\n        )\n\n    def from_descriptor_encoding(self, values: pd.DataFrame) -&gt; pd.Series:\n\"\"\"Converts values back from descriptor encoding.\n\n        Args:\n            values (pd.DataFrame): Descriptor encoded dataframe.\n\n        Raises:\n            ValueError: If descriptor columns not found in the dataframe.\n\n        Returns:\n            pd.Series: Series with categorical values.\n        \"\"\"\n        cat_cols = [f\"{self.key}{_CAT_SEP}{d}\" for d in self.descriptors]\n        # we allow here explicitly that the dataframe can have more columns than needed to have it\n        # easier in the backtransform.\n        if np.any([c not in values.columns for c in cat_cols]):\n            raise ValueError(\n                f\"{self.key}: Column names don't match categorical levels: {values.columns}, {cat_cols}.\"\n            )\n        s = pd.DataFrame(\n            data=np.sqrt(\n                np.sum(\n                    (\n                        values[cat_cols].to_numpy()[:, np.newaxis, :]\n                        - self.to_df().iloc[self.allowed].to_numpy()\n                    )\n                    ** 2,\n                    axis=2,\n                )\n            ),\n            columns=self.get_allowed_categories(),\n            index=values.index,\n        ).idxmin(1)\n        s.name = self.key\n        return s\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.descriptor.CategoricalDescriptorInput.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-features/#bofire.data_models.features.descriptor.CategoricalDescriptorInput.fixed_value","title":"<code>fixed_value(self, transform_type=None)</code>","text":"<p>Returns the categories to which the feature is fixed, None if the feature is not fixed</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of categories or None</p> Source code in <code>bofire/data_models/features/descriptor.py</code> <pre><code>def fixed_value(\n    self, transform_type: Optional[TTransform] = None\n) -&gt; Union[List[str], List[float], None]:\n\"\"\"Returns the categories to which the feature is fixed, None if the feature is not fixed\n\n    Returns:\n        List[str]: List of categories or None\n    \"\"\"\n    if transform_type != CategoricalEncodingEnum.DESCRIPTOR:\n        return super().fixed_value(transform_type)\n    else:\n        val = self.get_allowed_categories()[0]\n        return self.to_descriptor_encoding(pd.Series([val])).values[0].tolist()\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.descriptor.CategoricalDescriptorInput.from_descriptor_encoding","title":"<code>from_descriptor_encoding(self, values)</code>","text":"<p>Converts values back from descriptor encoding.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.DataFrame</code> <p>Descriptor encoded dataframe.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If descriptor columns not found in the dataframe.</p> <p>Returns:</p> Type Description <code>pd.Series</code> <p>Series with categorical values.</p> Source code in <code>bofire/data_models/features/descriptor.py</code> <pre><code>def from_descriptor_encoding(self, values: pd.DataFrame) -&gt; pd.Series:\n\"\"\"Converts values back from descriptor encoding.\n\n    Args:\n        values (pd.DataFrame): Descriptor encoded dataframe.\n\n    Raises:\n        ValueError: If descriptor columns not found in the dataframe.\n\n    Returns:\n        pd.Series: Series with categorical values.\n    \"\"\"\n    cat_cols = [f\"{self.key}{_CAT_SEP}{d}\" for d in self.descriptors]\n    # we allow here explicitly that the dataframe can have more columns than needed to have it\n    # easier in the backtransform.\n    if np.any([c not in values.columns for c in cat_cols]):\n        raise ValueError(\n            f\"{self.key}: Column names don't match categorical levels: {values.columns}, {cat_cols}.\"\n        )\n    s = pd.DataFrame(\n        data=np.sqrt(\n            np.sum(\n                (\n                    values[cat_cols].to_numpy()[:, np.newaxis, :]\n                    - self.to_df().iloc[self.allowed].to_numpy()\n                )\n                ** 2,\n                axis=2,\n            )\n        ),\n        columns=self.get_allowed_categories(),\n        index=values.index,\n    ).idxmin(1)\n    s.name = self.key\n    return s\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.descriptor.CategoricalDescriptorInput.from_df","title":"<code>from_df(key, df)</code>  <code>classmethod</code>","text":"<p>Creates a feature from a dataframe</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the feature</p> required <code>df</code> <code>pd.DataFrame</code> <p>Categories as rows and descriptors as columns</p> required <p>Returns:</p> Type Description <code>_type_</code> <p>description</p> Source code in <code>bofire/data_models/features/descriptor.py</code> <pre><code>@classmethod\ndef from_df(cls, key: str, df: pd.DataFrame):\n\"\"\"Creates a feature from a dataframe\n\n    Args:\n        key (str): The name of the feature\n        df (pd.DataFrame): Categories as rows and descriptors as columns\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    return cls(\n        key=key,\n        categories=list(df.index),\n        allowed=[True for _ in range(len(df))],\n        descriptors=list(df.columns),\n        values=df.values.tolist(),\n    )\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.descriptor.CategoricalDescriptorInput.get_bounds","title":"<code>get_bounds(self, transform_type, values=None)</code>","text":"<p>Returns the bounds of an input feature depending on the requested transform type.</p> <p>Parameters:</p> Name Type Description Default <code>transform_type</code> <code>Optional[TTransform]</code> <p>The requested transform type. Defaults to None.</p> required <code>values</code> <code>Optional[pd.Series]</code> <p>If values are provided the bounds are returned taking the most extreme values for the feature into account. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[List[float], List[float]]</code> <p>List of lower bound values, list of upper bound values.</p> Source code in <code>bofire/data_models/features/descriptor.py</code> <pre><code>def get_bounds(\n    self, transform_type: TTransform, values: Optional[pd.Series] = None\n) -&gt; Tuple[List[float], List[float]]:\n    if transform_type != CategoricalEncodingEnum.DESCRIPTOR:\n        return super().get_bounds(transform_type, values)\n    else:\n        # in case that values is None, we return the optimization bounds\n        # else we return the complete bounds\n        if values is None:\n            df = self.to_df().loc[self.get_allowed_categories()]\n        else:\n            df = self.to_df()\n        lower = df.min().values.tolist()  # type: ignore\n        upper = df.max().values.tolist()  # type: ignore\n        return lower, upper\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.descriptor.CategoricalDescriptorInput.to_descriptor_encoding","title":"<code>to_descriptor_encoding(self, values)</code>","text":"<p>Converts values to descriptor encoding.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>Values to transform.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Descriptor encoded dataframe.</p> Source code in <code>bofire/data_models/features/descriptor.py</code> <pre><code>def to_descriptor_encoding(self, values: pd.Series) -&gt; pd.DataFrame:\n\"\"\"Converts values to descriptor encoding.\n\n    Args:\n        values (pd.Series): Values to transform.\n\n    Returns:\n        pd.DataFrame: Descriptor encoded dataframe.\n    \"\"\"\n    return pd.DataFrame(\n        data=values.map(\n            dict(zip(self.categories, self.values))\n        ).values.tolist(),  # type: ignore\n        columns=[f\"{self.key}{_CAT_SEP}{d}\" for d in self.descriptors],\n        index=values.index,\n    )\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.descriptor.CategoricalDescriptorInput.to_df","title":"<code>to_df(self)</code>","text":"<p>tabular overview of the feature as DataFrame</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>tabular overview of the feature as DataFrame</p> Source code in <code>bofire/data_models/features/descriptor.py</code> <pre><code>def to_df(self):\n\"\"\"tabular overview of the feature as DataFrame\n\n    Returns:\n        pd.DataFrame: tabular overview of the feature as DataFrame\n    \"\"\"\n    data = dict(zip(self.categories, self.values))\n    return pd.DataFrame.from_dict(data, orient=\"index\", columns=self.descriptors)\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.descriptor.CategoricalDescriptorInput.validate_descriptors","title":"<code>validate_descriptors(descriptors)</code>  <code>classmethod</code>","text":"<p>validates that descriptors have unique names</p> <p>Parameters:</p> Name Type Description Default <code>categories</code> <code>List[str]</code> <p>List of descriptor names</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>when descriptors have non-unique names</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of the descriptors</p> Source code in <code>bofire/data_models/features/descriptor.py</code> <pre><code>@validator(\"descriptors\")\ndef validate_descriptors(cls, descriptors):\n\"\"\"validates that descriptors have unique names\n\n    Args:\n        categories (List[str]): List of descriptor names\n\n    Raises:\n        ValueError: when descriptors have non-unique names\n\n    Returns:\n        List[str]: List of the descriptors\n    \"\"\"\n    descriptors = list(descriptors)\n    if len(descriptors) != len(set(descriptors)):\n        raise ValueError(\"descriptors must be unique\")\n    return descriptors\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.descriptor.CategoricalDescriptorInput.validate_experimental","title":"<code>validate_experimental(self, values, strict=False)</code>","text":"<p>Method to validate the experimental dataFrame</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>A dataFrame with experiments</p> required <code>strict</code> <code>bool</code> <p>Boolean to distinguish if the occurence of fixed features in the dataset should be considered or not. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>when an entry is not in the list of allowed categories</p> <code>ValueError</code> <p>when there is no variation in a feature provided by the experimental data</p> <code>ValueError</code> <p>when no variation is present or planed for a given descriptor</p> <p>Returns:</p> Type Description <code>pd.Series</code> <p>A dataFrame with experiments</p> Source code in <code>bofire/data_models/features/descriptor.py</code> <pre><code>def validate_experimental(\n    self, values: pd.Series, strict: bool = False\n) -&gt; pd.Series:\n\"\"\"Method to validate the experimental dataFrame\n\n    Args:\n        values (pd.Series): A dataFrame with experiments\n        strict (bool, optional): Boolean to distinguish if the occurence of fixed features in the dataset should be considered or not. Defaults to False.\n\n    Raises:\n        ValueError: when an entry is not in the list of allowed categories\n        ValueError: when there is no variation in a feature provided by the experimental data\n        ValueError: when no variation is present or planed for a given descriptor\n\n    Returns:\n        pd.Series: A dataFrame with experiments\n    \"\"\"\n    values = super().validate_experimental(values, strict)\n    if strict:\n        lower, upper = self.get_bounds(\n            transform_type=CategoricalEncodingEnum.DESCRIPTOR, values=values\n        )\n        for i, desc in enumerate(self.descriptors):\n            if lower[i] == upper[i]:\n                raise ValueError(\n                    f\"No variation present or planned for descriptor {desc} for feature {self.key}. Remove the descriptor.\"\n                )\n    return values\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.descriptor.CategoricalDescriptorInput.validate_values","title":"<code>validate_values(v, values)</code>  <code>classmethod</code>","text":"<p>validates the compatability of passed values for the descriptors and the defined categories</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>List[List[float]]</code> <p>Nested list with descriptor values</p> required <code>values</code> <code>Dict</code> <p>Dictionary with attributes</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>when values have different length than categories</p> <code>ValueError</code> <p>when rows in values have different length than descriptors</p> <code>ValueError</code> <p>when a descriptor shows no variance in the data</p> <p>Returns:</p> Type Description <code>List[List[float]]</code> <p>Nested list with descriptor values</p> Source code in <code>bofire/data_models/features/descriptor.py</code> <pre><code>@validator(\"values\")\ndef validate_values(cls, v, values):\n\"\"\"validates the compatability of passed values for the descriptors and the defined categories\n\n    Args:\n        v (List[List[float]]): Nested list with descriptor values\n        values (Dict): Dictionary with attributes\n\n    Raises:\n        ValueError: when values have different length than categories\n        ValueError: when rows in values have different length than descriptors\n        ValueError: when a descriptor shows no variance in the data\n\n    Returns:\n        List[List[float]]: Nested list with descriptor values\n    \"\"\"\n    if len(v) != len(values[\"categories\"]):\n        raise ValueError(\"values must have same length as categories\")\n    for row in v:\n        if len(row) != len(values[\"descriptors\"]):\n            raise ValueError(\"rows in values must have same length as descriptors\")\n    a = np.array(v)\n    for i, d in enumerate(values[\"descriptors\"]):\n        if len(set(a[:, i])) == 1:\n            raise ValueError(f\"No variation for descriptor {d}.\")\n    return v\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.descriptor.ContinuousDescriptorInput","title":"<code> ContinuousDescriptorInput            (ContinuousInput)         </code>  <code>pydantic-model</code>","text":"<p>Class for continuous input features with descriptors</p> <p>Attributes:</p> Name Type Description <code>lower_bound</code> <code>float</code> <p>Lower bound of the feature in the optimization.</p> <code>upper_bound</code> <code>float</code> <p>Upper bound of the feature in the optimization.</p> <code>descriptors</code> <code>List[str]</code> <p>Names of the descriptors.</p> <code>values</code> <code>List[float]</code> <p>Values of the descriptors.</p> Source code in <code>bofire/data_models/features/descriptor.py</code> <pre><code>class ContinuousDescriptorInput(ContinuousInput):\n\"\"\"Class for continuous input features with descriptors\n\n    Attributes:\n        lower_bound (float): Lower bound of the feature in the optimization.\n        upper_bound (float): Upper bound of the feature in the optimization.\n        descriptors (List[str]): Names of the descriptors.\n        values (List[float]): Values of the descriptors.\n    \"\"\"\n\n    type: Literal[\"ContinuousDescriptorInput\"] = \"ContinuousDescriptorInput\"\n    order_id: ClassVar[int] = 2\n\n    descriptors: TDescriptors\n    values: TDiscreteVals\n\n    @validator(\"descriptors\")\n    def descriptors_to_keys(cls, descriptors):\n\"\"\"validates the descriptor names and transforms it to valid keys\n\n        Args:\n            descriptors (List[str]): List of descriptor names\n\n        Returns:\n            List[str]: List of valid keys\n        \"\"\"\n        return list(descriptors)\n\n    @root_validator(pre=False, skip_on_failure=True)\n    def validate_list_lengths(cls, values):\n\"\"\"compares the length of the defined descriptors list with the provided values\n\n        Args:\n            values (Dict): Dictionary with all attribues\n\n        Raises:\n            ValueError: when the number of descriptors does not math the number of provided values\n\n        Returns:\n            Dict: Dict with the attributes\n        \"\"\"\n        if len(values[\"descriptors\"]) != len(values[\"values\"]):\n            raise ValueError(\n                'must provide same number of descriptors and values, got {len(values[\"descriptors\"])} != {len(values[\"values\"])}'\n            )\n        return values\n\n    def to_df(self) -&gt; pd.DataFrame:\n\"\"\"tabular overview of the feature as DataFrame\n\n        Returns:\n            pd.DataFrame: tabular overview of the feature as DataFrame\n        \"\"\"\n        return pd.DataFrame(\n            data=[self.values], index=[self.key], columns=self.descriptors\n        )\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.descriptor.ContinuousDescriptorInput.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-features/#bofire.data_models.features.descriptor.ContinuousDescriptorInput.descriptors_to_keys","title":"<code>descriptors_to_keys(descriptors)</code>  <code>classmethod</code>","text":"<p>validates the descriptor names and transforms it to valid keys</p> <p>Parameters:</p> Name Type Description Default <code>descriptors</code> <code>List[str]</code> <p>List of descriptor names</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of valid keys</p> Source code in <code>bofire/data_models/features/descriptor.py</code> <pre><code>@validator(\"descriptors\")\ndef descriptors_to_keys(cls, descriptors):\n\"\"\"validates the descriptor names and transforms it to valid keys\n\n    Args:\n        descriptors (List[str]): List of descriptor names\n\n    Returns:\n        List[str]: List of valid keys\n    \"\"\"\n    return list(descriptors)\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.descriptor.ContinuousDescriptorInput.to_df","title":"<code>to_df(self)</code>","text":"<p>tabular overview of the feature as DataFrame</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>tabular overview of the feature as DataFrame</p> Source code in <code>bofire/data_models/features/descriptor.py</code> <pre><code>def to_df(self) -&gt; pd.DataFrame:\n\"\"\"tabular overview of the feature as DataFrame\n\n    Returns:\n        pd.DataFrame: tabular overview of the feature as DataFrame\n    \"\"\"\n    return pd.DataFrame(\n        data=[self.values], index=[self.key], columns=self.descriptors\n    )\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.descriptor.ContinuousDescriptorInput.validate_list_lengths","title":"<code>validate_list_lengths(values)</code>  <code>classmethod</code>","text":"<p>compares the length of the defined descriptors list with the provided values</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Dict</code> <p>Dictionary with all attribues</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>when the number of descriptors does not math the number of provided values</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dict with the attributes</p> Source code in <code>bofire/data_models/features/descriptor.py</code> <pre><code>@root_validator(pre=False, skip_on_failure=True)\ndef validate_list_lengths(cls, values):\n\"\"\"compares the length of the defined descriptors list with the provided values\n\n    Args:\n        values (Dict): Dictionary with all attribues\n\n    Raises:\n        ValueError: when the number of descriptors does not math the number of provided values\n\n    Returns:\n        Dict: Dict with the attributes\n    \"\"\"\n    if len(values[\"descriptors\"]) != len(values[\"values\"]):\n        raise ValueError(\n            'must provide same number of descriptors and values, got {len(values[\"descriptors\"])} != {len(values[\"values\"])}'\n        )\n    return values\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.discrete","title":"<code>discrete</code>","text":""},{"location":"ref-features/#bofire.data_models.features.discrete.DiscreteInput","title":"<code> DiscreteInput            (NumericalInput)         </code>  <code>pydantic-model</code>","text":"<p>Feature with discretized ordinal values allowed in the optimization.</p> <p>Attributes:</p> Name Type Description <code>key(str)</code> <p>key of the feature.</p> <code>values(List[float])</code> <p>the discretized allowed values during the optimization.</p> Source code in <code>bofire/data_models/features/discrete.py</code> <pre><code>class DiscreteInput(NumericalInput):\n\"\"\"Feature with discretized ordinal values allowed in the optimization.\n\n    Attributes:\n        key(str): key of the feature.\n        values(List[float]): the discretized allowed values during the optimization.\n    \"\"\"\n\n    type: Literal[\"DiscreteInput\"] = \"DiscreteInput\"\n    order_id: ClassVar[int] = 3\n\n    values: TDiscreteVals\n\n    @validator(\"values\")\n    def validate_values_unique(cls, values):\n\"\"\"Validates that provided values are unique.\n\n        Args:\n            values (List[float]): List of values\n\n        Raises:\n            ValueError: when values are non-unique.\n            ValueError: when values contains only one entry.\n            ValueError: when values is empty.\n\n        Returns:\n            List[values]: Sorted list of values\n        \"\"\"\n        if len(values) != len(set(values)):\n            raise ValueError(\"Discrete values must be unique\")\n        if len(values) == 1:\n            raise ValueError(\n                \"Fixed discrete inputs are not supported. Please use a fixed continuous input.\"\n            )\n        if len(values) == 0:\n            raise ValueError(\"No values defined.\")\n        return sorted(values)\n\n    @property\n    def lower_bound(self) -&gt; float:\n\"\"\"Lower bound of the set of allowed values\"\"\"\n        return min(self.values)\n\n    @property\n    def upper_bound(self) -&gt; float:\n\"\"\"Upper bound of the set of allowed values\"\"\"\n        return max(self.values)\n\n    def validate_candidental(self, values: pd.Series) -&gt; pd.Series:\n\"\"\"Method to validate the provided candidates.\n\n        Args:\n            values (pd.Series): suggested candidates for the feature\n\n        Raises:\n            ValueError: Raises error when one of the provided values is not contained in the list of allowed values.\n\n        Returns:\n            pd.Series: _uggested candidates for the feature\n        \"\"\"\n        super().validate_candidental(values)\n        if not np.isin(values.to_numpy(), np.array(self.values)).all():\n            raise ValueError(\n                f\"Not allowed values in candidates for feature {self.key}.\"\n            )\n        return values\n\n    def sample(self, n: int) -&gt; pd.Series:\n\"\"\"Draw random samples from the feature.\n\n        Args:\n            n (int): number of samples.\n\n        Returns:\n            pd.Series: drawn samples.\n        \"\"\"\n        return pd.Series(name=self.key, data=np.random.choice(self.values, n))\n\n    def from_continuous(self, values: pd.DataFrame) -&gt; pd.Series:\n\"\"\"Rounds continuous values to the closest discrete ones.\n\n        Args:\n            values (pd.DataFrame): Dataframe with continuous entries.\n\n        Returns:\n            pd.Series: Series with discrete values.\n        \"\"\"\n\n        s = pd.DataFrame(\n            data=np.abs(\n                (values[self.key].to_numpy()[:, np.newaxis] - np.array(self.values))\n            ),\n            columns=self.values,\n            index=values.index,\n        ).idxmin(1)\n        s.name = self.key\n        return s\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.discrete.DiscreteInput.lower_bound","title":"<code>lower_bound: float</code>  <code>property</code> <code>readonly</code>","text":"<p>Lower bound of the set of allowed values</p>"},{"location":"ref-features/#bofire.data_models.features.discrete.DiscreteInput.upper_bound","title":"<code>upper_bound: float</code>  <code>property</code> <code>readonly</code>","text":"<p>Upper bound of the set of allowed values</p>"},{"location":"ref-features/#bofire.data_models.features.discrete.DiscreteInput.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-features/#bofire.data_models.features.discrete.DiscreteInput.from_continuous","title":"<code>from_continuous(self, values)</code>","text":"<p>Rounds continuous values to the closest discrete ones.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.DataFrame</code> <p>Dataframe with continuous entries.</p> required <p>Returns:</p> Type Description <code>pd.Series</code> <p>Series with discrete values.</p> Source code in <code>bofire/data_models/features/discrete.py</code> <pre><code>def from_continuous(self, values: pd.DataFrame) -&gt; pd.Series:\n\"\"\"Rounds continuous values to the closest discrete ones.\n\n    Args:\n        values (pd.DataFrame): Dataframe with continuous entries.\n\n    Returns:\n        pd.Series: Series with discrete values.\n    \"\"\"\n\n    s = pd.DataFrame(\n        data=np.abs(\n            (values[self.key].to_numpy()[:, np.newaxis] - np.array(self.values))\n        ),\n        columns=self.values,\n        index=values.index,\n    ).idxmin(1)\n    s.name = self.key\n    return s\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.discrete.DiscreteInput.sample","title":"<code>sample(self, n)</code>","text":"<p>Draw random samples from the feature.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>number of samples.</p> required <p>Returns:</p> Type Description <code>pd.Series</code> <p>drawn samples.</p> Source code in <code>bofire/data_models/features/discrete.py</code> <pre><code>def sample(self, n: int) -&gt; pd.Series:\n\"\"\"Draw random samples from the feature.\n\n    Args:\n        n (int): number of samples.\n\n    Returns:\n        pd.Series: drawn samples.\n    \"\"\"\n    return pd.Series(name=self.key, data=np.random.choice(self.values, n))\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.discrete.DiscreteInput.validate_candidental","title":"<code>validate_candidental(self, values)</code>","text":"<p>Method to validate the provided candidates.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>suggested candidates for the feature</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>Raises error when one of the provided values is not contained in the list of allowed values.</p> <p>Returns:</p> Type Description <code>pd.Series</code> <p>_uggested candidates for the feature</p> Source code in <code>bofire/data_models/features/discrete.py</code> <pre><code>def validate_candidental(self, values: pd.Series) -&gt; pd.Series:\n\"\"\"Method to validate the provided candidates.\n\n    Args:\n        values (pd.Series): suggested candidates for the feature\n\n    Raises:\n        ValueError: Raises error when one of the provided values is not contained in the list of allowed values.\n\n    Returns:\n        pd.Series: _uggested candidates for the feature\n    \"\"\"\n    super().validate_candidental(values)\n    if not np.isin(values.to_numpy(), np.array(self.values)).all():\n        raise ValueError(\n            f\"Not allowed values in candidates for feature {self.key}.\"\n        )\n    return values\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.discrete.DiscreteInput.validate_values_unique","title":"<code>validate_values_unique(values)</code>  <code>classmethod</code>","text":"<p>Validates that provided values are unique.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>List[float]</code> <p>List of values</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>when values are non-unique.</p> <code>ValueError</code> <p>when values contains only one entry.</p> <code>ValueError</code> <p>when values is empty.</p> <p>Returns:</p> Type Description <code>List[values]</code> <p>Sorted list of values</p> Source code in <code>bofire/data_models/features/discrete.py</code> <pre><code>@validator(\"values\")\ndef validate_values_unique(cls, values):\n\"\"\"Validates that provided values are unique.\n\n    Args:\n        values (List[float]): List of values\n\n    Raises:\n        ValueError: when values are non-unique.\n        ValueError: when values contains only one entry.\n        ValueError: when values is empty.\n\n    Returns:\n        List[values]: Sorted list of values\n    \"\"\"\n    if len(values) != len(set(values)):\n        raise ValueError(\"Discrete values must be unique\")\n    if len(values) == 1:\n        raise ValueError(\n            \"Fixed discrete inputs are not supported. Please use a fixed continuous input.\"\n        )\n    if len(values) == 0:\n        raise ValueError(\"No values defined.\")\n    return sorted(values)\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.feature","title":"<code>feature</code>","text":""},{"location":"ref-features/#bofire.data_models.features.feature.Feature","title":"<code> Feature            (BaseModel)         </code>  <code>pydantic-model</code>","text":"<p>The base class for all features.</p> Source code in <code>bofire/data_models/features/feature.py</code> <pre><code>class Feature(BaseModel):\n\"\"\"The base class for all features.\"\"\"\n\n    type: str\n    key: str\n    order_id: ClassVar[int] = -1\n\n    def __lt__(self, other) -&gt; bool:\n\"\"\"\n        Method to compare two models to get them in the desired order.\n        Return True if other is larger than self, else False. (see FEATURE_ORDER)\n\n        Args:\n            other: The other class to compare to self\n\n        Returns:\n            bool: True if the other class is larger than self, else False\n        \"\"\"\n        order_self = self.order_id\n        order_other = other.order_id\n        if order_self == order_other:\n            return self.key &lt; other.key\n        else:\n            return order_self &lt; order_other\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.feature.Feature.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-features/#bofire.data_models.features.feature.Feature.__lt__","title":"<code>__lt__(self, other)</code>  <code>special</code>","text":"<p>Method to compare two models to get them in the desired order. Return True if other is larger than self, else False. (see FEATURE_ORDER)</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>The other class to compare to self</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the other class is larger than self, else False</p> Source code in <code>bofire/data_models/features/feature.py</code> <pre><code>def __lt__(self, other) -&gt; bool:\n\"\"\"\n    Method to compare two models to get them in the desired order.\n    Return True if other is larger than self, else False. (see FEATURE_ORDER)\n\n    Args:\n        other: The other class to compare to self\n\n    Returns:\n        bool: True if the other class is larger than self, else False\n    \"\"\"\n    order_self = self.order_id\n    order_other = other.order_id\n    if order_self == order_other:\n        return self.key &lt; other.key\n    else:\n        return order_self &lt; order_other\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.feature.Input","title":"<code> Input            (Feature)         </code>  <code>pydantic-model</code>","text":"<p>Base class for all input features.</p> Source code in <code>bofire/data_models/features/feature.py</code> <pre><code>class Input(Feature):\n\"\"\"Base class for all input features.\"\"\"\n\n    @abstractmethod\n    def is_fixed(self) -&gt; bool:\n\"\"\"Indicates if a variable is set to a fixed value.\n\n        Returns:\n            bool: True if fixed, els False.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def fixed_value(\n        self, transform_type: Optional[TTransform] = None\n    ) -&gt; Union[None, List[str], List[float]]:\n\"\"\"Method to return the fixed value in case of a fixed feature.\n\n        Returns:\n            Union[None,str,float]: None in case the feature is not fixed, else the fixed value.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def validate_experimental(\n        self, values: pd.Series, strict: bool = False\n    ) -&gt; pd.Series:\n\"\"\"Abstract method to validate the experimental dataFrame\n\n        Args:\n            values (pd.Series): A dataFrame with experiments\n            strict (bool, optional): Boolean to distinguish if the occurence of fixed features in the dataset should be considered or not. Defaults to False.\n\n        Returns:\n            pd.Series: The passed dataFrame with experiments\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def validate_candidental(self, values: pd.Series) -&gt; pd.Series:\n\"\"\"Abstract method to validate the suggested candidates\n\n        Args:\n            values (pd.Series): A dataFrame with candidates\n\n        Returns:\n            pd.Series: The passed dataFrame with candidates\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def sample(self, n: int) -&gt; pd.Series:\n\"\"\"Sample a series of allowed values.\n\n        Args:\n            n (int): Number of samples\n\n        Returns:\n            pd.Series: Sampled values.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_bounds(\n        self,\n        transform_type: Optional[TTransform] = None,\n        values: Optional[pd.Series] = None,\n    ) -&gt; Tuple[List[float], List[float]]:\n\"\"\"Returns the bounds of an input feature depending on the requested transform type.\n\n        Args:\n            transform_type (Optional[TTransform], optional): The requested transform type. Defaults to None.\n            values (Optional[pd.Series], optional): If values are provided the bounds are returned taking\n                the most extreme values for the feature into account. Defaults to None.\n\n        Returns:\n            Tuple[List[float], List[float]]: List of lower bound values, list of upper bound values.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.feature.Input.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-features/#bofire.data_models.features.feature.Input.fixed_value","title":"<code>fixed_value(self, transform_type=None)</code>","text":"<p>Method to return the fixed value in case of a fixed feature.</p> <p>Returns:</p> Type Description <code>Union[None,str,float]</code> <p>None in case the feature is not fixed, else the fixed value.</p> Source code in <code>bofire/data_models/features/feature.py</code> <pre><code>@abstractmethod\ndef fixed_value(\n    self, transform_type: Optional[TTransform] = None\n) -&gt; Union[None, List[str], List[float]]:\n\"\"\"Method to return the fixed value in case of a fixed feature.\n\n    Returns:\n        Union[None,str,float]: None in case the feature is not fixed, else the fixed value.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.feature.Input.get_bounds","title":"<code>get_bounds(self, transform_type=None, values=None)</code>","text":"<p>Returns the bounds of an input feature depending on the requested transform type.</p> <p>Parameters:</p> Name Type Description Default <code>transform_type</code> <code>Optional[TTransform]</code> <p>The requested transform type. Defaults to None.</p> <code>None</code> <code>values</code> <code>Optional[pd.Series]</code> <p>If values are provided the bounds are returned taking the most extreme values for the feature into account. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[List[float], List[float]]</code> <p>List of lower bound values, list of upper bound values.</p> Source code in <code>bofire/data_models/features/feature.py</code> <pre><code>@abstractmethod\ndef get_bounds(\n    self,\n    transform_type: Optional[TTransform] = None,\n    values: Optional[pd.Series] = None,\n) -&gt; Tuple[List[float], List[float]]:\n\"\"\"Returns the bounds of an input feature depending on the requested transform type.\n\n    Args:\n        transform_type (Optional[TTransform], optional): The requested transform type. Defaults to None.\n        values (Optional[pd.Series], optional): If values are provided the bounds are returned taking\n            the most extreme values for the feature into account. Defaults to None.\n\n    Returns:\n        Tuple[List[float], List[float]]: List of lower bound values, list of upper bound values.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.feature.Input.is_fixed","title":"<code>is_fixed(self)</code>","text":"<p>Indicates if a variable is set to a fixed value.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if fixed, els False.</p> Source code in <code>bofire/data_models/features/feature.py</code> <pre><code>@abstractmethod\ndef is_fixed(self) -&gt; bool:\n\"\"\"Indicates if a variable is set to a fixed value.\n\n    Returns:\n        bool: True if fixed, els False.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.feature.Input.sample","title":"<code>sample(self, n)</code>","text":"<p>Sample a series of allowed values.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of samples</p> required <p>Returns:</p> Type Description <code>pd.Series</code> <p>Sampled values.</p> Source code in <code>bofire/data_models/features/feature.py</code> <pre><code>@abstractmethod\ndef sample(self, n: int) -&gt; pd.Series:\n\"\"\"Sample a series of allowed values.\n\n    Args:\n        n (int): Number of samples\n\n    Returns:\n        pd.Series: Sampled values.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.feature.Input.validate_candidental","title":"<code>validate_candidental(self, values)</code>","text":"<p>Abstract method to validate the suggested candidates</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>A dataFrame with candidates</p> required <p>Returns:</p> Type Description <code>pd.Series</code> <p>The passed dataFrame with candidates</p> Source code in <code>bofire/data_models/features/feature.py</code> <pre><code>@abstractmethod\ndef validate_candidental(self, values: pd.Series) -&gt; pd.Series:\n\"\"\"Abstract method to validate the suggested candidates\n\n    Args:\n        values (pd.Series): A dataFrame with candidates\n\n    Returns:\n        pd.Series: The passed dataFrame with candidates\n    \"\"\"\n    pass\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.feature.Input.validate_experimental","title":"<code>validate_experimental(self, values, strict=False)</code>","text":"<p>Abstract method to validate the experimental dataFrame</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>A dataFrame with experiments</p> required <code>strict</code> <code>bool</code> <p>Boolean to distinguish if the occurence of fixed features in the dataset should be considered or not. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>pd.Series</code> <p>The passed dataFrame with experiments</p> Source code in <code>bofire/data_models/features/feature.py</code> <pre><code>@abstractmethod\ndef validate_experimental(\n    self, values: pd.Series, strict: bool = False\n) -&gt; pd.Series:\n\"\"\"Abstract method to validate the experimental dataFrame\n\n    Args:\n        values (pd.Series): A dataFrame with experiments\n        strict (bool, optional): Boolean to distinguish if the occurence of fixed features in the dataset should be considered or not. Defaults to False.\n\n    Returns:\n        pd.Series: The passed dataFrame with experiments\n    \"\"\"\n    pass\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.feature.Output","title":"<code> Output            (Feature)         </code>  <code>pydantic-model</code>","text":"<p>Base class for all output features.</p> <p>Attributes:</p> Name Type Description <code>key(str)</code> <p>Key of the Feature.</p> Source code in <code>bofire/data_models/features/feature.py</code> <pre><code>class Output(Feature):\n\"\"\"Base class for all output features.\n\n    Attributes:\n        key(str): Key of the Feature.\n    \"\"\"\n\n    @abstractmethod\n    def __call__(self, values: pd.Series) -&gt; pd.Series:\n        pass\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.feature.Output.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-features/#bofire.data_models.features.molecular","title":"<code>molecular</code>","text":""},{"location":"ref-features/#bofire.data_models.features.molecular.MolecularInput","title":"<code> MolecularInput            (Input)         </code>  <code>pydantic-model</code>","text":"Source code in <code>bofire/data_models/features/molecular.py</code> <pre><code>class MolecularInput(Input):\n    type: Literal[\"MolecularInput\"] = \"MolecularInput\"\n    order: ClassVar[int] = 6\n\n    def validate_experimental(\n        self, values: pd.Series, strict: bool = False\n    ) -&gt; pd.Series:\n        for smi in values:\n            smiles2mol(smi)\n        return values\n\n    def validate_candidental(self, values: pd.Series) -&gt; pd.Series:\n        for smi in values:\n            smiles2mol(smi)\n        return values\n\n    def fixed_value(self, transform_type: Optional[TTransform] = None) -&gt; None:\n        return None\n\n    def is_fixed(self) -&gt; bool:\n        return False\n\n    # TODO: model descriptors as pydantic class\n    def to_fingerprints(\n        self, values: pd.Series, bond_radius: int = 5, n_bits: int = 2048\n    ) -&gt; pd.DataFrame:\n        # validate it\n        data = smiles2fingerprints(\n            values.to_list(), bond_radius=bond_radius, n_bits=n_bits\n        )\n        return pd.DataFrame(\n            data=data,\n            columns=[f\"{self.key}{_CAT_SEP}{i}\" for i in range(data.shape[1])],\n        )\n\n    def to_bag_of_characters(\n        self, values: pd.Series, max_ngram: int = 5\n    ) -&gt; pd.DataFrame:\n        # todo: add selfies later\n        data = smiles2bag_of_characters(values.to_list(), max_ngram=max_ngram)\n        return pd.DataFrame(\n            data=data,\n            columns=[f\"{self.key}{_CAT_SEP}{i}\" for i in range(data.shape[1])],\n        )\n\n    def to_fragments(self, values: pd.Series):\n        data = smiles2fragments(values.to_list())\n        return pd.DataFrame(\n            data=data,\n            columns=[f\"{self.key}{_CAT_SEP}{i}\" for i in range(data.shape[1])],\n        )\n\n    def sample(self, n: int) -&gt; pd.Series:\n        raise ValueError(\"Sampling not supported for `MolecularInput`.\")\n\n    def get_bounds(\n        self, transform_type: TTransform, values: pd.Series\n    ) -&gt; Tuple[List[float], List[float]]:\n        # TODO: this is only needed for optimization for which we need also\n        # MolecularCategorical, this will be added later.\n        raise NotImplementedError(\"`get_bounds` not yet implemented.\")\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.molecular.MolecularInput.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-features/#bofire.data_models.features.molecular.MolecularInput.fixed_value","title":"<code>fixed_value(self, transform_type=None)</code>","text":"<p>Method to return the fixed value in case of a fixed feature.</p> <p>Returns:</p> Type Description <code>Union[None,str,float]</code> <p>None in case the feature is not fixed, else the fixed value.</p> Source code in <code>bofire/data_models/features/molecular.py</code> <pre><code>def fixed_value(self, transform_type: Optional[TTransform] = None) -&gt; None:\n    return None\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.molecular.MolecularInput.get_bounds","title":"<code>get_bounds(self, transform_type, values)</code>","text":"<p>Returns the bounds of an input feature depending on the requested transform type.</p> <p>Parameters:</p> Name Type Description Default <code>transform_type</code> <code>Optional[TTransform]</code> <p>The requested transform type. Defaults to None.</p> required <code>values</code> <code>Optional[pd.Series]</code> <p>If values are provided the bounds are returned taking the most extreme values for the feature into account. Defaults to None.</p> required <p>Returns:</p> Type Description <code>Tuple[List[float], List[float]]</code> <p>List of lower bound values, list of upper bound values.</p> Source code in <code>bofire/data_models/features/molecular.py</code> <pre><code>def get_bounds(\n    self, transform_type: TTransform, values: pd.Series\n) -&gt; Tuple[List[float], List[float]]:\n    # TODO: this is only needed for optimization for which we need also\n    # MolecularCategorical, this will be added later.\n    raise NotImplementedError(\"`get_bounds` not yet implemented.\")\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.molecular.MolecularInput.is_fixed","title":"<code>is_fixed(self)</code>","text":"<p>Indicates if a variable is set to a fixed value.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if fixed, els False.</p> Source code in <code>bofire/data_models/features/molecular.py</code> <pre><code>def is_fixed(self) -&gt; bool:\n    return False\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.molecular.MolecularInput.sample","title":"<code>sample(self, n)</code>","text":"<p>Sample a series of allowed values.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of samples</p> required <p>Returns:</p> Type Description <code>pd.Series</code> <p>Sampled values.</p> Source code in <code>bofire/data_models/features/molecular.py</code> <pre><code>def sample(self, n: int) -&gt; pd.Series:\n    raise ValueError(\"Sampling not supported for `MolecularInput`.\")\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.molecular.MolecularInput.validate_candidental","title":"<code>validate_candidental(self, values)</code>","text":"<p>Abstract method to validate the suggested candidates</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>A dataFrame with candidates</p> required <p>Returns:</p> Type Description <code>pd.Series</code> <p>The passed dataFrame with candidates</p> Source code in <code>bofire/data_models/features/molecular.py</code> <pre><code>def validate_candidental(self, values: pd.Series) -&gt; pd.Series:\n    for smi in values:\n        smiles2mol(smi)\n    return values\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.molecular.MolecularInput.validate_experimental","title":"<code>validate_experimental(self, values, strict=False)</code>","text":"<p>Abstract method to validate the experimental dataFrame</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>A dataFrame with experiments</p> required <code>strict</code> <code>bool</code> <p>Boolean to distinguish if the occurence of fixed features in the dataset should be considered or not. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>pd.Series</code> <p>The passed dataFrame with experiments</p> Source code in <code>bofire/data_models/features/molecular.py</code> <pre><code>def validate_experimental(\n    self, values: pd.Series, strict: bool = False\n) -&gt; pd.Series:\n    for smi in values:\n        smiles2mol(smi)\n    return values\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.numerical","title":"<code>numerical</code>","text":""},{"location":"ref-features/#bofire.data_models.features.numerical.NumericalInput","title":"<code> NumericalInput            (Input)         </code>  <code>pydantic-model</code>","text":"<p>Abstract base class for all numerical (ordinal) input features.</p> Source code in <code>bofire/data_models/features/numerical.py</code> <pre><code>class NumericalInput(Input):\n\"\"\"Abstract base class for all numerical (ordinal) input features.\"\"\"\n\n    unit: Optional[str] = None\n\n    def to_unit_range(\n        self, values: Union[pd.Series, np.ndarray], use_real_bounds: bool = False\n    ) -&gt; Union[pd.Series, np.ndarray]:\n\"\"\"Convert to the unit range between 0 and 1.\n\n        Args:\n            values (pd.Series): values to be transformed\n            use_real_bounds (bool, optional): if True, use the bounds from the actual values else the bounds from the feature.\n                Defaults to False.\n\n        Raises:\n            ValueError: If lower_bound == upper bound an error is raised\n\n        Returns:\n            pd.Series: transformed values.\n        \"\"\"\n        if use_real_bounds:\n            lower, upper = self.get_bounds(transform_type=None, values=values)\n            lower = lower[0]\n            upper = upper[0]\n        else:\n            lower, upper = self.lower_bound, self.upper_bound  # type: ignore\n        if lower == upper:\n            raise ValueError(\"Fixed feature cannot be transformed to unit range.\")\n        valrange = upper - lower\n        return (values - lower) / valrange\n\n    def from_unit_range(\n        self, values: Union[pd.Series, np.ndarray]\n    ) -&gt; Union[pd.Series, np.ndarray]:\n\"\"\"Convert from unit range.\n\n        Args:\n            values (pd.Series): values to transform from.\n\n        Raises:\n            ValueError: if the feature is fixed raise a value error.\n\n        Returns:\n            pd.Series: _description_\n        \"\"\"\n        if self.is_fixed():\n            raise ValueError(\"Fixed feature cannot be transformed from unit range.\")\n        valrange = self.upper_bound - self.lower_bound  # type: ignore\n        return (values * valrange) + self.lower_bound  # type: ignore\n\n    def is_fixed(self):\n\"\"\"Method to check if the feature is fixed\n\n        Returns:\n            Boolean: True when the feature is fixed, false otherwise.\n        \"\"\"\n        return self.lower_bound == self.upper_bound  # type: ignore\n\n    def fixed_value(\n        self, transform_type: Optional[TTransform] = None\n    ) -&gt; Union[None, List[float]]:\n\"\"\"Method to get the value to which the feature is fixed\n\n        Returns:\n            Float: Return the feature value or None if the feature is not fixed.\n        \"\"\"\n        assert transform_type is None\n        if self.is_fixed():\n            return [self.lower_bound]  # type: ignore\n        else:\n            return None\n\n    def validate_experimental(self, values: pd.Series, strict=False) -&gt; pd.Series:\n\"\"\"Method to validate the experimental dataFrame\n\n        Args:\n            values (pd.Series): A dataFrame with experiments\n            strict (bool, optional): Boolean to distinguish if the occurence of fixed features in the dataset should be considered or not.\n                Defaults to False.\n\n        Raises:\n            ValueError: when a value is not numerical\n            ValueError: when there is no variation in a feature provided by the experimental data\n\n        Returns:\n            pd.Series: A dataFrame with experiments\n        \"\"\"\n        if not is_numeric(values):\n            raise ValueError(\n                f\"not all values of input feature `{self.key}` are numerical\"\n            )\n        if strict:\n            lower, upper = self.get_bounds(transform_type=None, values=values)\n            if lower == upper:\n                raise ValueError(\n                    f\"No variation present or planned for feature {self.key}. Remove it.\"\n                )\n        return values\n\n    def validate_candidental(self, values: pd.Series) -&gt; pd.Series:\n\"\"\"Validate the suggested candidates for the feature.\n\n        Args:\n            values (pd.Series): suggested candidates for the feature\n\n        Raises:\n            ValueError: Error is raised when one of the values is not numerical.\n\n        Returns:\n            pd.Series: the original provided candidates\n        \"\"\"\n        if not is_numeric(values):\n            raise ValueError(\n                f\"not all values of input feature `{self.key}` are numerical\"\n            )\n        return values\n\n    def get_bounds(\n        self,\n        transform_type: Optional[TTransform] = None,\n        values: Optional[pd.Series] = None,\n    ) -&gt; Tuple[List[float], List[float]]:\n        assert transform_type is None\n        if values is None:\n            return [self.lower_bound], [self.upper_bound]  # type: ignore\n        lower = min(self.lower_bound, values.min())  # type: ignore\n        upper = max(self.upper_bound, values.max())  # type: ignore\n        return [lower], [upper]  # type: ignore\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.numerical.NumericalInput.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-features/#bofire.data_models.features.numerical.NumericalInput.fixed_value","title":"<code>fixed_value(self, transform_type=None)</code>","text":"<p>Method to get the value to which the feature is fixed</p> <p>Returns:</p> Type Description <code>Float</code> <p>Return the feature value or None if the feature is not fixed.</p> Source code in <code>bofire/data_models/features/numerical.py</code> <pre><code>def fixed_value(\n    self, transform_type: Optional[TTransform] = None\n) -&gt; Union[None, List[float]]:\n\"\"\"Method to get the value to which the feature is fixed\n\n    Returns:\n        Float: Return the feature value or None if the feature is not fixed.\n    \"\"\"\n    assert transform_type is None\n    if self.is_fixed():\n        return [self.lower_bound]  # type: ignore\n    else:\n        return None\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.numerical.NumericalInput.from_unit_range","title":"<code>from_unit_range(self, values)</code>","text":"<p>Convert from unit range.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>values to transform from.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>if the feature is fixed raise a value error.</p> <p>Returns:</p> Type Description <code>pd.Series</code> <p>description</p> Source code in <code>bofire/data_models/features/numerical.py</code> <pre><code>def from_unit_range(\n    self, values: Union[pd.Series, np.ndarray]\n) -&gt; Union[pd.Series, np.ndarray]:\n\"\"\"Convert from unit range.\n\n    Args:\n        values (pd.Series): values to transform from.\n\n    Raises:\n        ValueError: if the feature is fixed raise a value error.\n\n    Returns:\n        pd.Series: _description_\n    \"\"\"\n    if self.is_fixed():\n        raise ValueError(\"Fixed feature cannot be transformed from unit range.\")\n    valrange = self.upper_bound - self.lower_bound  # type: ignore\n    return (values * valrange) + self.lower_bound  # type: ignore\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.numerical.NumericalInput.get_bounds","title":"<code>get_bounds(self, transform_type=None, values=None)</code>","text":"<p>Returns the bounds of an input feature depending on the requested transform type.</p> <p>Parameters:</p> Name Type Description Default <code>transform_type</code> <code>Optional[TTransform]</code> <p>The requested transform type. Defaults to None.</p> <code>None</code> <code>values</code> <code>Optional[pd.Series]</code> <p>If values are provided the bounds are returned taking the most extreme values for the feature into account. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[List[float], List[float]]</code> <p>List of lower bound values, list of upper bound values.</p> Source code in <code>bofire/data_models/features/numerical.py</code> <pre><code>def get_bounds(\n    self,\n    transform_type: Optional[TTransform] = None,\n    values: Optional[pd.Series] = None,\n) -&gt; Tuple[List[float], List[float]]:\n    assert transform_type is None\n    if values is None:\n        return [self.lower_bound], [self.upper_bound]  # type: ignore\n    lower = min(self.lower_bound, values.min())  # type: ignore\n    upper = max(self.upper_bound, values.max())  # type: ignore\n    return [lower], [upper]  # type: ignore\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.numerical.NumericalInput.is_fixed","title":"<code>is_fixed(self)</code>","text":"<p>Method to check if the feature is fixed</p> <p>Returns:</p> Type Description <code>Boolean</code> <p>True when the feature is fixed, false otherwise.</p> Source code in <code>bofire/data_models/features/numerical.py</code> <pre><code>def is_fixed(self):\n\"\"\"Method to check if the feature is fixed\n\n    Returns:\n        Boolean: True when the feature is fixed, false otherwise.\n    \"\"\"\n    return self.lower_bound == self.upper_bound  # type: ignore\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.numerical.NumericalInput.to_unit_range","title":"<code>to_unit_range(self, values, use_real_bounds=False)</code>","text":"<p>Convert to the unit range between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>values to be transformed</p> required <code>use_real_bounds</code> <code>bool</code> <p>if True, use the bounds from the actual values else the bounds from the feature. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If lower_bound == upper bound an error is raised</p> <p>Returns:</p> Type Description <code>pd.Series</code> <p>transformed values.</p> Source code in <code>bofire/data_models/features/numerical.py</code> <pre><code>def to_unit_range(\n    self, values: Union[pd.Series, np.ndarray], use_real_bounds: bool = False\n) -&gt; Union[pd.Series, np.ndarray]:\n\"\"\"Convert to the unit range between 0 and 1.\n\n    Args:\n        values (pd.Series): values to be transformed\n        use_real_bounds (bool, optional): if True, use the bounds from the actual values else the bounds from the feature.\n            Defaults to False.\n\n    Raises:\n        ValueError: If lower_bound == upper bound an error is raised\n\n    Returns:\n        pd.Series: transformed values.\n    \"\"\"\n    if use_real_bounds:\n        lower, upper = self.get_bounds(transform_type=None, values=values)\n        lower = lower[0]\n        upper = upper[0]\n    else:\n        lower, upper = self.lower_bound, self.upper_bound  # type: ignore\n    if lower == upper:\n        raise ValueError(\"Fixed feature cannot be transformed to unit range.\")\n    valrange = upper - lower\n    return (values - lower) / valrange\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.numerical.NumericalInput.validate_candidental","title":"<code>validate_candidental(self, values)</code>","text":"<p>Validate the suggested candidates for the feature.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>suggested candidates for the feature</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>Error is raised when one of the values is not numerical.</p> <p>Returns:</p> Type Description <code>pd.Series</code> <p>the original provided candidates</p> Source code in <code>bofire/data_models/features/numerical.py</code> <pre><code>def validate_candidental(self, values: pd.Series) -&gt; pd.Series:\n\"\"\"Validate the suggested candidates for the feature.\n\n    Args:\n        values (pd.Series): suggested candidates for the feature\n\n    Raises:\n        ValueError: Error is raised when one of the values is not numerical.\n\n    Returns:\n        pd.Series: the original provided candidates\n    \"\"\"\n    if not is_numeric(values):\n        raise ValueError(\n            f\"not all values of input feature `{self.key}` are numerical\"\n        )\n    return values\n</code></pre>"},{"location":"ref-features/#bofire.data_models.features.numerical.NumericalInput.validate_experimental","title":"<code>validate_experimental(self, values, strict=False)</code>","text":"<p>Method to validate the experimental dataFrame</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>pd.Series</code> <p>A dataFrame with experiments</p> required <code>strict</code> <code>bool</code> <p>Boolean to distinguish if the occurence of fixed features in the dataset should be considered or not. Defaults to False.</p> <code>False</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>when a value is not numerical</p> <code>ValueError</code> <p>when there is no variation in a feature provided by the experimental data</p> <p>Returns:</p> Type Description <code>pd.Series</code> <p>A dataFrame with experiments</p> Source code in <code>bofire/data_models/features/numerical.py</code> <pre><code>def validate_experimental(self, values: pd.Series, strict=False) -&gt; pd.Series:\n\"\"\"Method to validate the experimental dataFrame\n\n    Args:\n        values (pd.Series): A dataFrame with experiments\n        strict (bool, optional): Boolean to distinguish if the occurence of fixed features in the dataset should be considered or not.\n            Defaults to False.\n\n    Raises:\n        ValueError: when a value is not numerical\n        ValueError: when there is no variation in a feature provided by the experimental data\n\n    Returns:\n        pd.Series: A dataFrame with experiments\n    \"\"\"\n    if not is_numeric(values):\n        raise ValueError(\n            f\"not all values of input feature `{self.key}` are numerical\"\n        )\n    if strict:\n        lower, upper = self.get_bounds(transform_type=None, values=values)\n        if lower == upper:\n            raise ValueError(\n                f\"No variation present or planned for feature {self.key}. Remove it.\"\n            )\n    return values\n</code></pre>"},{"location":"ref-mappers/","title":"Opti Mappers","text":""},{"location":"ref-objectives/","title":"Domain","text":""},{"location":"ref-objectives/#bofire.data_models.objectives.identity","title":"<code>identity</code>","text":""},{"location":"ref-objectives/#bofire.data_models.objectives.identity.IdentityObjective","title":"<code> IdentityObjective            (Objective)         </code>  <code>pydantic-model</code>","text":"<p>An objective returning the identity as reward. The return can be scaled, when a lower and upper bound are provided.</p> <p>Attributes:</p> Name Type Description <code>w</code> <code>float</code> <p>float between zero and one for weighting the objective</p> <code>bounds</code> <code>Tuple[float]</code> <p>Bound for normalizing the objective between zero and one. Defaults to (0,1).</p> Source code in <code>bofire/data_models/objectives/identity.py</code> <pre><code>class IdentityObjective(Objective):\n\"\"\"An objective returning the identity as reward.\n    The return can be scaled, when a lower and upper bound are provided.\n\n    Attributes:\n        w (float): float between zero and one for weighting the objective\n        bounds (Tuple[float], optional): Bound for normalizing the objective between zero and one. Defaults to (0,1).\n    \"\"\"\n\n    type: Literal[\"IdentityObjective\"] = \"IdentityObjective\"\n    w: TWeight = 1\n    bounds: Tuple[float, float] = (0, 1)\n\n    @property\n    def lower_bound(self) -&gt; float:\n        return self.bounds[0]\n\n    @property\n    def upper_bound(self) -&gt; float:\n        return self.bounds[1]\n\n    @root_validator(pre=False, skip_on_failure=True)\n    def validate_lower_upper(cls, values):\n\"\"\"Validation function to ensure that lower bound is always greater the upper bound\n\n        Args:\n            values (Dict): The attributes of the class\n\n        Raises:\n            ValueError: when a lower bound higher than the upper bound is passed\n\n        Returns:\n            Dict: The attributes of the class\n        \"\"\"\n        if values[\"bounds\"][0] &gt; values[\"bounds\"][1]:\n            raise ValueError(\n                f'lower bound must be &lt;= upper bound, got {values[\"lower_bound\"]} &gt; {values[\"upper_bound\"]}'\n            )\n        return values\n\n    def __call__(self, x: Union[pd.Series, np.ndarray]) -&gt; Union[pd.Series, np.ndarray]:\n\"\"\"The call function returning a reward for passed x values\n\n        Args:\n            x (np.ndarray): An array of x values\n\n        Returns:\n            np.ndarray: The identity as reward, might be normalized to the passed lower and upper bounds\n        \"\"\"\n        return (x - self.lower_bound) / (self.upper_bound - self.lower_bound)\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.identity.IdentityObjective.__call__","title":"<code>__call__(self, x)</code>  <code>special</code>","text":"<p>The call function returning a reward for passed x values</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>An array of x values</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>The identity as reward, might be normalized to the passed lower and upper bounds</p> Source code in <code>bofire/data_models/objectives/identity.py</code> <pre><code>def __call__(self, x: Union[pd.Series, np.ndarray]) -&gt; Union[pd.Series, np.ndarray]:\n\"\"\"The call function returning a reward for passed x values\n\n    Args:\n        x (np.ndarray): An array of x values\n\n    Returns:\n        np.ndarray: The identity as reward, might be normalized to the passed lower and upper bounds\n    \"\"\"\n    return (x - self.lower_bound) / (self.upper_bound - self.lower_bound)\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.identity.IdentityObjective.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-objectives/#bofire.data_models.objectives.identity.IdentityObjective.validate_lower_upper","title":"<code>validate_lower_upper(values)</code>  <code>classmethod</code>","text":"<p>Validation function to ensure that lower bound is always greater the upper bound</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Dict</code> <p>The attributes of the class</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>when a lower bound higher than the upper bound is passed</p> <p>Returns:</p> Type Description <code>Dict</code> <p>The attributes of the class</p> Source code in <code>bofire/data_models/objectives/identity.py</code> <pre><code>@root_validator(pre=False, skip_on_failure=True)\ndef validate_lower_upper(cls, values):\n\"\"\"Validation function to ensure that lower bound is always greater the upper bound\n\n    Args:\n        values (Dict): The attributes of the class\n\n    Raises:\n        ValueError: when a lower bound higher than the upper bound is passed\n\n    Returns:\n        Dict: The attributes of the class\n    \"\"\"\n    if values[\"bounds\"][0] &gt; values[\"bounds\"][1]:\n        raise ValueError(\n            f'lower bound must be &lt;= upper bound, got {values[\"lower_bound\"]} &gt; {values[\"upper_bound\"]}'\n        )\n    return values\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.identity.MaximizeObjective","title":"<code> MaximizeObjective            (IdentityObjective)         </code>  <code>pydantic-model</code>","text":"<p>Child class from the identity function without modifications, since the parent class is already defined as maximization</p> <p>Attributes:</p> Name Type Description <code>w</code> <code>float</code> <p>float between zero and one for weighting the objective</p> <code>bounds</code> <code>Tuple[float]</code> <p>Bound for normalizing the objective between zero and one. Defaults to (0,1).</p> Source code in <code>bofire/data_models/objectives/identity.py</code> <pre><code>class MaximizeObjective(IdentityObjective):\n\"\"\"Child class from the identity function without modifications, since the parent class is already defined as maximization\n\n    Attributes:\n        w (float): float between zero and one for weighting the objective\n        bounds (Tuple[float], optional): Bound for normalizing the objective between zero and one. Defaults to (0,1).\n    \"\"\"\n\n    type: Literal[\"MaximizeObjective\"] = \"MaximizeObjective\"\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.identity.MaximizeObjective.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-objectives/#bofire.data_models.objectives.identity.MinimizeObjective","title":"<code> MinimizeObjective            (IdentityObjective)         </code>  <code>pydantic-model</code>","text":"<p>Class returning the negative identity as reward.</p> <p>Attributes:</p> Name Type Description <code>w</code> <code>float</code> <p>float between zero and one for weighting the objective</p> <code>bounds</code> <code>Tuple[float]</code> <p>Bound for normalizing the objective between zero and one. Defaults to (0,1).</p> Source code in <code>bofire/data_models/objectives/identity.py</code> <pre><code>class MinimizeObjective(IdentityObjective):\n\"\"\"Class returning the negative identity as reward.\n\n    Attributes:\n        w (float): float between zero and one for weighting the objective\n        bounds (Tuple[float], optional): Bound for normalizing the objective between zero and one. Defaults to (0,1).\n    \"\"\"\n\n    type: Literal[\"MinimizeObjective\"] = \"MinimizeObjective\"\n\n    def __call__(self, x: Union[pd.Series, np.ndarray]) -&gt; Union[pd.Series, np.ndarray]:\n\"\"\"The call function returning a reward for passed x values\n\n        Args:\n            x (np.ndarray): An array of x values\n\n        Returns:\n            np.ndarray: The negative identity as reward, might be normalized to the passed lower and upper bounds\n        \"\"\"\n        return -1.0 * (x - self.lower_bound) / (self.upper_bound - self.lower_bound)\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.identity.MinimizeObjective.__call__","title":"<code>__call__(self, x)</code>  <code>special</code>","text":"<p>The call function returning a reward for passed x values</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>An array of x values</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>The negative identity as reward, might be normalized to the passed lower and upper bounds</p> Source code in <code>bofire/data_models/objectives/identity.py</code> <pre><code>def __call__(self, x: Union[pd.Series, np.ndarray]) -&gt; Union[pd.Series, np.ndarray]:\n\"\"\"The call function returning a reward for passed x values\n\n    Args:\n        x (np.ndarray): An array of x values\n\n    Returns:\n        np.ndarray: The negative identity as reward, might be normalized to the passed lower and upper bounds\n    \"\"\"\n    return -1.0 * (x - self.lower_bound) / (self.upper_bound - self.lower_bound)\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.identity.MinimizeObjective.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-objectives/#bofire.data_models.objectives.objective","title":"<code>objective</code>","text":""},{"location":"ref-objectives/#bofire.data_models.objectives.objective.ConstrainedObjective","title":"<code> ConstrainedObjective        </code>","text":"<p>This abstract class offers a convenience routine for transforming sigmoid based objectives to botorch output constraints.</p> Source code in <code>bofire/data_models/objectives/objective.py</code> <pre><code>class ConstrainedObjective:\n\"\"\"This abstract class offers a convenience routine for transforming sigmoid based objectives to botorch output constraints.\"\"\"\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.objective.Objective","title":"<code> Objective            (BaseModel)         </code>  <code>pydantic-model</code>","text":"<p>The base class for all objectives</p> Source code in <code>bofire/data_models/objectives/objective.py</code> <pre><code>class Objective(BaseModel):\n\"\"\"The base class for all objectives\"\"\"\n\n    type: str\n\n    @abstractmethod\n    def __call__(self, x: Union[pd.Series, np.ndarray]) -&gt; Union[pd.Series, np.ndarray]:\n\"\"\"Abstract method to define the call function for the class Objective\n\n        Args:\n            x (np.ndarray): An array of x values\n\n        Returns:\n            np.ndarray: The desirability of the passed x values\n        \"\"\"\n        pass\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.objective.Objective.__call__","title":"<code>__call__(self, x)</code>  <code>special</code>","text":"<p>Abstract method to define the call function for the class Objective</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>An array of x values</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>The desirability of the passed x values</p> Source code in <code>bofire/data_models/objectives/objective.py</code> <pre><code>@abstractmethod\ndef __call__(self, x: Union[pd.Series, np.ndarray]) -&gt; Union[pd.Series, np.ndarray]:\n\"\"\"Abstract method to define the call function for the class Objective\n\n    Args:\n        x (np.ndarray): An array of x values\n\n    Returns:\n        np.ndarray: The desirability of the passed x values\n    \"\"\"\n    pass\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.objective.Objective.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-objectives/#bofire.data_models.objectives.sigmoid","title":"<code>sigmoid</code>","text":""},{"location":"ref-objectives/#bofire.data_models.objectives.sigmoid.MaximizeSigmoidObjective","title":"<code> MaximizeSigmoidObjective            (SigmoidObjective)         </code>  <code>pydantic-model</code>","text":"<p>Class for a maximizing sigmoid objective</p> <p>Attributes:</p> Name Type Description <code>w</code> <code>float</code> <p>float between zero and one for weighting the objective.</p> <code>steepness</code> <code>float</code> <p>Steepness of the sigmoid function. Has to be greater than zero.</p> <code>tp</code> <code>float</code> <p>Turning point of the sigmoid function.</p> Source code in <code>bofire/data_models/objectives/sigmoid.py</code> <pre><code>class MaximizeSigmoidObjective(SigmoidObjective):\n\"\"\"Class for a maximizing sigmoid objective\n\n    Attributes:\n        w (float): float between zero and one for weighting the objective.\n        steepness (float): Steepness of the sigmoid function. Has to be greater than zero.\n        tp (float): Turning point of the sigmoid function.\n\n    \"\"\"\n\n    type: Literal[\"MaximizeSigmoidObjective\"] = \"MaximizeSigmoidObjective\"\n\n    def __call__(self, x: Union[pd.Series, np.ndarray]) -&gt; Union[pd.Series, np.ndarray]:\n\"\"\"The call function returning a sigmoid shaped reward for passed x values.\n\n        Args:\n            x (np.ndarray): An array of x values\n\n        Returns:\n            np.ndarray: A reward calculated with a sigmoid function. The stepness and the tipping point can be modified via passed arguments.\n        \"\"\"\n        return 1 / (1 + np.exp(-1 * self.steepness * (x - self.tp)))\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.sigmoid.MaximizeSigmoidObjective.__call__","title":"<code>__call__(self, x)</code>  <code>special</code>","text":"<p>The call function returning a sigmoid shaped reward for passed x values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>An array of x values</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>A reward calculated with a sigmoid function. The stepness and the tipping point can be modified via passed arguments.</p> Source code in <code>bofire/data_models/objectives/sigmoid.py</code> <pre><code>def __call__(self, x: Union[pd.Series, np.ndarray]) -&gt; Union[pd.Series, np.ndarray]:\n\"\"\"The call function returning a sigmoid shaped reward for passed x values.\n\n    Args:\n        x (np.ndarray): An array of x values\n\n    Returns:\n        np.ndarray: A reward calculated with a sigmoid function. The stepness and the tipping point can be modified via passed arguments.\n    \"\"\"\n    return 1 / (1 + np.exp(-1 * self.steepness * (x - self.tp)))\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.sigmoid.MaximizeSigmoidObjective.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-objectives/#bofire.data_models.objectives.sigmoid.MinimizeSigmoidObjective","title":"<code> MinimizeSigmoidObjective            (SigmoidObjective)         </code>  <code>pydantic-model</code>","text":"<p>Class for a minimizing a sigmoid objective</p> <p>Attributes:</p> Name Type Description <code>w</code> <code>float</code> <p>float between zero and one for weighting the objective.</p> <code>steepness</code> <code>float</code> <p>Steepness of the sigmoid function. Has to be greater than zero.</p> <code>tp</code> <code>float</code> <p>Turning point of the sigmoid function.</p> Source code in <code>bofire/data_models/objectives/sigmoid.py</code> <pre><code>class MinimizeSigmoidObjective(SigmoidObjective):\n\"\"\"Class for a minimizing a sigmoid objective\n\n    Attributes:\n        w (float): float between zero and one for weighting the objective.\n        steepness (float): Steepness of the sigmoid function. Has to be greater than zero.\n        tp (float): Turning point of the sigmoid function.\n    \"\"\"\n\n    type: Literal[\"MinimizeSigmoidObjective\"] = \"MinimizeSigmoidObjective\"\n\n    def __call__(self, x: Union[pd.Series, np.ndarray]) -&gt; Union[pd.Series, np.ndarray]:\n\"\"\"The call function returning a sigmoid shaped reward for passed x values.\n\n        Args:\n            x (np.ndarray): An array of x values\n\n        Returns:\n            np.ndarray: A reward calculated with a sigmoid function. The stepness and the tipping point can be modified via passed arguments.\n        \"\"\"\n        return 1 - 1 / (1 + np.exp(-1 * self.steepness * (x - self.tp)))\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.sigmoid.MinimizeSigmoidObjective.__call__","title":"<code>__call__(self, x)</code>  <code>special</code>","text":"<p>The call function returning a sigmoid shaped reward for passed x values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>An array of x values</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>A reward calculated with a sigmoid function. The stepness and the tipping point can be modified via passed arguments.</p> Source code in <code>bofire/data_models/objectives/sigmoid.py</code> <pre><code>def __call__(self, x: Union[pd.Series, np.ndarray]) -&gt; Union[pd.Series, np.ndarray]:\n\"\"\"The call function returning a sigmoid shaped reward for passed x values.\n\n    Args:\n        x (np.ndarray): An array of x values\n\n    Returns:\n        np.ndarray: A reward calculated with a sigmoid function. The stepness and the tipping point can be modified via passed arguments.\n    \"\"\"\n    return 1 - 1 / (1 + np.exp(-1 * self.steepness * (x - self.tp)))\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.sigmoid.MinimizeSigmoidObjective.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-objectives/#bofire.data_models.objectives.sigmoid.SigmoidObjective","title":"<code> SigmoidObjective            (Objective, ConstrainedObjective)         </code>  <code>pydantic-model</code>","text":"<p>Base class for all sigmoid shaped objectives</p> <p>Attributes:</p> Name Type Description <code>w</code> <code>float</code> <p>float between zero and one for weighting the objective.</p> <code>steepness</code> <code>float</code> <p>Steepness of the sigmoid function. Has to be greater than zero.</p> <code>tp</code> <code>float</code> <p>Turning point of the sigmoid function.</p> Source code in <code>bofire/data_models/objectives/sigmoid.py</code> <pre><code>class SigmoidObjective(Objective, ConstrainedObjective):\n\"\"\"Base class for all sigmoid shaped objectives\n\n    Attributes:\n        w (float): float between zero and one for weighting the objective.\n        steepness (float): Steepness of the sigmoid function. Has to be greater than zero.\n        tp (float): Turning point of the sigmoid function.\n    \"\"\"\n\n    steepness: TGt0\n    tp: float\n    w: TWeight = 1\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.sigmoid.SigmoidObjective.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-objectives/#bofire.data_models.objectives.target","title":"<code>target</code>","text":""},{"location":"ref-objectives/#bofire.data_models.objectives.target.CloseToTargetObjective","title":"<code> CloseToTargetObjective            (Objective)         </code>  <code>pydantic-model</code>","text":"<p>Optimize towards a target value. It can be used as objective in multiobjective scenarios.</p> <p>Attributes:</p> Name Type Description <code>w</code> <code>float</code> <p>float between zero and one for weighting the objective.</p> <code>target_value</code> <code>float</code> <p>target value that should be reached.</p> <code>exponent</code> <code>float</code> <p>the exponent of the expression.</p> Source code in <code>bofire/data_models/objectives/target.py</code> <pre><code>class CloseToTargetObjective(Objective):\n\"\"\"Optimize towards a target value. It can be used as objective\n    in multiobjective scenarios.\n\n    Attributes:\n        w (float): float between zero and one for weighting the objective.\n        target_value (float): target value that should be reached.\n        exponent (float): the exponent of the expression.\n    \"\"\"\n\n    type: Literal[\"CloseToTargetObjective\"] = \"CloseToTargetObjective\"\n    w: TWeight = 1\n    target_value: float\n    exponent: float\n\n    def __call__(self, x: Union[pd.Series, np.ndarray]) -&gt; Union[pd.Series, np.ndarray]:\n        return -1 * (np.abs(x - self.target_value) ** self.exponent)\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.target.CloseToTargetObjective.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-objectives/#bofire.data_models.objectives.target.TargetObjective","title":"<code> TargetObjective            (Objective, ConstrainedObjective)         </code>  <code>pydantic-model</code>","text":"<p>Class for objectives for optimizing towards a target value</p> <p>Attributes:</p> Name Type Description <code>w</code> <code>float</code> <p>float between zero and one for weighting the objective.</p> <code>target_value</code> <code>float</code> <p>target value that should be reached.</p> <code>tolerance</code> <code>float</code> <p>Tolerance for reaching the target. Has to be greater than zero.</p> <code>steepness</code> <code>float</code> <p>Steepness of the sigmoid function. Has to be greater than zero.</p> Source code in <code>bofire/data_models/objectives/target.py</code> <pre><code>class TargetObjective(Objective, ConstrainedObjective):\n\"\"\"Class for objectives for optimizing towards a target value\n\n    Attributes:\n        w (float): float between zero and one for weighting the objective.\n        target_value (float): target value that should be reached.\n        tolerance (float): Tolerance for reaching the target. Has to be greater than zero.\n        steepness (float): Steepness of the sigmoid function. Has to be greater than zero.\n\n    \"\"\"\n\n    type: Literal[\"TargetObjective\"] = \"TargetObjective\"\n    w: TWeight = 1\n    target_value: float\n    tolerance: TGe0\n    steepness: TGt0\n\n    def __call__(self, x: Union[pd.Series, np.ndarray]) -&gt; Union[pd.Series, np.ndarray]:\n\"\"\"The call function returning a reward for passed x values.\n\n        Args:\n            x (np.array): An array of x values\n\n        Returns:\n            np.array: An array of reward values calculated by the product of two sigmoidal shaped functions resulting in a maximum at the target value.\n        \"\"\"\n        return (\n            1\n            / (\n                1\n                + np.exp(\n                    -1 * self.steepness * (x - (self.target_value - self.tolerance))\n                )\n            )\n            * (\n                1\n                - 1\n                / (\n                    1.0\n                    + np.exp(\n                        -1 * self.steepness * (x - (self.target_value + self.tolerance))\n                    )\n                )\n            )\n        )\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.target.TargetObjective.__call__","title":"<code>__call__(self, x)</code>  <code>special</code>","text":"<p>The call function returning a reward for passed x values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.array</code> <p>An array of x values</p> required <p>Returns:</p> Type Description <code>np.array</code> <p>An array of reward values calculated by the product of two sigmoidal shaped functions resulting in a maximum at the target value.</p> Source code in <code>bofire/data_models/objectives/target.py</code> <pre><code>def __call__(self, x: Union[pd.Series, np.ndarray]) -&gt; Union[pd.Series, np.ndarray]:\n\"\"\"The call function returning a reward for passed x values.\n\n    Args:\n        x (np.array): An array of x values\n\n    Returns:\n        np.array: An array of reward values calculated by the product of two sigmoidal shaped functions resulting in a maximum at the target value.\n    \"\"\"\n    return (\n        1\n        / (\n            1\n            + np.exp(\n                -1 * self.steepness * (x - (self.target_value - self.tolerance))\n            )\n        )\n        * (\n            1\n            - 1\n            / (\n                1.0\n                + np.exp(\n                    -1 * self.steepness * (x - (self.target_value + self.tolerance))\n                )\n            )\n        )\n    )\n</code></pre>"},{"location":"ref-objectives/#bofire.data_models.objectives.target.TargetObjective.__json_encoder__","title":"<code>__json_encoder__(obj)</code>  <code>special</code> <code>staticmethod</code>","text":"<p>partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.</p>"},{"location":"ref-utils/","title":"Utils","text":""},{"location":"ref-utils/#bofire.utils.cheminformatics","title":"<code>cheminformatics</code>","text":""},{"location":"ref-utils/#bofire.utils.cheminformatics.smiles2bag_of_characters","title":"<code>smiles2bag_of_characters(smiles, max_ngram=5)</code>","text":"<p>Transforms list of smiles to bag of characters.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>List[str]</code> <p>List of smiles</p> required <code>max_ngram</code> <code>int</code> <p>Maximal ngram value. Defaults to 5.</p> <code>5</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Array holding the bag of characters.</p> Source code in <code>bofire/utils/cheminformatics.py</code> <pre><code>def smiles2bag_of_characters(smiles: List[str], max_ngram: int = 5) -&gt; np.ndarray:\n\"\"\"Transforms list of smiles to bag of characters.\n\n    Args:\n        smiles (List[str]): List of smiles\n        max_ngram (int, optional): Maximal ngram value. Defaults to 5.\n\n    Returns:\n        np.ndarray: Array holding the bag of characters.\n    \"\"\"\n    for smi in smiles:\n        smiles2mol(smi)\n    cv = CountVectorizer(ngram_range=(1, max_ngram), analyzer=\"char\", lowercase=False)\n    return cv.fit_transform(smiles).toarray()\n</code></pre>"},{"location":"ref-utils/#bofire.utils.cheminformatics.smiles2fingerprints","title":"<code>smiles2fingerprints(smiles, bond_radius=5, n_bits=2048)</code>","text":"<p>Transforms a list of smiles to an array of morgan fingerprints.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>List[str]</code> <p>List of smiles</p> required <code>bond_radius</code> <code>int</code> <p>Bond radius to use. Defaults to 5.</p> <code>5</code> <code>n_bits</code> <code>int</code> <p>Number of bits. Defaults to 2048.</p> <code>2048</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Numpy array holding the fingerprints</p> Source code in <code>bofire/utils/cheminformatics.py</code> <pre><code>def smiles2fingerprints(\n    smiles: List[str], bond_radius: int = 5, n_bits: int = 2048\n) -&gt; np.ndarray:\n\"\"\"Transforms a list of smiles to an array of morgan fingerprints.\n\n    Args:\n        smiles (List[str]): List of smiles\n        bond_radius (int, optional): Bond radius to use. Defaults to 5.\n        n_bits (int, optional): Number of bits. Defaults to 2048.\n\n    Returns:\n        np.ndarray: Numpy array holding the fingerprints\n    \"\"\"\n    rdkit_mols = [smiles2mol(m) for m in smiles]\n    fps = [\n        AllChem.GetMorganFingerprintAsBitVect(  # type: ignore\n            mol, radius=bond_radius, nBits=n_bits\n        )\n        for mol in rdkit_mols\n    ]\n\n    return np.asarray(fps)\n</code></pre>"},{"location":"ref-utils/#bofire.utils.cheminformatics.smiles2fragments","title":"<code>smiles2fragments(smiles)</code>","text":"<p>Transforms smiles to an array of fragments.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>List[str]</code> <p>List of smiles</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Array holding the fragment information.</p> Source code in <code>bofire/utils/cheminformatics.py</code> <pre><code>def smiles2fragments(smiles: List[str]) -&gt; np.ndarray:\n\"\"\"Transforms smiles to an array of fragments.\n\n    Args:\n        smiles (List[str]): List of smiles\n\n    Returns:\n        np.ndarray: Array holding the fragment information.\n    \"\"\"\n    # descList[115:] contains fragment-based features only\n    # (https://www.rdkit.org/docs/source/rdkit.Chem.Fragments.html)\n    # Update: in the new RDKit version the indices are [124:]\n    fragments = {d[0]: d[1] for d in Descriptors.descList[124:]}\n    frags = np.zeros((len(smiles), len(fragments)))\n    for i in range(len(smiles)):\n        mol = smiles2mol(smiles[i])\n        features = [fragments[d](mol) for d in fragments]\n        frags[i, :] = features\n\n    return frags\n</code></pre>"},{"location":"ref-utils/#bofire.utils.cheminformatics.smiles2mol","title":"<code>smiles2mol(smiles)</code>","text":"<p>Transforms a smiles string to an rdkit mol object.</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>str</code> <p>Smiles string.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If string is not a valid smiles.</p> <p>Returns:</p> Type Description <code>rdkit.Mol</code> <p>rdkit.mol object</p> Source code in <code>bofire/utils/cheminformatics.py</code> <pre><code>def smiles2mol(smiles: str):\n\"\"\"Transforms a smiles string to an rdkit mol object.\n\n    Args:\n        smiles (str): Smiles string.\n\n    Raises:\n        ValueError: If string is not a valid smiles.\n\n    Returns:\n        rdkit.Mol: rdkit.mol object\n    \"\"\"\n    mol = MolFromSmiles(smiles)\n    if mol is None:\n        raise ValueError(f\"{smiles} is not a valid smiles string.\")\n    return mol\n</code></pre>"},{"location":"ref-utils/#bofire.utils.doe","title":"<code>doe</code>","text":""},{"location":"ref-utils/#bofire.utils.doe.get_confounding_matrix","title":"<code>get_confounding_matrix(inputs, design, powers=None, interactions=None)</code>","text":"<p>Analyzes the confounding of a design and returns the confounding matrix.</p> <p>Only takes continuous features into account.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Inputs</code> <p>Input features.</p> required <code>design</code> <code>pd.DataFrame</code> <p>Design matrix.</p> required <code>powers</code> <code>List[int]</code> <p>List of powers of the individual factors/features that should be considered. Integers has to be larger than 1. Defaults to [].</p> <code>None</code> <code>interactions</code> <code>List[int]</code> <p>List with interaction levels to be considered. Integers has to be larger than 1. Defaults to [2].</p> <code>None</code> <p>Returns:</p> Type Description <code>_type_</code> <p>description</p> Source code in <code>bofire/utils/doe.py</code> <pre><code>def get_confounding_matrix(\n    inputs: Inputs,\n    design: pd.DataFrame,\n    powers: Optional[List[int]] = None,\n    interactions: Optional[List[int]] = None,\n):\n\"\"\"Analyzes the confounding of a design and returns the confounding matrix.\n\n    Only takes continuous features into account.\n\n    Args:\n        inputs (Inputs): Input features.\n        design (pd.DataFrame): Design matrix.\n        powers (List[int], optional): List of powers of the individual factors/features that should be considered.\n            Integers has to be larger than 1. Defaults to [].\n        interactions (List[int], optional): List with interaction levels to be considered.\n            Integers has to be larger than 1. Defaults to [2].\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    if len(inputs.get(CategoricalInput)) &gt; 0:\n        warnings.warn(\"Categorical input features will be ignored.\")\n\n    keys = inputs.get_keys(ContinuousInput)\n    scaler = MinMaxScaler(feature_range=(-1, 1))\n    scaled_design = pd.DataFrame(\n        data=scaler.fit_transform(design[keys]),\n        columns=keys,\n    )\n\n    # add powers\n    if powers is not None:\n        for p in powers:\n            assert p &gt; 1, \"Power has to be at least of degree two.\"\n            for key in keys:\n                scaled_design[f\"{key}**{p}\"] = scaled_design[key] ** p\n\n    # add interactions\n    if interactions is None:\n        interactions = [2]\n\n    for i in interactions:\n        assert i &gt; 1, \"Interaction has to be at least of degree two.\"\n        assert i &lt; len(keys) + 1, f\"Interaction has to be smaller than {len(keys)+1}.\"\n        for combi in itertools.combinations(keys, i):\n            scaled_design[\":\".join(combi)] = scaled_design[list(combi)].prod(axis=1)\n\n    return scaled_design.corr()\n</code></pre>"},{"location":"ref-utils/#bofire.utils.multiobjective","title":"<code>multiobjective</code>","text":""},{"location":"ref-utils/#bofire.utils.multiobjective.get_ref_point_mask","title":"<code>get_ref_point_mask(domain, output_feature_keys=None)</code>","text":"<p>Method to get a mask for the reference points taking into account if we want to maximize or minimize an objective. In case it is maximize the value in the mask is 1, in case we want to minimize it is -1.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>Domain for which the mask should be generated.</p> required <code>output_feature_keys</code> <code>Optional[list]</code> <p>Name of output feature keys that should be considered in the mask. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>description</p> Source code in <code>bofire/utils/multiobjective.py</code> <pre><code>def get_ref_point_mask(\n    domain: Domain, output_feature_keys: Optional[list] = None\n) -&gt; np.ndarray:\n\"\"\"Method to get a mask for the reference points taking into account if we\n    want to maximize or minimize an objective. In case it is maximize the value\n    in the mask is 1, in case we want to minimize it is -1.\n\n    Args:\n        domain (Domain): Domain for which the mask should be generated.\n        output_feature_keys (Optional[list], optional): Name of output feature keys\n            that should be considered in the mask. Defaults to None.\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    if output_feature_keys is None:\n        output_feature_keys = domain.outputs.get_keys_by_objective(\n            includes=[MaximizeObjective, MinimizeObjective, CloseToTargetObjective]\n        )\n    if len(output_feature_keys) &lt; 2:\n        raise ValueError(\"At least two output features have to be provided.\")\n    mask = []\n    for key in output_feature_keys:\n        feat = domain.get_feature(key)\n        if isinstance(feat.objective, MaximizeObjective):  # type: ignore\n            mask.append(1.0)\n        elif isinstance(feat.objective, MinimizeObjective):  # type: ignore\n            mask.append(-1.0)\n        elif isinstance(feat.objective, CloseToTargetObjective):  # type: ignore\n            mask.append(-1.0)\n        else:\n            raise ValueError(\n                \"Only `MaximizeObjective` and `MinimizeObjective` supported\"\n            )\n    return np.array(mask)\n</code></pre>"},{"location":"ref-utils/#bofire.utils.reduce","title":"<code>reduce</code>","text":""},{"location":"ref-utils/#bofire.utils.reduce.AffineTransform","title":"<code> AffineTransform        </code>","text":"<p>Class to switch back and forth from the reduced to the original domain.</p> Source code in <code>bofire/utils/reduce.py</code> <pre><code>class AffineTransform:\n\"\"\"Class to switch back and forth from the reduced to the original domain.\"\"\"\n\n    def __init__(self, equalities: List[Tuple[str, List[str], List[float]]]):\n\"\"\"Initializes a `AffineTransformation` object.\n\n        Args:\n            equalities (List[Tuple[str,List[str],List[float]]]): List of equalities. Every equality\n                is defined as a tuple, in which the first entry is the key of the reduced feature, the second\n                one is a list of feature keys that can be used to compute the feature and the third list of floats\n                are the corresponding coefficients.\n        \"\"\"\n        self.equalities = equalities\n\n    def augment_data(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Restore the eliminated features in a dataframe\n\n        Args:\n            data (pd.DataFrame): Dataframe that should be restored.\n\n        Returns:\n            pd.DataFrame: Restored dataframe\n        \"\"\"\n        if len(self.equalities) == 0:\n            return data\n        data = data.copy()\n        for name_lhs, names_rhs, coeffs in self.equalities:\n            data[name_lhs] = coeffs[-1]\n            for i, name in enumerate(names_rhs):\n                data[name_lhs] += coeffs[i] * data[name]\n        return data\n\n    def drop_data(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Drop eliminated features from a dataframe.\n\n        Args:\n            data (pd.DataFrame): Dataframe with features to be dropped.\n\n        Returns:\n            pd.DataFrame: Reduced dataframe.\n        \"\"\"\n        if len(self.equalities) == 0:\n            return data\n        drop = []\n        for name_lhs, _, _ in self.equalities:\n            if name_lhs in data.columns:\n                drop.append(name_lhs)\n        return data.drop(columns=drop)\n</code></pre>"},{"location":"ref-utils/#bofire.utils.reduce.AffineTransform.__init__","title":"<code>__init__(self, equalities)</code>  <code>special</code>","text":"<p>Initializes a <code>AffineTransformation</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>equalities</code> <code>List[Tuple[str,List[str],List[float]]]</code> <p>List of equalities. Every equality is defined as a tuple, in which the first entry is the key of the reduced feature, the second one is a list of feature keys that can be used to compute the feature and the third list of floats are the corresponding coefficients.</p> required Source code in <code>bofire/utils/reduce.py</code> <pre><code>def __init__(self, equalities: List[Tuple[str, List[str], List[float]]]):\n\"\"\"Initializes a `AffineTransformation` object.\n\n    Args:\n        equalities (List[Tuple[str,List[str],List[float]]]): List of equalities. Every equality\n            is defined as a tuple, in which the first entry is the key of the reduced feature, the second\n            one is a list of feature keys that can be used to compute the feature and the third list of floats\n            are the corresponding coefficients.\n    \"\"\"\n    self.equalities = equalities\n</code></pre>"},{"location":"ref-utils/#bofire.utils.reduce.AffineTransform.augment_data","title":"<code>augment_data(self, data)</code>","text":"<p>Restore the eliminated features in a dataframe</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>Dataframe that should be restored.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Restored dataframe</p> Source code in <code>bofire/utils/reduce.py</code> <pre><code>def augment_data(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Restore the eliminated features in a dataframe\n\n    Args:\n        data (pd.DataFrame): Dataframe that should be restored.\n\n    Returns:\n        pd.DataFrame: Restored dataframe\n    \"\"\"\n    if len(self.equalities) == 0:\n        return data\n    data = data.copy()\n    for name_lhs, names_rhs, coeffs in self.equalities:\n        data[name_lhs] = coeffs[-1]\n        for i, name in enumerate(names_rhs):\n            data[name_lhs] += coeffs[i] * data[name]\n    return data\n</code></pre>"},{"location":"ref-utils/#bofire.utils.reduce.AffineTransform.drop_data","title":"<code>drop_data(self, data)</code>","text":"<p>Drop eliminated features from a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>pd.DataFrame</code> <p>Dataframe with features to be dropped.</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>Reduced dataframe.</p> Source code in <code>bofire/utils/reduce.py</code> <pre><code>def drop_data(self, data: pd.DataFrame) -&gt; pd.DataFrame:\n\"\"\"Drop eliminated features from a dataframe.\n\n    Args:\n        data (pd.DataFrame): Dataframe with features to be dropped.\n\n    Returns:\n        pd.DataFrame: Reduced dataframe.\n    \"\"\"\n    if len(self.equalities) == 0:\n        return data\n    drop = []\n    for name_lhs, _, _ in self.equalities:\n        if name_lhs in data.columns:\n            drop.append(name_lhs)\n    return data.drop(columns=drop)\n</code></pre>"},{"location":"ref-utils/#bofire.utils.reduce.adjust_boundary","title":"<code>adjust_boundary(feature, coef, rhs)</code>","text":"<p>Adjusts the boundaries of a feature.</p> <p>Parameters:</p> Name Type Description Default <code>feature</code> <code>ContinuousInput</code> <p>Feature to be adjusted.</p> required <code>coef</code> <code>float</code> <p>Coefficient.</p> required <code>rhs</code> <code>float</code> <p>Right-hand-side of the constraint.</p> required Source code in <code>bofire/utils/reduce.py</code> <pre><code>def adjust_boundary(feature: ContinuousInput, coef: float, rhs: float):\n\"\"\"Adjusts the boundaries of a feature.\n\n    Args:\n        feature (ContinuousInput): Feature to be adjusted.\n        coef (float): Coefficient.\n        rhs (float): Right-hand-side of the constraint.\n    \"\"\"\n    boundary = rhs / coef\n    if coef &gt; 0:\n        if boundary &gt; feature.lower_bound:\n            feature.bounds = (boundary, feature.upper_bound)\n    else:\n        if boundary &lt; feature.upper_bound:\n            feature.bounds = (feature.lower_bound, boundary)\n</code></pre>"},{"location":"ref-utils/#bofire.utils.reduce.check_domain_for_reduction","title":"<code>check_domain_for_reduction(domain)</code>","text":"<p>Check if the reduction can be applied or if a trivial case is present.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>Domain to be checked.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if reducable, else False.</p> Source code in <code>bofire/utils/reduce.py</code> <pre><code>def check_domain_for_reduction(domain: Domain) -&gt; bool:\n\"\"\"Check if the reduction can be applied or if a trivial case is present.\n\n    Args:\n        domain (Domain): Domain to be checked.\n    Returns:\n        bool: True if reducable, else False.\n    \"\"\"\n    # are there any constraints?\n    if len(domain.constraints) == 0:\n        return False\n\n    # are there any linear equality constraints?\n    linear_equalities = domain.constraints.get(LinearEqualityConstraint)\n    if len(linear_equalities) == 0:\n        return False\n\n    # are there no NChooseKConstraint constraints?\n    if len(domain.constraints.get([NChooseKConstraint])) &gt; 0:\n        return False\n\n    # are there continuous inputs\n    continuous_inputs = domain.get_features(ContinuousInput)\n    if len(continuous_inputs) == 0:\n        return False\n\n    # check that equality constraints only contain continuous inputs\n    for c in linear_equalities:\n        assert isinstance(c, LinearConstraint)\n        for feat in c.features:\n            if feat not in domain.get_feature_keys(ContinuousInput):\n                return False\n    return True\n</code></pre>"},{"location":"ref-utils/#bofire.utils.reduce.check_existence_of_solution","title":"<code>check_existence_of_solution(A_aug)</code>","text":"<p>Given an augmented coefficient matrix this function determines the existence (and uniqueness) of solution using the rank theorem.</p> Source code in <code>bofire/utils/reduce.py</code> <pre><code>def check_existence_of_solution(A_aug):\n\"\"\"Given an augmented coefficient matrix this function determines the existence (and uniqueness) of solution using the rank theorem.\"\"\"\n    A = A_aug[:, :-1]\n    b = A_aug[:, -1]\n    len_inputs = np.shape(A)[1]\n\n    # catch special cases\n    rk_A_aug = np.linalg.matrix_rank(A_aug)\n    rk_A = np.linalg.matrix_rank(A)\n\n    if rk_A == rk_A_aug:\n        if rk_A &lt; len_inputs:\n            return  # all good\n        else:\n            x = np.linalg.solve(A, b)\n            raise Exception(\n                f\"There is a unique solution x for the linear equality constraints: x={x}\"\n            )\n    elif rk_A &lt; rk_A_aug:\n        raise Exception(\n            \"There is no solution fulfilling the linear equality constraints.\"\n        )\n</code></pre>"},{"location":"ref-utils/#bofire.utils.reduce.reduce_domain","title":"<code>reduce_domain(domain)</code>","text":"<p>Reduce a domain with linear equality constraints to a subdomain where linear equality constraints are eliminated.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>Domain to be reduced.</p> required <p>Returns:</p> Type Description <code>Tuple[Domain, AffineTransform]</code> <p>reduced domain and the according transformation to switch between the     reduced and orginal domain.</p> Source code in <code>bofire/utils/reduce.py</code> <pre><code>def reduce_domain(domain: Domain) -&gt; Tuple[Domain, AffineTransform]:\n\"\"\"Reduce a domain with linear equality constraints to a subdomain where linear equality constraints are eliminated.\n\n    Args:\n        domain (Domain): Domain to be reduced.\n\n    Returns:\n        Tuple[Domain, AffineTransform]: reduced domain and the according transformation to switch between the\n            reduced and orginal domain.\n    \"\"\"\n    # check if the domain can be reduced\n    if not check_domain_for_reduction(domain):\n        return domain, AffineTransform([])\n\n    # find linear equality constraints\n    linear_equalities = domain.constraints.get(LinearEqualityConstraint)\n    other_constraints = domain.constraints.get(\n        Constraint, excludes=[LinearEqualityConstraint]\n    )\n\n    # only consider continuous inputs\n    continuous_inputs = [\n        cast(ContinuousInput, f) for f in domain.get_features(ContinuousInput)\n    ]\n    other_inputs = domain.inputs.get(Input, excludes=[ContinuousInput])\n\n    # assemble Matrix A from equality constraints\n    N = len(linear_equalities)\n    M = len(continuous_inputs) + 1\n    names = np.concatenate(([feat.key for feat in continuous_inputs], [\"rhs\"]))\n\n    A_aug = pd.DataFrame(data=np.zeros(shape=(N, M)), columns=names)\n\n    for i in range(len(linear_equalities)):\n        c = linear_equalities[i]\n        assert isinstance(c, LinearEqualityConstraint)\n        A_aug.loc[i, c.features] = c.coefficients  # type: ignore\n        A_aug.loc[i, \"rhs\"] = c.rhs\n    A_aug = A_aug.values\n\n    # catch special cases\n    check_existence_of_solution(A_aug)\n\n    # bring A_aug to reduced row-echelon form\n    A_aug_rref, pivots = rref(A_aug)\n    pivots = np.array(pivots)\n    A_aug_rref = np.array(A_aug_rref).astype(np.float64)\n\n    # formulate box bounds as linear inequality constraints in matrix form\n    B = np.zeros(shape=(2 * (M - 1), M))\n    B[: M - 1, : M - 1] = np.eye(M - 1)\n    B[M - 1 :, : M - 1] = -np.eye(M - 1)\n\n    B[: M - 1, -1] = np.array([feat.upper_bound for feat in continuous_inputs])\n    B[M - 1 :, -1] = -1.0 * np.array([feat.lower_bound for feat in continuous_inputs])\n\n    # eliminate columns with pivot element\n    for i in range(len(pivots)):\n        p = pivots[i]\n        B[p, :] -= A_aug_rref[i, :]\n        B[p + M - 1, :] += A_aug_rref[i, :]\n\n    # build up reduced domain\n    _domain = Domain.construct(\n        # _fields_set = {\"inputs\", \"outputs\", \"constraints\"}\n        inputs=deepcopy(other_inputs),\n        outputs=deepcopy(domain.outputs),\n        constraints=deepcopy(other_constraints),\n    )\n    new_inputs = [\n        deepcopy(feat) for i, feat in enumerate(continuous_inputs) if i not in pivots\n    ]\n    all_inputs = _domain.inputs + new_inputs\n    assert isinstance(all_inputs, Inputs)\n    _domain.inputs = all_inputs\n\n    constraints: List[AnyConstraint] = []\n    for i in pivots:\n        # reduce equation system of upper bounds\n        ind = np.where(B[i, :-1] != 0)[0]\n        if len(ind) &gt; 0 and B[i, -1] &lt; np.inf:\n            if len(list(names[ind])) &gt; 1:\n                c = LinearInequalityConstraint.from_greater_equal(\n                    features=list(names[ind]),\n                    coefficients=(-1.0 * B[i, ind]).tolist(),\n                    rhs=B[i, -1] * -1.0,\n                )\n                constraints.append(c)\n            else:\n                key = names[ind][0]\n                feat = cast(ContinuousInput, _domain.get_feature(key))\n                adjust_boundary(feat, (-1.0 * B[i, ind])[0], B[i, -1] * -1.0)\n        else:\n            if B[i, -1] &lt; -1e-16:\n                raise Exception(\"There is no solution that fulfills the constraints.\")\n\n        # reduce equation system of lower bounds\n        ind = np.where(B[i + M - 1, :-1] != 0)[0]\n        if len(ind) &gt; 0 and B[i + M - 1, -1] &lt; np.inf:\n            if len(list(names[ind])) &gt; 1:\n                c = LinearInequalityConstraint.from_greater_equal(\n                    features=list(names[ind]),\n                    coefficients=(-1.0 * B[i + M - 1, ind]).tolist(),\n                    rhs=B[i + M - 1, -1] * -1.0,\n                )\n                constraints.append(c)\n            else:\n                key = names[ind][0]\n                feat = cast(ContinuousInput, _domain.get_feature(key))\n                adjust_boundary(\n                    feat,\n                    (-1.0 * B[i + M - 1, ind])[0],\n                    B[i + M - 1, -1] * -1.0,\n                )\n        else:\n            if B[i + M - 1, -1] &lt; -1e-16:\n                raise Exception(\"There is no solution that fulfills the constraints.\")\n\n    if len(constraints) &gt; 0:\n        _domain._set_constraints_unvalidated(_domain.constraints + constraints)\n\n    # assemble equalities\n    _equalities = []\n    for i in range(len(pivots)):\n        name_lhs = names[pivots[i]]\n        names_rhs = []\n        coeffs = []\n\n        for j in range(len(names) - 1):\n            if A_aug_rref[i, j] != 0 and j != pivots[i]:\n                coeffs.append(-A_aug_rref[i, j])\n                names_rhs.append(names[j])\n\n        coeffs.append(A_aug_rref[i, -1])\n\n        _equalities.append((name_lhs, names_rhs, coeffs))\n\n    trafo = AffineTransform(_equalities)\n    # remove remaining dependencies of eliminated inputs from the problem\n    _domain = remove_eliminated_inputs(_domain, trafo)\n    return _domain, trafo\n</code></pre>"},{"location":"ref-utils/#bofire.utils.reduce.remove_eliminated_inputs","title":"<code>remove_eliminated_inputs(domain, transform)</code>","text":"<p>Eliminates remaining occurences of eliminated inputs in linear constraints.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>Domain in which the linear constraints should be purged.</p> required <code>transform</code> <code>AffineTransform</code> <p>Affine transformation object that defines the obsolete features.</p> required <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If feature occurs in a constraint different from a linear one.</p> <p>Returns:</p> Type Description <code>Domain</code> <p>Purged domain.</p> Source code in <code>bofire/utils/reduce.py</code> <pre><code>def remove_eliminated_inputs(domain: Domain, transform: AffineTransform) -&gt; Domain:\n\"\"\"Eliminates remaining occurences of eliminated inputs in linear constraints.\n\n    Args:\n        domain (Domain): Domain in which the linear constraints should be purged.\n        transform (AffineTransform): Affine transformation object that defines the obsolete features.\n\n    Raises:\n        ValueError: If feature occurs in a constraint different from a linear one.\n\n    Returns:\n        Domain: Purged domain.\n    \"\"\"\n    inputs_names = domain.get_feature_keys()\n    M = len(inputs_names)\n\n    # write the equalities for the backtransformation into one matrix\n    inputs_dict = {inputs_names[i]: i for i in range(M)}\n\n    # build up dict from domain.equalities e.g. {\"xi1\": [coeff(xj1), ..., coeff(xjn)], ... \"xik\":...}\n    coeffs_dict = {}\n    for e in transform.equalities:\n        coeffs = np.zeros(M + 1)\n        for j, name in enumerate(e[1]):\n            coeffs[inputs_dict[name]] = e[2][j]\n        coeffs[-1] = e[2][-1]\n        coeffs_dict[e[0]] = coeffs\n\n    constraints = []\n    for c in domain.constraints.get():\n        # Nonlinear constraints not supported\n        if not isinstance(c, LinearConstraint):\n            raise ValueError(\n                \"Elimination of variables is only supported for LinearEquality and LinearInequality constraints.\"\n            )\n\n        # no changes, if the constraint does not contain eliminated inputs\n        elif all(name in inputs_names for name in c.features):\n            constraints.append(c)\n\n        # remove inputs from the constraint that were eliminated from the inputs before\n        else:\n            totally_removed = False\n            _features = np.array(inputs_names)\n            _rhs = c.rhs\n\n            # create new lhs and rhs from the old one and knowledge from problem._equalities\n            _coefficients = np.zeros(M)\n            for j, name in enumerate(c.features):\n                if name in inputs_names:\n                    _coefficients[inputs_dict[name]] += c.coefficients[j]\n                else:\n                    _coefficients += c.coefficients[j] * coeffs_dict[name][:-1]\n                    _rhs -= c.coefficients[j] * coeffs_dict[name][-1]\n\n            _features = _features[np.abs(_coefficients) &gt; 1e-16]\n            _coefficients = _coefficients[np.abs(_coefficients) &gt; 1e-16]\n            _c = None\n            if isinstance(c, LinearEqualityConstraint):\n                if len(_features) &gt; 1:\n                    _c = LinearEqualityConstraint(\n                        features=_features.tolist(),\n                        coefficients=_coefficients.tolist(),\n                        rhs=_rhs,\n                    )\n                elif len(_features) == 0:\n                    totally_removed = True\n                else:\n                    feat: ContinuousInput = ContinuousInput(\n                        **domain.get_feature(_features[0]).dict()\n                    )\n                    feat.bounds = (_coefficients[0], _coefficients[0])\n                    totally_removed = True\n            else:\n                if len(_features) &gt; 1:\n                    _c = LinearInequalityConstraint(\n                        features=_features.tolist(),\n                        coefficients=_coefficients.tolist(),\n                        rhs=_rhs,\n                    )\n                elif len(_features) == 0:\n                    totally_removed = True\n                else:\n                    feat = cast(ContinuousInput, domain.get_feature(_features[0]))\n                    adjust_boundary(feat, _coefficients[0], _rhs)\n                    totally_removed = True\n\n            # check if constraint is always fulfilled/not fulfilled\n            if not totally_removed:\n                assert _c is not None\n                if len(_c.features) == 0 and _c.rhs &gt;= 0:\n                    pass\n                elif len(_c.features) == 0 and _c.rhs &lt; 0:\n                    raise Exception(\"Linear constraints cannot be fulfilled.\")\n                elif np.isinf(_c.rhs):\n                    pass\n                else:\n                    constraints.append(_c)\n    domain.constraints = Constraints(constraints=constraints)\n    return domain\n</code></pre>"},{"location":"ref-utils/#bofire.utils.reduce.rref","title":"<code>rref(A, tol=1e-08)</code>","text":"<p>Computes the reduced row echelon form of a Matrix</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>ndarray</code> <p>2d array representing a matrix.</p> required <code>tol</code> <code>float</code> <p>tolerance for rounding to 0. Defaults to 1e-8.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>Tuple[numpy.ndarray, List[int]]</code> <p>(A_rref, pivots), where A_rref is the reduced row echelon form of A and pivots is a numpy array containing the pivot columns of A_rref</p> Source code in <code>bofire/utils/reduce.py</code> <pre><code>def rref(A: np.ndarray, tol: float = 1e-8) -&gt; Tuple[np.ndarray, List[int]]:\n\"\"\"Computes the reduced row echelon form of a Matrix\n\n    Args:\n        A (ndarray): 2d array representing a matrix.\n        tol (float, optional): tolerance for rounding to 0. Defaults to 1e-8.\n\n    Returns:\n        (A_rref, pivots), where A_rref is the reduced row echelon form of A and pivots\n        is a numpy array containing the pivot columns of A_rref\n    \"\"\"\n    A = np.array(A, dtype=np.float64)\n    n, m = np.shape(A)\n\n    col = 0\n    row = 0\n    pivots = []\n\n    for col in range(m):\n        # does a pivot element exist?\n        if all(np.abs(A[row:, col]) &lt; tol):\n            pass\n        # if yes: start elimination\n        else:\n            pivots.append(col)\n            max_row = np.argmax(np.abs(A[row:, col])) + row\n            # switch to most stable row\n            A[[row, max_row], :] = A[[max_row, row], :]  # type: ignore\n            # normalize row\n            A[row, :] /= A[row, col]\n            # eliminate other elements from column\n            for r in range(n):\n                if r != row:\n                    A[r, :] -= A[r, col] / A[row, col] * A[row, :]\n            row += 1\n\n    prec = int(-np.log10(tol))\n    return np.round(A, prec), pivots\n</code></pre>"},{"location":"ref-utils/#bofire.utils.subdomain","title":"<code>subdomain</code>","text":""},{"location":"ref-utils/#bofire.utils.subdomain.get_subdomain","title":"<code>get_subdomain(domain, feature_keys)</code>","text":"<p>removes all features not defined as argument creating a subdomain of the provided domain</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>the original domain wherefrom a subdomain should be created</p> required <code>feature_keys</code> <code>List</code> <p>List of features that shall be included in the subdomain</p> required <p>Exceptions:</p> Type Description <code>Assert</code> <p>when in total less than 2 features are provided</p> <code>ValueError</code> <p>when a provided feature key is not present in the provided domain</p> <code>Assert</code> <p>when no output feature is provided</p> <code>Assert</code> <p>when no input feature is provided</p> <code>ValueError</code> <p>description</p> <p>Returns:</p> Type Description <code>Domain</code> <p>A new domain containing only parts of the original domain</p> Source code in <code>bofire/utils/subdomain.py</code> <pre><code>def get_subdomain(\n    domain: Domain,\n    feature_keys: List,\n) -&gt; Domain:\n\"\"\"removes all features not defined as argument creating a subdomain of the provided domain\n\n    Args:\n        domain (Domain): the original domain wherefrom a subdomain should be created\n        feature_keys (List): List of features that shall be included in the subdomain\n\n    Raises:\n        Assert: when in total less than 2 features are provided\n        ValueError: when a provided feature key is not present in the provided domain\n        Assert: when no output feature is provided\n        Assert: when no input feature is provided\n        ValueError: _description_\n\n    Returns:\n        Domain: A new domain containing only parts of the original domain\n    \"\"\"\n    assert len(feature_keys) &gt;= 2, \"At least two features have to be provided.\"\n    outputs = []\n    inputs = []\n    for key in feature_keys:\n        try:\n            feat = domain.get_feature(key)\n        except KeyError:\n            raise ValueError(f\"Feature {key} not present in domain.\")\n        if isinstance(feat, Input):\n            inputs.append(feat)\n        else:\n            outputs.append(feat)\n    assert len(outputs) &gt; 0, \"At least one output feature has to be provided.\"\n    assert len(inputs) &gt; 0, \"At least one input feature has to be provided.\"\n    inputs = Inputs(features=inputs)\n    outputs = Outputs(features=outputs)\n    # loop over constraints and make sure that all features used in constraints are in the input_feature_keys\n    for c in domain.constraints:\n        for key in c.features:  # type: ignore\n            if key not in inputs.get_keys():\n                raise ValueError(\n                    f\"Removed input feature {key} is used in a constraint.\"\n                )\n    subdomain = deepcopy(domain)\n    subdomain.inputs = inputs\n    subdomain.outputs = outputs\n    return subdomain\n</code></pre>"},{"location":"ref-utils/#bofire.utils.torch_tools","title":"<code>torch_tools</code>","text":""},{"location":"ref-utils/#bofire.utils.torch_tools.constrained_objective2botorch","title":"<code>constrained_objective2botorch(idx, objective)</code>","text":"<p>Create a callable that can be used by <code>botorch.utils.objective.apply_constraints</code> to setup ouput constrained optimizations.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Index of the constraint objective in the list of outputs.</p> required <code>objective</code> <code>BotorchConstrainedObjective</code> <p>The objective that should be transformed.</p> required <p>Returns:</p> Type Description <code>Tuple[List[Callable[[Tensor], Tensor]], List[float]]</code> <p>List of callables that can be used by botorch for setting up the constrained objective, and     list of the corresponding botorch eta values.</p> Source code in <code>bofire/utils/torch_tools.py</code> <pre><code>def constrained_objective2botorch(\n    idx: int,\n    objective: ConstrainedObjective,\n) -&gt; Tuple[List[Callable[[Tensor], Tensor]], List[float]]:\n\"\"\"Create a callable that can be used by `botorch.utils.objective.apply_constraints`\n    to setup ouput constrained optimizations.\n\n    Args:\n        idx (int): Index of the constraint objective in the list of outputs.\n        objective (BotorchConstrainedObjective): The objective that should be transformed.\n\n    Returns:\n        Tuple[List[Callable[[Tensor], Tensor]], List[float]]: List of callables that can be used by botorch for setting up the constrained objective, and\n            list of the corresponding botorch eta values.\n    \"\"\"\n    assert isinstance(\n        objective, ConstrainedObjective\n    ), \"Objective is not a `ConstrainedObjective`.\"\n    if isinstance(objective, MaximizeSigmoidObjective):\n        return [lambda Z: (Z[..., idx] - objective.tp) * -1.0], [\n            1.0 / objective.steepness\n        ]\n    elif isinstance(objective, MinimizeSigmoidObjective):\n        return [lambda Z: (Z[..., idx] - objective.tp)], [1.0 / objective.steepness]\n    elif isinstance(objective, TargetObjective):\n        return [\n            lambda Z: (Z[..., idx] - (objective.target_value - objective.tolerance))\n            * -1.0,\n            lambda Z: (Z[..., idx] - (objective.target_value + objective.tolerance)),\n        ], [1.0 / objective.steepness, 1.0 / objective.steepness]\n    else:\n        raise ValueError(f\"Objective {objective.__class__.__name__} not known.\")\n</code></pre>"},{"location":"ref-utils/#bofire.utils.torch_tools.get_initial_conditions_generator","title":"<code>get_initial_conditions_generator(strategy, transform_specs, ask_options=None, sequential=True)</code>","text":"<p>Takes a strategy object and returns a callable which uses this strategy to return a generator callable which can be used in botorch<code>s</code>gen_batch_initial_conditions` to generate samples.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>Strategy</code> <p>Strategy that should be used to generate samples.</p> required <code>transform_specs</code> <code>Dict</code> <p>Dictionary indicating how the samples should be transformed.</p> required <code>ask_options</code> <code>Dict</code> <p>Dictionary of keyword arguments that are passed to the <code>ask</code> method of the strategy. Defaults to {}.</p> <code>None</code> <code>sequential</code> <code>bool</code> <p>If True, samples for every q-batch are generate indepenent from each other. If False, the <code>n x q</code> samples are generated at once.</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable[[int, int, int], Tensor]</code> <p>Callable that can be passed to     <code>batch_initial_conditions</code>.</p> Source code in <code>bofire/utils/torch_tools.py</code> <pre><code>def get_initial_conditions_generator(\n    strategy: Strategy,\n    transform_specs: Dict,\n    ask_options: Optional[Dict] = None,\n    sequential: bool = True,\n) -&gt; Callable[[int, int, int], Tensor]:\n\"\"\"Takes a strategy object and returns a callable which uses this\n    strategy to return a generator callable which can be used in botorch`s\n    `gen_batch_initial_conditions` to generate samples.\n\n    Args:\n        strategy (Strategy): Strategy that should be used to generate samples.\n        transform_specs (Dict): Dictionary indicating how the samples should be\n            transformed.\n        ask_options (Dict, optional): Dictionary of keyword arguments that are\n            passed to the `ask` method of the strategy. Defaults to {}.\n        sequential (bool, optional): If True, samples for every q-batch are\n            generate indepenent from each other. If False, the `n x q` samples\n            are generated at once.\n\n    Returns:\n        Callable[[int, int, int], Tensor]: Callable that can be passed to\n            `batch_initial_conditions`.\n    \"\"\"\n    if ask_options is None:\n        ask_options = {}\n\n    def generator(n: int, q: int, seed: int) -&gt; Tensor:\n        if sequential:\n            initial_conditions = []\n            for _ in range(n):\n                candidates = strategy.ask(q, **ask_options)\n                # transform it\n                transformed_candidates = strategy.domain.inputs.transform(\n                    candidates, transform_specs\n                )\n                # transform to tensor\n                initial_conditions.append(\n                    torch.from_numpy(transformed_candidates.values).to(**tkwargs)\n                )\n            return torch.stack(initial_conditions, dim=0)\n        else:\n            candidates = strategy.ask(n * q, **ask_options)\n            # transform it\n            transformed_candidates = strategy.domain.inputs.transform(\n                candidates, transform_specs\n            )\n            return (\n                torch.from_numpy(transformed_candidates.values)\n                .to(**tkwargs)\n                .reshape(n, q, transformed_candidates.shape[1])\n            )\n\n    return generator\n</code></pre>"},{"location":"ref-utils/#bofire.utils.torch_tools.get_linear_constraints","title":"<code>get_linear_constraints(domain, constraint, unit_scaled=False)</code>","text":"<p>Converts linear constraints to the form required by BoTorch.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>Optimization problem definition.</p> required <code>constraint</code> <code>Union[LinearEqualityConstraint, LinearInequalityConstraint]</code> <p>Type of constraint that should be converted.</p> required <code>unit_scaled</code> <code>bool</code> <p>If True, transforms constraints by assuming that the bound for the continuous features are [0,1]. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Tuple[Tensor, Tensor, float]]</code> <p>List of tuples, each tuple consists of a tensor with the feature indices, coefficients and a float for the rhs.</p> Source code in <code>bofire/utils/torch_tools.py</code> <pre><code>def get_linear_constraints(\n    domain: Domain,\n    constraint: Union[LinearEqualityConstraint, LinearInequalityConstraint],\n    unit_scaled: bool = False,\n) -&gt; List[Tuple[Tensor, Tensor, float]]:\n\"\"\"Converts linear constraints to the form required by BoTorch.\n\n    Args:\n        domain (Domain): Optimization problem definition.\n        constraint (Union[LinearEqualityConstraint, LinearInequalityConstraint]): Type of constraint that should be converted.\n        unit_scaled (bool, optional): If True, transforms constraints by assuming that the bound for the continuous features are [0,1]. Defaults to False.\n\n    Returns:\n        List[Tuple[Tensor, Tensor, float]]: List of tuples, each tuple consists of a tensor with the feature indices, coefficients and a float for the rhs.\n    \"\"\"\n    constraints = []\n    for c in domain.constraints.get(constraint):\n        indices = []\n        coefficients = []\n        lower = []\n        upper = []\n        rhs = 0.0\n        for i, featkey in enumerate(c.features):  # type: ignore\n            idx = domain.get_feature_keys(Input).index(featkey)\n            feat = domain.get_feature(featkey)\n            if feat.is_fixed():  # type: ignore\n                rhs -= feat.fixed_value()[0] * c.coefficients[i]  # type: ignore\n            else:\n                lower.append(feat.lower_bound)  # type: ignore\n                upper.append(feat.upper_bound)  # type: ignore\n                indices.append(idx)\n                coefficients.append(\n                    c.coefficients[i]  # type: ignore\n                )  # if unit_scaled == False else c_scaled.coefficients[i])\n        if unit_scaled:\n            lower = np.array(lower)\n            upper = np.array(upper)\n            s = upper - lower\n            scaled_coefficients = s * np.array(coefficients)\n            constraints.append(\n                (\n                    torch.tensor(indices),\n                    -torch.tensor(scaled_coefficients).to(**tkwargs),\n                    -(rhs + c.rhs - np.sum(np.array(coefficients) * lower)),  # type: ignore\n                )\n            )\n        else:\n            constraints.append(\n                (\n                    torch.tensor(indices),\n                    -torch.tensor(coefficients).to(**tkwargs),\n                    -(rhs + c.rhs),  # type: ignore\n                )\n            )\n    return constraints\n</code></pre>"},{"location":"ref-utils/#bofire.utils.torch_tools.get_multiobjective_objective","title":"<code>get_multiobjective_objective(outputs)</code>","text":"<p>Returns</p> <p>Parameters:</p> Name Type Description Default <code>outputs</code> <code>Outputs</code> <p>description</p> required <p>Returns:</p> Type Description <code>Callable[[Tensor], Tensor]</code> <p>description</p> Source code in <code>bofire/utils/torch_tools.py</code> <pre><code>def get_multiobjective_objective(\n    outputs: Outputs,\n) -&gt; Callable[[Tensor, Optional[Tensor]], Tensor]:\n\"\"\"Returns\n\n    Args:\n        outputs (Outputs): _description_\n\n    Returns:\n        Callable[[Tensor], Tensor]: _description_\n    \"\"\"\n    callables = [\n        get_objective_callable(idx=i, objective=feat.objective)  # type: ignore\n        for i, feat in enumerate(outputs.get())\n        if feat.objective is not None  # type: ignore\n        and isinstance(\n            feat.objective,  # type: ignore\n            (MaximizeObjective, MinimizeObjective, CloseToTargetObjective),\n        )\n    ]\n\n    def objective(samples: Tensor, X: Optional[Tensor] = None) -&gt; Tensor:\n        return torch.stack([c(samples, None) for c in callables], dim=-1)\n\n    return objective\n</code></pre>"},{"location":"ref-utils/#bofire.utils.torch_tools.get_nchoosek_constraints","title":"<code>get_nchoosek_constraints(domain)</code>","text":"<p>Transforms NChooseK constraints into a list of non-linear inequality constraint callables that can be parsed by pydantic. For this purpose the NChooseK constraint is continuously relaxed by countig the number of zeros in a candidate by a sum of narrow gaussians centered at zero.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>Optimization problem definition.</p> required <p>Returns:</p> Type Description <code>List[Callable[[Tensor], float]]</code> <p>List of callables that can be used     as nonlinear equality constraints in botorch.</p> Source code in <code>bofire/utils/torch_tools.py</code> <pre><code>def get_nchoosek_constraints(domain: Domain) -&gt; List[Callable[[Tensor], float]]:\n\"\"\"Transforms NChooseK constraints into a list of non-linear inequality constraint callables\n    that can be parsed by pydantic. For this purpose the NChooseK constraint is continuously\n    relaxed by countig the number of zeros in a candidate by a sum of narrow gaussians centered\n    at zero.\n\n    Args:\n        domain (Domain): Optimization problem definition.\n\n    Returns:\n        List[Callable[[Tensor], float]]: List of callables that can be used\n            as nonlinear equality constraints in botorch.\n    \"\"\"\n\n    def narrow_gaussian(x, ell=1e-3):\n        return torch.exp(-0.5 * (x / ell) ** 2)\n\n    def max_constraint(indices: Tensor, num_features: int, max_count: int):\n        return lambda x: narrow_gaussian(x=x[..., indices]).sum(dim=-1) - (\n            num_features - max_count\n        )\n\n    def min_constraint(indices: Tensor, num_features: int, min_count: int):\n        return lambda x: -narrow_gaussian(x=x[..., indices]).sum(dim=-1) + (\n            num_features - min_count\n        )\n\n    constraints = []\n    # ignore none also valid for the start\n    for c in domain.constraints.get(NChooseKConstraint):\n        assert isinstance(c, NChooseKConstraint)\n        indices = torch.tensor(\n            [domain.get_feature_keys(ContinuousInput).index(key) for key in c.features],\n            dtype=torch.int64,\n        )\n        if c.max_count != len(c.features):\n            constraints.append(\n                max_constraint(\n                    indices=indices, num_features=len(c.features), max_count=c.max_count\n                )\n            )\n        if c.min_count &gt; 0:\n            constraints.append(\n                min_constraint(\n                    indices=indices, num_features=len(c.features), min_count=c.min_count\n                )\n            )\n    return constraints\n</code></pre>"},{"location":"ref-utils/#bofire.utils.torch_tools.get_output_constraints","title":"<code>get_output_constraints(outputs)</code>","text":"<p>Method to translate output constraint objectives into a list of callables and list of etas for use in botorch.</p> <p>Parameters:</p> Name Type Description Default <code>outputs</code> <code>Outputs</code> <p>Output feature object that should be processed.</p> required <p>Returns:</p> Type Description <code>Tuple[List[Callable[[Tensor], Tensor]], List[float]]</code> <p>List of constraint callables,     list of associated etas.</p> Source code in <code>bofire/utils/torch_tools.py</code> <pre><code>def get_output_constraints(\n    outputs: Outputs,\n) -&gt; Tuple[List[Callable[[Tensor], Tensor]], List[float]]:\n\"\"\"Method to translate output constraint objectives into a list of\n    callables and list of etas for use in botorch.\n\n    Args:\n        outputs (Outputs): Output feature object that should\n            be processed.\n\n    Returns:\n        Tuple[List[Callable[[Tensor], Tensor]], List[float]]: List of constraint callables,\n            list of associated etas.\n    \"\"\"\n    constraints = []\n    etas = []\n    for idx, feat in enumerate(outputs.get()):\n        if isinstance(feat.objective, ConstrainedObjective):  # type: ignore\n            iconstraints, ietas = constrained_objective2botorch(\n                idx, objective=feat.objective  # type: ignore\n            )\n            constraints += iconstraints\n            etas += ietas\n    return constraints, etas\n</code></pre>"}]}